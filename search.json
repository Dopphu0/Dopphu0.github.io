[{"title":"Hexo的Kaze主题除首页外无法搜索的问题","url":"/2023/04/14/hexo%E7%AC%94%E8%AE%B0/","content":"解决方法关于Hexo的Kaze主题有一个bug，这个bug在Kaze的github仓库issue中已经有人提出了，\n解释了bug产生的原因，作者目前正在考虑重构search功能\n搜索功能在首页之外不可用 · Issue #75 · theme-kaze&#x2F;hexo-theme-kaze · GitHub\n我个人在经过读源码（瞎读的，因为不了解js和ejs）有个不成熟的解决办法，仅供参考。\nKaze中layout文件夹下有一个layout.ejs文件，最下面有一段代码\n\n绿色是作者源码，我把里面内容改了，经过试验，可以在其他页面进行搜索了。\n下面是一些废话，可以不看\n我的思考(其实最后还是代码给面子，一改就成了)根据bug发现者的描述，产生bug的原因是search.json文件的路径出现了错误，我也有了解决的大概思路。我不断翻Kaze的文件，想从中找出哪个方法的search.json的路径出错了。\n由于我们在写页面的时候一般习惯把相应功能的js写在html元素附近，所以我先在博客的首页搜索框附近找js文件或代码，很幸运源码展示的似乎就是我们一般的习惯写法。\n\n当然这是马后炮了，我当时也是试着去看main.js有没有需要的线索，确实有localSearch方法的定义，但是很遗憾我最后也没看懂是干嘛的。\n    window.localSearch = function(e) &#123;        fetch(e).then((e = &gt;e.json())).then((e = &gt;&#123;            let t = document.getElementById(&quot;search-input&quot;),            o = document.getElementById(&quot;search-content&quot;);            t.addEventListener(&quot;input&quot;, (function() &#123;                let t = &#x27;&lt;ul class=&quot;search-result-list&quot;&gt;&#x27;,                n = this.value.trim().toLowerCase().replace(/[&lt;&gt;&amp;&quot;]/g, (e = &gt;(&#123;                    &quot;&lt;&quot;: &quot;&lt;&quot;,                    &quot;&gt;&quot;: &quot;&gt;&quot;,                    &quot;&amp;&quot;: &quot;&amp;&quot;,                    &#x27;&quot;&#x27;: &quot;&quot;&quot;                &#125; [e])));                if (o.innerHTML = &quot;&quot;, !(this.value.trim().length &lt;= 0)) &#123;                    if (e.forEach((function(e) &#123;                        let o = !0;                        e.title &amp;&amp; &quot;&quot; !== e.title.trim() || (e.title = &quot;Untitled&quot;);                        let l = e.title.trim().toLowerCase();                        const s = e.content.trim().replace(/&lt;[^&gt;]+&gt;/g, &quot;&quot;).toLowerCase();                        let c = -1;                        const i = l.indexOf(n);                        let r = 0;                        if (&quot;&quot; !== s &amp;&amp; (r = s.indexOf(n), c = r), i &lt; 0 &amp;&amp; r &lt; 0 &amp;&amp; (o = !1), r &lt; 0 &amp;&amp; (c = 0), o) &#123;                            t += ` &lt; li &gt; &lt;a href = &quot;$&#123;e.url&#125;&quot;class = &quot;search-result-title&quot; &gt; &#x27;$&#123;l&#125;&lt;/a&gt;`;const o=e.content;if(c&gt;=0)&#123;const e=Math.max(0,c-12),l=Math.min(o.length,c+12);let s=o.substr(e,l);s=s.replace(new RegExp(n,&quot;gi&quot;),&#x27; &lt; em class = &quot;search-keyword&quot; &gt; &#x27;+n+&quot;&lt;/em&gt;&quot;),t+=&#x27; &lt; p class = &quot;search-result&quot; &gt; &#x27;+s+&quot;...&lt;/p&gt;&quot;&#125;t+=&quot;&lt;/li&gt;&quot;&#125;&#125;)),t+=&quot;&lt;/ul&gt;&quot;,-1===t.indexOf(&quot;&lt;li&gt;&quot;))return o.innerHTML=&#x27; &lt; ul &gt; &lt;span class = &quot;local-search-empty&quot; &gt; 没有搜索到结果 &lt; span &gt; &lt;/ul&gt;&#x27;;o.innerHTML=t&#125;&#125;))&#125;))&#125;&#125;();/\n\n但是我了解到似乎是在通过这个方法发送请求，即发送搜索框的内容，接收返回来的搜索数据。但是search.json还是不知道在哪给的路径，猜测可能是作为该方法的参数给的。\n继续翻文件夹，我又发现了script/generators/search.js这个文件，似乎和搜索有关\n/*  Source: https://github.com/forsigner/hexo-search/blob/master/index.js  License: MIT License  Modify: songhn for hexo-theme-kaze*//* global hexo */&#x27;use strict&#x27;// eslint-disable-next-line camelcaseconst url_for = require(&#x27;hexo-util&#x27;).url_for.bind(hexo)hexo.extend.generator.register(&#x27;_hexo_generator_search&#x27;, function (locals) &#123;  const config = hexo.theme.config  if (!config.search || !config.search.enable || !config.search.path) &#123;    return  &#125;  const searchSource = config.search.field.trim()  const posts = locals.posts.sort(&#x27;-date&#x27;)  const pages = locals.pages  let sources = []  if (searchSource != &#x27;&#x27; &amp;&amp; searchSource != &#x27;all&#x27;) &#123;    if (searchSource == &#x27;posts&#x27;) &#123;      sources = posts.data    &#125; else if (searchSource == &#x27;pages&#x27;) &#123;      sources = pages.data    &#125;  &#125; else &#123;    sources = posts.data.concat(pages.data)  &#125;  let data = []  sources.forEach((post) =&gt; &#123;    let categories = []    let tags = []    if (post.layout == &#x27;post&#x27;) &#123;      if (post.categories !== &#x27;undefined&#x27;) &#123;        post.categories.data.forEach(function (categorie) &#123;          categories.push(categorie.name)        &#125;)      &#125;      if (post.tags !== &#x27;undefined&#x27;) &#123;        post.tags.data.forEach(function (tag) &#123;          tags.push(tag.name)        &#125;)      &#125;    &#125;    data.push(&#123;      title: post.title,      url: url_for(`$&#123;post.path&#125;`),      content: config.search.searchContent        ? post.content.replace(/&lt;[^&lt;&gt;]+&gt;/g, &#x27;&#x27;)        : &#x27;&#x27;,      categories: categories,      tags: tags,    &#125;)  &#125;)  return &#123;    path: &#x27;/search.json&#x27;,    data: JSON.stringify(data),  &#125;&#125;)\n\n观察几个if判断，发现page、all、post这几个值，这是我们在Kaze主题中可以配置的搜索范围，接着看到返回值，猜测这可能就是返回的搜索解果，但是这个path不知道是干啥的，按理来说搜索完，就不需要json文件了才对。（这也可能就是Kaze文档中说search的path配置项无用的原因）\n所以，按照之前的猜测，search.json是网站生成的时候就有的，localSearch的参数就可能是json文件的路径。\n\n然后我们去找是怎么渲染这个script标签的，因为搜索功能在nav，我们去找layout下的nav.ejs，果然在这里，我也看不懂什么意思，直接改。\n\n然后就很给面子，其他页面也可以搜索了\n\n","categories":["Hexo"],"tags":["踩坑","Hexo"]},{"title":"this 关键字的使用","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%9B%9B%E7%AB%A0/this%20%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%BF%E7%94%A8/","content":"/** * this 关键字的使用 *  * this 可以理解为当前对象，可以修饰调用属性、方法、构造器 * 当类的形参和属性重名时，可以用this进行区分 *  * this修饰、调用构造器 * \t\t我们在类的构造其中可以使用this(形参列表) * \t\t构造器不能自己调自己，否则就像是死循环，也不能几个构造器环形调用，一直掉下去没完了 * \t\t因此，至少有一个构造器不能用this调用构造器 * \t\t另外，构造器用this调用时，只能位于首行，因此也只能this调一个 */package chapter04;/** * @author Dopphu * *///import chapter04.Animal;public class TestKeyWord_this &#123;\tpublic static void main(String[] args) &#123;\t\tPerson1 p1 = new Person1();\t\tPerson1 p2 = new Person1(&quot;Dopphu&quot;,12);\t\tp1.show();\t&#125;&#125;class Person1&#123;\tprivate String name;\tprivate int id;\t\tpublic Person1() &#123;\t\tthis.name = &quot;Tom&quot;;\t\t//一顿操作\t&#125;\tpublic Person1(String s) &#123;\t\tthis();//this调用构造器\t\tthis.name = s;\t&#125;\t\tpublic Person1(String s,int a) &#123;\t\tthis(s);//this调用构造器\t\tthis.id = a;\t&#125;\t\tvoid show() &#123;\t\tSystem.out.println(this);\t&#125;\tvoid setName(String name) &#123;\t\tthis.name = name;\t&#125;&#125;\n\n","categories":["Java Language Basics","第四章 面向对象(上)"],"tags":[]},{"title":"package关键字的使用","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%9B%9B%E7%AB%A0/package%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%BF%E7%94%A8/","content":"/** * package关键字的使用 * \t1.为了更好地实现项目中类的管理，提供包的概念 * \t2.使用package声明类或接口所属的包，声明在源文件的首行 * \t3.包，属于标识符，遵循标识符的命名规则（xxxzzzyyy） * \t4.每.一次代表一层文件目录 *  * 补充：同一个包下，不能命名同名的接口、类 * \t\t不同的包下可以命名同名的接口、类 */package chapter04;/** * @author Dopphu * */public class TestPackage &#123;&#125;\n\n","categories":["Java Language Basics","第四章 面向对象(上)"],"tags":[]},{"title":"JavaBean是什么","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%9B%9B%E7%AB%A0/JavaBean%E6%98%AF%E4%BB%80%E4%B9%88/","content":"/** * JavaBean是一种Java语言写成的可重用组件 *  * 所谓JavaBean，是指符合如下标准的Java类 * \t&gt; 类是公共的 *  &gt; 有一个无参的公共的构造器 *  &gt; 有属性，且有对应的get、set方法 */package chapter04;/** * @author Dopphu * */public class TestJavaBean &#123;&#125;class CustomerTest&#123;\tprivate int id;\tprivate String name;\t\tpublic CustomerTest() &#123;\t\t\t&#125;\t\tpublic void setId(int i) &#123;\t\tid = i;\t&#125;\tpublic void setName(String n) &#123;\t\tname = n;\t&#125;\tpublic int getId() &#123;\t\treturn id;\t&#125;\tpublic String getName() &#123;\t\treturn name;\t&#125;&#125;\n\n","categories":["Java Language Basics","第四章 面向对象(上)"],"tags":[]},{"title":"import关键字的使用","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%9B%9B%E7%AB%A0/import%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%BF%E7%94%A8/","content":"/** * import 关键字的使用 * import：导入 * 1.在源文件中显式地使用import结构导入指定包下的类、接口 * 2.声明在包的声明和类的声明之间 * 3.如果导入多个结构，并列写出即可 * 4.可以用*，导入包下所有结构 * 5.如果使用的类或接口是java.lang包下定义的（如String），则可以省略import结构 * 6.如果使用的类或接口是本包下，也不用import导入 * 7.如果在源文件中使用了不同包下的同名的类，则必须至少有一个类要用全类名 * 8.使用“xxx.*”方式表名可以调用xxx包下的所有结构。但是如果使用的是xxx子包下的结构，仍需要显示导入 *  * 9.import static:导入指定类或接口中的静态结构：属性或方法 */package chapter04;import java.util.Scanner;/** * @author Dopphu * */public class TestImport &#123;\tpublic static void main(String[] args) &#123;\t\tScanner scan = new Scanner(System.in);\t\t//\t\t不同包的同名变量的使用，全类名\t\tchapter04.Person1 a = new chapter04.Person1();\t&#125;&#125;\n\n","categories":["Java Language Basics","第四章 面向对象(上)"],"tags":[]},{"title":"12 属性赋值的先后顺序","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%9B%9B%E7%AB%A0/12%20%E5%B1%9E%E6%80%A7%E8%B5%8B%E5%80%BC%E7%9A%84%E5%85%88%E5%90%8E%E9%A1%BA%E5%BA%8F/","content":"/** * 属性赋值的先后顺序 *  * 1.默认初始化 * 2.显式初始化 * 3.构造器中赋值 * 4.通过&quot;对象.属性&quot;或&quot;对象.方法&quot; *  * 2在3之前，即\t\t1-2-3-4 *  */package chapter04;/** * @author Dopphu * */public class Test0412 &#123;\tpublic static void main(String[] args) &#123;\t\tTestClass1 demo = new TestClass1();\t\tSystem.out.println(demo.age);//12\t\t\t&#125;&#125;class TestClass1&#123;\tint age = 1;//显式赋值\tpublic TestClass1() &#123;\t\tage = 12;\t&#125;&#125;\n\n","categories":["Java Language Basics","第四章 面向对象(上)"],"tags":[]},{"title":"11 构造器","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%9B%9B%E7%AB%A0/11%20%E6%9E%84%E9%80%A0%E5%99%A8/","content":"/** * 类的结构之构造器（构造方法、constructor）的使用 * 一、构造器的作用 * \t\t创建对象 * \t\t初始化对象的信息 * 二、说明 * \t1.如果没有显式定义类的构造器的话，则系统会默认提供一个空参的构造器 * \t2.定义构造器的格式：权限修饰符 类名(形参列表)&#123;&#125; * \t3.构造器也可以重载 * \t4.一旦自己显式定义了类的构造器之后，系统就不再提供空参的构造器了 * \t5.一个类中，至少会有一个构造器 */package chapter04;/** * @author Dopphu * */public class Test0411 &#123;\tpublic static void main(String[] args) &#123;\t\tSomeOne demo = new SomeOne(&quot;Tom&quot;,12);\t\t\t&#125;&#125;class SomeOne&#123;\tString name;\tint age;\t//构造器\tpublic SomeOne() &#123;\t\tSystem.out.println(&quot;构造器SomeOne...&quot;);\t&#125;\t//使用构造器给对象初始化\tpublic SomeOne(String s,int a) &#123;\t\tname = s;\t\tage = a;\t&#125;\t\tpublic void show() &#123;\t\tSystem.out.println(&quot;name:&quot;+name+&quot; age:&quot;+age);\t&#125;&#125;\n\n","categories":["Java Language Basics","第四章 面向对象(上)"],"tags":[]},{"title":"10 啥也不写就是缺省","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%9B%9B%E7%AB%A0/10%20%E5%95%A5%E4%B9%9F%E4%B8%8D%E5%86%99%E5%B0%B1%E6%98%AF%E7%BC%BA%E7%9C%81/","content":"/** *  */package chapter04;/** * @author Dopphu * */public class Test0410Class &#123;\tprivate int orderP;\tint orderQ;\tvoid showQ() &#123;\t\tSystem.out.println(&quot;缺省&quot;);\t&#125;\t&#125;\n\n关于权限修饰符:\n\n","categories":["Java Language Basics","第四章 面向对象(上)"],"tags":[]},{"title":"09 面向对象特征之一:封装和隐藏","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%9B%9B%E7%AB%A0/09%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%89%B9%E5%BE%81%E4%B9%8B%E4%B8%80_%E5%B0%81%E8%A3%85%E5%92%8C%E9%9A%90%E8%97%8F/","content":"/** * 面向对象特征之一：封装和隐藏 * 我们程序设计追求 “高内聚，低耦合” * &gt; 高内聚：类内部数据操作细节自己完成，不允许外部干涉 * &gt; 低耦合：仅对外暴露少量的方法用于自己使用 *  * 隐藏对象内部的复杂性，对外公开简单的接口。便于外界调用，从而提高系统 * 的可扩展性、可维护性。通俗的说，把该隐藏的隐藏起来，改暴露的暴露出来。 * 这就是封装性的设计思想 *  * 封装性的体现： * \t\t我们将类的属性私有化（private），同时，提供公共（public）的方法来获取（getXxx）和设置（setXxx） *  * \t\t拓展：封装性的体现 * \t\t\t①如上 * \t\t\t②不对外暴露的私有的方法  * \t\t\t③单列模式 *  * 权限修饰符 * \t1. Java规定的4种权限（从小到大）：private、缺省（啥也没写）、protected、public * \t2. 4种权限可以修饰类及类的内部结构：属性、方法、构造器、内部类 * \t3. 具体的，4种权限都可以用来修饰类的内部结构。修饰类的话，只能使用缺省和public *  * 总结封装性：Java提供了四种权限修饰符来修饰类和类的内部结构，体现了类及类的内部结构在被调用时的可加性的大小。 */package chapter04;/** * @author Dopphu * */public class Test0409 &#123;\tpublic static void main(String[] args) &#123;\t\tAnimal a = new Animal();\t\ta.name = &quot;大黄&quot;;\t\ta.age = 1;//\t\ta.legs = 4;\t\ta.show();\t\ta.setLegs(100);\t\ta.show();\t&#125;&#125;class Animal&#123;\tString name;\tint age;\tprivate int legs;//腿的个数,配合方法限制legs&gt;=0\t\tpublic void eat() &#123;\t\tSystem.out.println(&quot;进食&quot;);\t&#125;\t\tpublic void show() &#123;\t\tSystem.out.println(&quot;name=&quot;+ name+&quot; age=&quot;+ age+&quot; legs=&quot;+legs);\t&#125;\tpublic void setLegs(int l) &#123;\t\tif(l&gt;=0) &#123;\t\t\tlegs = l;\t\t&#125;else &#123;\t\t\tlegs = 0;\t\t&#125;\t&#125;\t\tpublic int getLegs() &#123;\t\treturn legs;\t&#125;&#125;\n\n","categories":["Java Language Basics","第四章 面向对象(上)"],"tags":[]},{"title":"08 (参数传递)关于变量的复制","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%9B%9B%E7%AB%A0/08%20(%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92)%E5%85%B3%E4%BA%8E%E5%8F%98%E9%87%8F%E7%9A%84%E5%A4%8D%E5%88%B6/","content":"/** * 关于变量的赋值 *  * \t如果变量是基本数据类型，此时赋值的是变量所保存的数据值 * \t如果变量是引用数据类型，此时赋值的是变量所保存的数据的地址值 *  * 方法形参的传递机制： * \t\t值传递机制：如果参数是基本数据类型，此时实参赋给形参的是实参真是储存的数据值。 * \t\t */package chapter04;/** * @author Dopphu * */public class Test0408 &#123;\tpublic static void main(String[] args) &#123;\t\tData data = new Data();\t\t\t\tdata.m = 10;\t\tdata.n = 999;\t\tSystem.out.println(&quot;m = &quot;+data.m +&quot;;n = &quot;+data.n);\t\tswap(data);\t\tSystem.out.println(&quot;m = &quot;+data.m +&quot;;n = &quot;+data.n);\t\t\t&#125;\t//给数组换的话可以往里边传索引（下标）\t//这样实现值交换\tstatic void swap(Data d) &#123;\t\tint temp = d.m;\t\td.m=d.n;\t\td.n=temp;\t\t\t&#125;&#125;class Data&#123;\tint m;\tint n;&#125;\n\n","categories":["Java Language Basics","第四章 面向对象(上)"],"tags":[]},{"title":"07 JDK5允许可变个数参数","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%9B%9B%E7%AB%A0/07%20JDK5%E5%85%81%E8%AE%B8%E5%8F%AF%E5%8F%98%E4%B8%AA%E6%95%B0%E5%8F%82%E6%95%B0/","content":"/** * JDK5.0 允许可变个数参数(可以的话，优先调用固定个数的) * 1.调用可变个数形参方法时，传入的参数可以是0个、1个、2个... * 2.可变个数形参的方法中与本类方法名相同，形参不同的方法之间构成重载 * 3.可变个数形参的方法与本类中方法名相同，形参类型也相同的数组之间不构成重载（二者不能共存，新特性之前就是用数组参数来实现的） * 4.可变个数的形参在方法的形参中必须声明在末尾 */package chapter04;/** * @author Dopphu * */public class Test0407JDk5Extra &#123;\tpublic static void main(String[] args) &#123;\t\tTest0407JDk5Extra demo = new Test0407JDk5Extra();\t\tdemo.show(&quot;123&quot;,&quot;abc&quot;);\t&#125;\tpublic void show(String ...strs) &#123;\t\tSystem.out.println(&quot;show(Stirng)&quot;+strs[1]);\t&#125;\t/**\t * \t * Description:\t * @author \t * @param str\t */\tpublic void show(String str) &#123;\t\tSystem.out.println(&quot;show(Stirng...)&quot;);\t&#125;\t//认为与可变一样，不能共存//\tpublic void show(String [] a) &#123;//\t\tSystem.out.println(&quot;show(Stirng...)&quot;);//\t&#125;&#125;\n\n","categories":["Java Language Basics","第四章 面向对象(上)"],"tags":[]},{"title":"06 方法的重载(overload)","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%9B%9B%E7%AB%A0/06%20%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD(overload)/","content":"/** * 方法的重载(overload)  * 1.定义：在同一个类中，允许存在一个以上的重名方法，只要它们的参数个数或类型不同即可 * 2.举例 * \t\tArrays类中重载的sort() / binarySearch() * 3.重载和方法权限修饰符、返回值类型、形参变量名、方法体都没有关系 */package chapter04;/** * @author Dopphu * */public class Test0406 &#123;\tpublic static void main(String[] args) &#123;\t\tOverLoadTest demo = new OverLoadTest();\t\tdemo.test1();\t\tdemo.test1(1);\t&#125;&#125;class OverLoadTest&#123;\tvoid test1() &#123;\t\tSystem.out.println(&quot;test1 no params&quot;);\t&#125;\tvoid test1(int a) &#123;\t\tSystem.out.println(&quot;test1 with 1 int param&quot;);\t&#125;&#125;\n\n","categories":["Java Language Basics","第四章 面向对象(上)"],"tags":[]},{"title":"05 万事万物皆对象and内存解析and匿名对象的使用","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%9B%9B%E7%AB%A0/05%20%E4%B8%87%E4%BA%8B%E4%B8%87%E7%89%A9%E7%9A%86%E5%AF%B9%E8%B1%A1and%E5%86%85%E5%AD%98%E8%A7%A3%E6%9E%90and%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BD%BF%E7%94%A8/","content":"/** * 一、理解万事万物皆对象 * 1.在JAVA语言范畴中，我们都将功能结构等封装到类中，通过类的实例化，来调用具体的功能结构 * \t\t&gt;Scanenr、String等 * \t\t&gt;文件：File * \t\t&gt;网络资源：URL * 2.涉及到Java语言与前端HTML、后端数据库交互时，前后端的结构在Java层面交互时，都体现为类、对象。 * 二、内存解析的说明 * \t 引用类型的变量，只可能存储两类值：null或地址 * 三、匿名对象的使用 * \t1.我们创建的对象没有显式赋给一个变量名，即为匿名对象 * \t2.特征：匿名对象只能调用一次 *  3.使用 */package chapter04;/** * @author Dopphu * */public class Test0405 &#123;\tpublic static void main(String[] args) &#123;\t\tPhone p = new Phone();\t\tSystem.out.println(p);\t\t\t\tp.sendEmail();\t\tp.playGame();\t\t\t\t\t\t//匿名对象\t\tnew Phone().sendEmail();\t\tnew Phone().playGame();\t\t\t\t//匿名对象的使用\t\tPhoneMall demo = new PhoneMall();\t\tdemo.show(p);\t&#125;&#125;class PhoneMall&#123;\t/**\t * \t * Description:\t * @author \t * @param p\t */\tpublic void show(Phone p) &#123;\t\tp.playGame();\t\tp.sendEmail();\t&#125;&#125;class Phone&#123;\tdouble price;//价格\t\tpublic void sendEmail()&#123;\t\tSystem.out.println(&quot;发送邮件&quot;);\t&#125;\t\tpublic void playGame() &#123;\t\tSystem.out.println(&quot;打游戏&quot;);\t&#125;&#125;\n\n内存解析:\n\n","categories":["Java Language Basics","第四章 面向对象(上)"],"tags":[]},{"title":"04 对象数组练习","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%9B%9B%E7%AB%A0/04%20%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84%E7%BB%83%E4%B9%A0/","content":"/** * 对象数组练习： * \t\t定义类Student，包含三个属性：学号number(int)，年级state(int)，成绩score(int)。 * \t创建20个学生对象，学号为1到20，年级和成绩都由随机数确定 * \t问题1：打印出3年级（state值为3）的学生信息 * \t问题2：使用冒泡排序按学生成绩排序，并遍历所有学生信息 *  * 提示：随机数Math.random() 返回值类型double；四舍五入取整Math.round(double d),返回值类型long *  */package chapter04;/** * @author Dopphu * */public class Test0404 &#123;\tpublic static void main(String[] args) &#123;\t\tint count = 20;\t\tStudent students[] = new Student[count];\t\tfor(int i = 0; i&lt;students.length; i++) &#123;\t\t\t//我第一次就没有加这句，警钟长鸣啊\t\t\tstudents[i] = new Student();\t\t\t\t\t\tstudents[i].number = i+1;\t\t\tstudents[i].state = (int)(Math.random()*4+1);\t\t\tstudents[i].score = (int)(Math.random()*100);\t\t&#125;\t\t//冒泡排序\t\tfor(int i = 0; i&lt;students.length-1; i++) &#123;\t\t\tfor(int j = 0; j&lt;(students.length-i-1); j++) &#123;\t\t\t\tif(students[j].score&gt;students[j+1].score) &#123;\t\t\t\t\tStudent temp = students[j];\t\t\t\t\tstudents[j] = students[j+1];\t\t\t\t\tstudents[j+1] = temp;\t\t\t\t\t\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t\tTest0404 demo = new Test0404();\t\tdemo.print(students);\t\t\t&#125;\t/*\t * \t */\t//遍历输出\t/**\t * \t * @author \t * @param stu\t */\tpublic void print(Student[] stu) &#123;\t\tfor(int i = 0; i&lt;stu.length; i++) &#123;\t\t\tSystem.out.println(&quot;学号：&quot;+stu[i].number+&quot;\\t年级：&quot;+stu[i].state+&quot;\\t成绩&quot;+stu[i].score+&quot;\\t&quot;);\t\t&#125;\t&#125;&#125;//Student类class Student&#123;\tint score;\tint number;\tint state;&#125;\n\n","categories":["Java Language Basics","第四章 面向对象(上)"],"tags":[]},{"title":"03 简单Circle类","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%9B%9B%E7%AB%A0/03%20%E7%AE%80%E5%8D%95Circle%E7%B1%BB/","content":"/** * 设计Circle类，计算圆的面积 */package chapter04;/** * @author Dopphu * */public class Test0403 &#123;\tpublic static void main(String[] args) &#123;\t\tCircle c1 = new Circle();\t\tc1.radius = 2;\t\tSystem.out.println(c1.Area());\t&#125;&#125;//圆class Circle&#123;\t//属性\tdouble radius;\t\t//求圆的面积\tpublic double Area() &#123;\t\treturn Math.PI*radius*radius;\t&#125;&#125;\n\n","categories":["Java Language Basics","第四章 面向对象(上)"],"tags":[]},{"title":"02 类中方法的声明和使用","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%9B%9B%E7%AB%A0/02%20%E7%B1%BB%E4%B8%AD%E6%96%B9%E6%B3%95%E7%9A%84%E5%A3%B0%E6%98%8E%E5%92%8C%E4%BD%BF%E7%94%A8/","content":"/** * 类中方法的声明和使用 *  * 方法：描述类应该具有的功能 * 比如：Math类：sqrt()\\random()\\... * \t   Scanner类：nextXxx()... * 方法的声明：权限修饰符 返回值类型 方法名(形参列表)&#123; * \t\t\t\t方法体 * \t\t\t&#125; * \t\t注意：static、final、abstract 来修饰的方法，后面再讲 *  * 说明： * \t\t1.关于权限修饰符 * \t\t\tjava规定的4种权限修饰符：private、public、缺省、protected * \t\t2.返回值类型：有返回值 VS 无返回值 * \t\t\t1）如果方法有返回值，则必须在方法声明时，指定返回值类型。同时方法中需要使用 * \t\t\treturn关键字来返回指定类型的变量或常量 * \t\t\t2）如果方法没有返回值，则方法声明时，使用void来表示。通常，没有返回值的方法就不使用 * \t\t\treturn了，但是，如果使用的话，只能“return;”表示结束此方法的意思。 * \t\t3.方法名：见名知意，属于标识符，遵循其规范 * \t\t4.形参列表：形参0个或多个 * \t\t5.方法体：方法功能的体现 *  * return关键字的使用 * \t\t1.使用范围：使用在方法体中 * \t\t2.作用： * \t\t\t（1）结束方法 * \t\t\t（2）针对有返回值类型的方法，使用“return 数据”方法返回所要的数据 * \t\t3.注意点：return 关键字后不可以声明执行语句 *  * 方法的使用：方法中可以调用其它方法，方法不能嵌套定义 */package chapter04;/** * @author Dopphu * */public class Test0402 &#123;\tpublic static void main(String[] args) &#123;\t\tCustomer c1 = new Customer();\t\tc1.name = &quot;Cats&quot;;\t\tSystem.out.println(c1.getNation(&quot;China&quot;));\t\tc1.test();\t&#125;&#125;//客户类class Customer&#123;\t//属性\tString name;\tint age;\tboolean isMale;\t\t//方法\tpublic void eat() &#123;\t\tSystem.out.println(&quot;客户吃饭&quot;);\t&#125;\t\tpublic void sleep(int hour) &#123;\t\tSystem.out.println(&quot;休息了&quot;+hour+&quot;小时&quot;);\t&#125;\t\tpublic String getName() &#123;\t\treturn name;\t&#125;\t\tpublic String getNation(String nation) &#123;\t\treturn &quot;我的国际是&quot;+nation;\t&#125;\t\tvoid test() &#123;\t\tSystem.out.println(&quot;这算是缺省么&quot;);\t&#125;&#125;\n\n","categories":["Java Language Basics","第四章 面向对象(上)"],"tags":[]},{"title":"01 类中属性的使用","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%9B%9B%E7%AB%A0/01%20%E7%B1%BB%E4%B8%AD%E5%B1%9E%E6%80%A7%E7%9A%84%E4%BD%BF%E7%94%A8/","content":"/** * 类中属性的使用 * 属性（成员变量）\tVS\t局部变量 * 1.相同点 * \t\t1.1定义变量的格式：数据类型\t变量名 = 变量值; * \t\t1.2先声明，后使用 * \t\t1.3变量都有其相对应的作用域 *  *  * 2.不同点 * \t\t2.1在类中声明的位置不同 * \t\t属性：直接定义在类的一对&#123;&#125;内 * \t\t局部变量：声明在方法内、方法形参、代码块内、构造器形参、构造器内部的变量 * \t\t2.2关于权限修饰符的不同 * \t\t属性：可以在声明属性时，指明其权限，使用权限修饰符。 * \t\t常用的权限修饰符：private、public、缺省、protected ——&gt;封装性 * \t\t2.3默认初始化值的情况 * \t\t属性：类的属性根据其类型，都有默认初始化值 * \t\t\t整型（byte、short、int、long）：0 * \t\t\t浮点型（float、double）：0.0 * \t\t\t字符型（char）：0或&#x27;\\u0000&#x27; * \t\t\t布尔型（boolean）：false * \t\t\t应用数据类型（类、数组、接口）：null * \t\t * \t\t局部变量：没有默认初始化值 * \t\t\t意味着，我们在调用局部变量之前，一定要显式赋值 * \t\t\t特别的，形参在调用时，赋值即可 * \t\t2.4在内存中加载的位置不同 * \t\t属性：加载到堆空间中（非static） * \t\t局部变量：加载到栈空间 */\tpackage chapter04;/** * @author Dopphu * */public class Test0401 &#123;\tpublic static void main(String[] args) &#123;\t\tUser demo = new User();\t\tdemo.talk(&quot;普通话&quot;);\t&#125;&#125;class User&#123;\tString name;\tint age;\t\tpublic void talk(String language) &#123;\t\tSystem.out.println(&quot;我们使用&quot;+language+&quot;进行交流。&quot;);\t&#125;\tpublic void think() &#123;\t\tint time;\t&#125;\t&#125;\n\n","categories":["Java Language Basics","第四章 面向对象(上)"],"tags":[]},{"title":"00 类和对象 初见","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%9B%9B%E7%AB%A0/00%20%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%20%E5%88%9D%E8%A7%81/","content":"/**j * 一、设计类，其实就是设计类的成员 * 属性 = 成员变量 = field = 域、字段 * 方法 = 成员方法 = 函数 =method * 创建类的对象 = 类的实例化 = 实例化 * 二、类和对象的使用（面向对象思想落地的实现） * 1.创建类，设计类的成员 * 2.创建类的对象 * 3.通过“对象.属性”、“对象.方法”调用对象的结构 * 三、如果创建了一个类的多个对象，则每个对象都独立拥有一套类的属性。（非static） * 意味着，如果我们修改了一个对象的属性a，则不影响其他对象的属性a的值 * 四、对象的内存解析https://www.bilibili.com/video/BV1Kb411W75N?p=183 */package chapter04;/** * @author Dopphu * */public class Test0400 &#123;\tpublic static void main(String[] args) &#123;\t\t//创建Person类的对象\t\tPerson p1 = new Person();\t\t//调用类的属性、方法\t\tp1.name = &quot;Dopp&quot;;\t\tSystem.out.println(p1.name);\t\t\t\t//调用方法\t\tp1.eat();\t\t\t\tPerson p2 = new Person();\t\tSystem.out.println(p2.name);//null\t\t\t\tPerson p3 = p1;\t\tSystem.out.println(p3.name);//Dopp\t\t//似乎这么做不会影响实参的值\t\tint a = 200;\t\tTest0400 t = new Test0400();\t\tt.test(a);//\t\tt.useArr(&#123;1,2,3&#125;);//这么做并不可以\t\tSystem.out.println(a);\t\t\t\t\t&#125;\tpublic void test(int a) &#123;\t\ta = 12;\t&#125;\t\tpublic void useArr(int[] a) &#123;\t\treturn;\t&#125;&#125;class Person&#123;\t//属性\tString name;\tint age = 1;\tboolean isMale;\t\t//方法\tpublic void eat() &#123;\t\tSystem.out.println(&quot;人可以吃饭&quot;);\t&#125;\t\tpublic void sleep() &#123;\t\tSystem.out.println(&quot;人可以睡觉&quot;);\t&#125;\t&#125;\n\n","categories":["Java Language Basics","第四章 面向对象(上)"],"tags":[]},{"title":"1002 注解的使用","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%8D%81%E7%AB%A0/1002%20%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%BF%E7%94%A8/","content":"package chapter10;import org.junit.Test;import java.lang.annotation.*;import java.util.ArrayList;import java.util.Date;import static java.lang.annotation.ElementType.*;/** * * 1.注解的使用 *  理解 Annotation 注解 * jdk 5.0 新增的内容 * *  在javaSE中，注解的使用目的比较简单，例如标记已经过时的功能，忽略警告等。在JavaEE/Android开发中 *  注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替JavaEE旧版中遗留的繁冗的代码 *  和XML配置 * * 2.Annotation 的使用示例 * 示例一：生成文档相关的注解 * 实例二：编译时进行格式检查（JDK内置的三个基本注解） *      @Override：限定重写父类方法，该注解只能用于方法 *      @Deprecated：用于表示所修饰的元素（类、方法等）已过时。通常是因为所修饰的结构危险或存在更好的选择 *      英 [ˈdeprikeitid] v. 不赞成, 反对( deprecate的过去式和过去分词 ) *      @SuppressWarnings：抑制编译器警告 * * 示例三：跟踪代码依赖性，实现替代配置文件的功能 * * 3.如何自定义注解：参照SuppressWarnings定义 *      1）注解声明为 @interface *      2）内部定义成员，通常使用value表示 *      3）可以指定成员的默认值，使用default定义 *      4）如果自定义注解没有成员，表明是一个标识作用 * * 如果注解有成员，在使用注释时，需要指定成员的值 * 自定义注解必须配上注解的信息处理流程（使用反射）才有意义 * 自定义注解通常都会指明两个元注解：Retention、Target * * * 4. jdk提供的四个元注解 *  元注解：对现有的注解进行说明的注解 *      &gt; Retention：指定所修饰的 Annotation 的声明周期；SOURCE/CLASS（默认行为）/RUNTIME *          只有声明为RUNTIME生命周期的注解，才能反射获取。 *      &gt; Target：用于指定被修饰的 Annotation 能用于修饰哪些程序元素 * *      ***以下出现频率较低*** *      &gt; Documented：表示所修饰的注解在被javadoc解析时，保留下来。 * *      &gt; Inherited：被他修饰的Annotation将具有继承性 * * 5.通过反射获取注解信息——到反射内容时系统讲解 * * 6. jdk 8 中注解的新特性：可重复注解、类型注解 *      6.1可重复注解 *          e.g. *              @MyAnnotation(&quot;111&quot;) *              @MyAnnotation(&quot;222&quot;) *          1) 在MyAnnotation上声明@Repeatable，成员值为MyAnnotations.class *          2) MyAnnotation的Target和Retention 与 MyAnnotations相同 *      6.2类型注解 *          ElementType.TYPE_PARAMETER 表示该注解能写在变量类型的声明语句中（如：泛型声明） *          ElementType.TYPE_USE 表示该注解能写在使用类型的任何语句中。 * * @author dopphu * @create 2021-04-12 21:05 */public class Test02 &#123;    public static void main(String[] args) &#123;        Person p = new Student();        p.walk();        Date date = new Date(2020,10,11);        System.out.println(date);        @SuppressWarnings(&quot;unused&quot;)//在Eclipse中的警告效果更加明显，括号里是可以写多个值        int num = 10;//        System.out.println(num);    &#125;    @Test    public void testAnnotation()&#123;        //反射代码        Class clazz = Person.class;        Annotation[] annotations = clazz.getAnnotations();        for(int i = 0; i&lt; annotations.length; i++)&#123;            System.out.println(annotations[i]);        &#125;    &#125;&#125;@MyAnnotation(value=&quot;123&quot;)@MyAnnotation(value=&quot;123444&quot;)//jdk 8 之前的写法//@MyAnnotations(&#123;@MyAnnotation(value=&quot;123&quot;),@MyAnnotation(value=&quot;123444&quot;)&#125;)class Person&#123;    private String name;    private int age;//    @MyAnnotation    public Person() &#123;    &#125;    public void walk()&#123;        System.out.println(&quot;人走路&quot;);    &#125;    public void eat()&#123;        System.out.println(&quot;人吃饭&quot;);    &#125;&#125;class Student extends Person implements Info0&#123;    @Override //可以在编译的时候进行校验，看你这个是不是重写    public void walk() &#123;        System.out.println(&quot;学生走路&quot;);    &#125;    @Override    public void show() &#123;        System.out.println(&quot;展示一下&quot;);    &#125;&#125;interface Info0&#123;    void show();&#125;//@Inherited@Repeatable(MyAnnotations.class)@Retention(RetentionPolicy.RUNTIME)@Target(&#123;TYPE/*类*/, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE, MODULE,TYPE_PARAMETER,TYPE_USE&#125;)@interface MyAnnotation&#123;    String value() default &quot;hello&quot;;&#125;@Retention(RetentionPolicy.RUNTIME)@Target(&#123;TYPE/*类*/, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE, MODULE&#125;)@interface MyAnnotations&#123;    MyAnnotation[] value();&#125;class Generic&lt;@MyAnnotation T&gt;&#123;//在这里修饰要在MyAnnotation的@TARGET 中加上TYPE_PARAMETER    public void show()&#123;        //在这里修饰要在MyAnnotation的@TARGET 中加上TYPE_USE        ArrayList&lt;@MyAnnotation String&gt; list = new ArrayList&lt;&gt;();        int num = (@MyAnnotation int) 10L;    &#125;&#125;\n\n","categories":["Java Language Basics","第十章 枚举类和注解"],"tags":[]},{"title":"1001 枚举类","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%8D%81%E7%AB%A0/1001%20%E6%9E%9A%E4%B8%BE%E7%B1%BB/","content":"package chapter10;/** * * 一、枚举类的使用 * 1.枚举类的理解：类的对象只有有限个，确定的，我们就称此类为枚举类 * 2.当需要定义一组常量时，强烈建议使用枚举类 * 3.如果枚举类中只有一个对象，则可以作为单例模式的实现方式 * * 二、如何定义枚举类 * 方式一：jdk5.0之前，自定义枚举类 * * 方式二：jdk5.0时可以使用enum关键字定义枚举类 *          说明：定义的枚举类默认继承于java.lang.Enum类 * * * 三、Enum类的常用方法 *          values() 方法：返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值 *          valueOf(String str)：可以把一个字符串转换为对应的的枚举类对象。要求字符串必须是枚举类对象名 *          toString()：返回当前枚举类对象常量的名称 * * 四、使用enum关键字定义的枚举类实现接口的情况 *      情况一：实现接口，在enum类中实现抽象方法 *      情况二： * @author dopphu * @create 2021-04-12 18:41 */public class Test01 &#123;    public static void main(String[] args) &#123;        Season spring = Season.SPRING;        System.out.println(spring);        System.out.println(&quot;*********分界线*********&quot;);        Season1 summer = Season1.SUMMER;        //toString()方法        System.out.println(summer.toString());        System.out.println(Season1.class.getSuperclass());        //values()        Season1[] values = Season1.values();        for(int i = 0; i &lt; values.length; i++)&#123;            System.out.println(values[i]);        &#125;        Thread.State[] values1 = Thread.State.values();        for(int i = 0; i&lt;values1.length; i++)&#123;            System.out.println(values1[i]);        &#125;        //valueOf(String objName)：根据提供的objName返回枚举类中对象名是objName的对象        Season1 winter = Season1.valueOf(&quot;WINTER&quot;);        //如果没有objName的枚举类对象，则抛异常：IllegalArgumentException//        Season1 winter1 = Season1.valueOf(&quot;WINTERasd&quot;);        System.out.println(winter);//        System.out.println(winter1);        summer.show();    &#125;&#125;class Season&#123;    //声明Season对象的属性,private final 修饰    private final String seasonName;    private final String seasonDesc;    //1.私有化类的构造器    private Season(String seasonName, String seasonDesc)&#123;        this.seasonDesc = seasonDesc;        this.seasonName = seasonName;    &#125;    //3.提供当前枚举类的多个对象    public static final Season SPRING = new Season(&quot;春天&quot;,&quot;春暖花开&quot;);    public static final Season SUMMER = new Season(&quot;夏天&quot;,&quot;夏日炎炎&quot;);    public static final Season AUTUMN = new Season(&quot;秋天&quot;,&quot;秋高气爽&quot;);    public static final Season WINTER = new Season(&quot;冬天&quot;,&quot;冬日凌冽&quot;);    //4.其他诉求1：获取枚举类对象的属性    public String getSeasonName()&#123;        return seasonName;    &#125;    public String getSeasonDesc() &#123;        return seasonDesc;    &#125;    //4.其他诉求2：提供toString()    @Override    public String toString() &#123;        return &quot;Season&#123;&quot; +                &quot;seasonName=&#x27;&quot; + seasonName + &#x27;\\&#x27;&#x27; +                &quot;, seasonDesc=&#x27;&quot; + seasonDesc + &#x27;\\&#x27;&#x27; +                &#x27;&#125;&#x27;;    &#125;&#125;//使用enum关键字来定义枚举类enum Season1 implements Info&#123;    //1.提供当前枚举类的对象，多个对象之间用“,”隔开，末尾对象“;”结束    SPRING(&quot;春天&quot;,&quot;春暖花开&quot;)&#123;        @Override        public void show() &#123;            System.out.println(&quot;春天是不灭之握&quot;);        &#125;    &#125;,    SUMMER(&quot;夏天&quot;,&quot;夏日炎炎&quot;)&#123;        @Override        public void show() &#123;            System.out.println(&quot;夏天我有小秘密，就不告诉你&quot;);        &#125;    &#125;,    AUTUMN(&quot;秋天&quot;,&quot;秋高气爽&quot;)&#123;        @Override        public void show() &#123;            System.out.println(&quot;秋天里没有爱情&quot;);        &#125;    &#125;,    WINTER(&quot;冬天&quot;,&quot;冬雷震震&quot;)&#123;        @Override        public void show() &#123;            System.out.println(&quot;大约在冬季&quot;);        &#125;    &#125;;    //2.声明Season对象的属性：private final 修饰    private final String seasonName;    private final String seasonDesc;    //3.私有化类的构造器    private Season1(String seasonName, String seasonDesc) &#123;        this.seasonName = seasonName;        this.seasonDesc = seasonDesc;    &#125;    //其他诉求1：获取枚举类对象的属性    public String getSeasonName() &#123;        return seasonName;    &#125;    public String getSeasonDesc() &#123;        return seasonDesc;    &#125;//    //其他诉求2：提供toString()//enum先不重写,有需要再重写//    @Override//    public String toString() &#123;//        return &quot;Season1&#123;&quot; +//                &quot;seasonName=&#x27;&quot; + seasonName + &#x27;\\&#x27;&#x27; +//                &quot;, seasonDesc=&#x27;&quot; + seasonDesc + &#x27;\\&#x27;&#x27; +//                &#x27;&#125;&#x27;;//    &#125;    //情况一//    @Override//    public void show() &#123;//        System.out.println(&quot;这是一个季节&quot;);//    &#125;&#125;interface Info&#123;    void show();&#125;\n\n","categories":["Java Language Basics","第十章 枚举类和注解"],"tags":[]},{"title":"了解ClassLoader","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0%E5%8F%8D%E5%B0%84/%E4%BA%86%E8%A7%A3ClassLoader/","content":"类加载器\n","categories":["Java Language Basics","第十四章 反射"],"tags":[]},{"title":"1203 泛型在继承方面的体现和通配符","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0/1203%20%E6%B3%9B%E5%9E%8B%E5%9C%A8%E7%BB%A7%E6%89%BF%E6%96%B9%E9%9D%A2%E7%9A%84%E4%BD%93%E7%8E%B0%E5%92%8C%E9%80%9A%E9%85%8D%E7%AC%A6/","content":"package chapter12;import org.junit.Test;import java.util.ArrayList;import java.util.Iterator;import java.util.List;/** * * 1.泛型在继承方面的体现 * * * 2.通配符 * * * @author dopphu * @create 2021-04-18 12:39 */public class Test1203 &#123;    /*    *    * 1.泛型在继承方面的体现:    *   虽然类A是类B的父类，但是G&lt;A&gt;和G&lt;B&gt;二者不具备字子父类关系，二者是并列关系    *       补充：类A是类B的父类，那么A&lt;G&gt;和B&lt;G&gt;具有子父类关系，可以体现多态    * */    @Test    public void test1()&#123;        Object obj = null;        String str = null;        obj = str;        Object[] arr1 = null;        String[] arr2 = null;        arr1 = arr2;        List&lt;Object&gt; list1 = null;        List&lt;String&gt; list2 = null;        //此时list1和list2不具有子父类关系        //编译不通过//        list1 = list2;        //编译不通过//        Date date = new Date();//        str = date;        /*        * 说明一下为什么list1 = list2;编译不通过        * 反证法：假设编译通过        * list1.add(123);就是可以的（因为是Object就可以），这将导致混入非String数据，那设置泛型就没有意义了        *        *        * */        //需要写两个方法        show(list1);        show1(list2);    &#125;    public void show1(List&lt;String&gt; list)&#123;    &#125;    public void show(List&lt;Object&gt; list)&#123;    &#125;    /*    * 2.通配符的使用    * 通配符：?    *   类A是类B的父类，G&lt;A&gt;和G&lt;B&gt;是没有关系的，二者共同的父类时：G&lt;?&gt;    *    * */    @Test    public void test2()&#123;        List&lt;Object&gt; list1 = null;        List&lt;String&gt; list2 = null;        List&lt;?&gt; list = null;        list = list1;        list = list2;        //编译通过的↓//        print(list1);//        print(list2);        //        List&lt;String&gt; list3 = new ArrayList&lt;&gt;();        list3.add(&quot;AA&quot;);        list3.add(&quot;BB&quot;);        list3.add(&quot;CC&quot;);        //添加：对于List&lt;?&gt;就不能向其内部添加数据        //除了添加null之外//        list.add(&quot;AA&quot;);//编译不通过        list3.add(null);        //获取（读取）：允许读取数据，读取数据类型为Object        Object o = list3.get(0);        System.out.println(o);    &#125;    public void print(List&lt;?&gt; list)&#123;        Iterator&lt;?&gt; iterator = list.iterator();        while(iterator.hasNext())&#123;            Object obj = iterator.next();            System.out.println(obj);        &#125;    &#125;    /*    *    * 有限制条件的通配符的使用    *   ? extends Person:    *       G&lt;? extend A&gt;可以作为G&lt;A&gt;或G&lt;B&gt;的父类，其中B是A的子类    *   ? super Person:    *       G&lt;? extend A&gt;可以作为G&lt;A&gt;或G&lt;B&gt;的父类，其中B是A的父类    *    *    * */    @Test    public void test3()&#123;        List&lt;? extends Person&gt; list1 = null;//看成 ≤        List&lt;? super Person&gt; list2 = null;//看成 ≥        List&lt;Student&gt; list3 = new ArrayList&lt;Student&gt;();        List&lt;Person&gt; list4 = new ArrayList&lt;Person&gt;();        List&lt;Object&gt; list5 = new ArrayList&lt;Object&gt;();        list1 = list3;        list1 = list4;//        list1 = list5;//        list2 = list3;        list2 = list4;        list2 = list5;        //读取数据        list1 = list4;        Person p= list1.get(0);        //编译不通过//        Student s = list1.get(0);        list2 = list4;        Object obj = list2.get(0);        //编译不通过//        Person obj2 = list2.get(0);        //写入数据        //编译不通过//        list1.add(new Student());        //编译通过        list2.add(new Person());        list2.add(new Student());    &#125;&#125;\n\n","categories":["Java Language Basics","第十二章 泛型"],"tags":[]},{"title":"1202 自定义泛型类、泛型接口、泛型方法","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0/1202%20%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B%E7%B1%BB%E3%80%81%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3%E3%80%81%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95/","content":"package chapter12;import org.junit.Test;import java.util.ArrayList;import java.util.List;/** 如何自定义泛型结构：泛型类、泛型接口 ：泛型方法。 * * 自定义泛型类 * * * 注：子类对于父类的泛型：全部保留、部分保留、不保留 * @author dopphu * @create 2021-04-17 18:16 */public class Test1202 &#123;    @Test    public void test1()&#123;        //如果定义了泛型类，实例化没有指明类的泛型，则认为此泛型类型为Object类型        Order order = new Order();        order.setOrderT(123);        order.setOrderT(&quot;ABC&quot;);        //建议：实例化时指明类的泛型        Order&lt;String&gt; order1 = new Order&lt;String&gt;(&quot;orderAA&quot;,1001,&quot;这是一个属性A&quot;);        System.out.println(order1.getOrderT());    &#125;    @Test    public void test2()&#123;        SubOrder sub1 = new SubOrder();        //由于子类在继承带泛型的父类时，指明了泛型类型。则实例化子类对象时，不再需要指明泛型类型。        sub1.setOrderT(1122);        SubOrder1&lt;String&gt; sub2 = new SubOrder1&lt;&gt;();        sub2.setOrderT(&quot;order...&quot;);    &#125;    @Test    public void test3()&#123;        //泛型不同的引用不能互相赋值        ArrayList&lt;String&gt; list1 = null;        ArrayList&lt;Integer&gt; list2 = new ArrayList&lt;Integer&gt;();//        list1 = list2;//编译报错    &#125;    //测试泛型方法    @Test    public void test4()&#123;        Order&lt;String&gt; order = new Order&lt;&gt;();        Integer[] arr = new Integer[]&#123;1,2,3,4&#125;;        //泛型方法在调用时，指明泛型参数的类型        List&lt;Integer&gt; list = order.copyFromArrayToList(arr);        System.out.println(list);    &#125;&#125;//自定义泛型类class Order&lt;T&gt;&#123;    String orderName;    int orderId;    //类的内部结构可以使用类的泛型    T orderT;    public Order()&#123;        // 想造T类型的数组       //编译不通过//        T[] arr = new T[10];//me：new的对象必须的指明的，emmm我其实也不知怎么理解(⊙_⊙?)        //编译通过        T[] arr = (T[]) new Object[10];//等往里边放对象如：arr[0]这就不要再arr[0] = new Object();了，这样会强转报错的    &#125;    public Order(String orderName,int orderId,T orderT)&#123;        this.orderName = orderName;        this.orderId = orderId;        this.orderT = orderT;    &#125;    public T getOrderT() &#123;        return orderT;    &#125;    public void setOrderT(T orderT) &#123;        this.orderT = orderT;    &#125;    @Override    public String toString() &#123;        return &quot;Order&#123;&quot; +                &quot;orderName=&#x27;&quot; + orderName + &#x27;\\&#x27;&#x27; +                &quot;, orderId=&quot; + orderId +                &quot;, orderT=&quot; + orderT +                &#x27;&#125;&#x27;;    &#125;    //静态方法中不能使用类的泛型 (me:因为静态结构的创建早于对象)//    public static void show()&#123;//        System.out.println(T orderT)&#123;//            System.out.println(orderT);//        &#125;//    &#125;//    public void show()&#123;//        try &#123;////        &#125;catch (T t)&#123;//编译不同过////        &#125;//    &#125;    //泛型方法：在方法中出现了泛型的结构，泛型参数与类泛型参数没有任何关系    //换句话说，泛型方法所属的类是不是泛型类都没有关系。    //泛型方法，可以声明为静态的。原因：泛型参数是在调用方法时确定的。并非在实例化类时确定    public static  &lt;E&gt; List&lt;E&gt; copyFromArrayToList(E[] arr)&#123;//List本身就是一个泛型类，List&lt;E&gt;这是用E来指定List的泛型        ArrayList list = new ArrayList();        for(E e:arr)&#123;            list.add(e);        &#125;        return list;    &#125;&#125;//异常类不能声明为泛型类//class MyException&lt;T&gt; extends Exception&#123;////&#125;\n\n","categories":["Java Language Basics","第十二章 泛型"],"tags":[]},{"title":"1201 泛型———>jdk 5.0的新增的特性","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0/1201%20%E6%B3%9B%E5%9E%8B%E2%80%94%E2%80%94%E2%80%94jdk%205.0%E7%9A%84%E6%96%B0%E5%A2%9E%E7%9A%84%E7%89%B9%E6%80%A7/","content":"package chapter12;import org.junit.Test;import java.util.*;/** * 泛型———&gt;jdk 5.0的新增的特性 * 1. jdk 5.0新增的特性 * 2.在集合中使用泛型： *      总结： *          1）集合接口或集合类在jdk5.0时都修改为带泛型的结构。（所以我们使用的时候才能用&lt;类型&gt;来限定） *          2）在实例化集合类时，可以指明具体的泛型类型 *          3）指明完以后，在集合类或接口中凡是定义类或接口时，内部结构使用到类的泛型的位置（比如：方法、构造器、属性等）都指定为实例化时指定的泛型类型 *              比如：add(E e) ——&gt; 实例化以后：add(Integer e) *          4）注意点：泛型的类型必须是类，不能是基本数据类型。需要用到基本数据类型的位置，拿包装类替换。 *          5）如果实例化时没有指明泛型的类型，默认类型为java.lang.Object类型 * * 3.如何自定义泛型结构：泛型类、泛型接口；泛型方法 * * @author dopphu * @create 2021-04-17 16:47 */public class Test1201 &#123;    //在集合中使用泛型之前的情况    @Test    public void test1()&#123;        ArrayList list = new ArrayList();        //需求：存放学生的成绩        list.add(78);        list.add(89);        list.add(45);        list.add(66);        //问题一：类型不安全//        list.add(&quot;Tom&quot;);        for(Object score:list)&#123;            int stuScore = (Integer)score;            System.out.println(stuScore);        &#125;    &#125;    //在集合中使用泛型的情况    @Test    public void test2()&#123;        //泛型中好像不能用基本数据类型//        ArrayList&lt;int&gt; list = new ArrayList&lt;int&gt;();        ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();        list.add(12);        list.add(78);        list.add(89);        list.add(100);        list.add(56);        //编译时，就会进行类型检查，保证数据的安全//        list.add(&quot;asd&quot;);        for (Integer score: list)&#123;            //避免了强制类型转换(因为强转是很容易出错的)            int stuScore = score;            System.out.println(stuScore);        &#125;        System.out.println(&quot;-------------------------&quot;);        //方式二：        Iterator&lt;Integer&gt; iterator = list.iterator();        while(iterator.hasNext())&#123;            int stuScore = iterator.next();            System.out.println(stuScore);        &#125;    &#125;    @Test    public void test3()&#123;        Map&lt;String,Integer&gt; map = new HashMap&lt;String, Integer&gt;();        map.put(&quot;Tom&quot;,3);        map.put(&quot;Jerry&quot;,2);        map.put(&quot;Jack&quot;,66);        //泛型的嵌套        Set&lt;Map.Entry&lt;String,Integer&gt;&gt; entrySet = map.entrySet();        Iterator&lt;Map.Entry&lt;String,Integer&gt;&gt; iterator = entrySet.iterator();        while (iterator.hasNext())&#123;            Map.Entry&lt;String,Integer&gt; e = iterator.next();            String key = e.getKey();            Integer value = e.getValue();            System.out.println(key+&quot;——&gt;&quot;+value);        &#125;    &#125;&#125;\n\n","categories":["Java Language Basics","第十二章 泛型"],"tags":[]},{"title":"UDP协议的网络编程","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0/UDP%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/","content":"package chapter13Net;import org.junit.Test;import java.io.IOException;import java.net.*;/** * * UDP协议的网络编程 * @author dopphu * @create 2021-04-24 19:43 */public class Test0314 &#123;    //发送端    @Test    public void sender() throws IOException &#123;        DatagramSocket socket = new DatagramSocket();        String str = &quot;吃我犹大的世界第一可爱重击&quot;;        byte[] data = str.getBytes();        InetAddress inet = InetAddress.getLocalHost();        DatagramPacket packet = new DatagramPacket(data,0,data.length,inet,9090);        socket.send(packet);        socket.close();    &#125;    //接收端    @Test    public void receiver() throws IOException &#123;        DatagramSocket socket = new DatagramSocket(9090);        byte[] buffer = new byte[100];        DatagramPacket packet = new DatagramPacket(buffer,0,buffer.length);        socket.receive(packet);        System.out.println(new String(packet.getData(),0,packet.getLength()));        socket.close();    &#125;&#125;\n\n","categories":["Java Language Basics","第十三章 File和IO"],"tags":[]},{"title":"1314 URL","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0/1314%20URL/","content":"package chapter13Net;/** * * URL网络编程 * 1. URl：统一资源定位符，对应着互联网的某一资源地址 * 2. 格式： *      http://localhost:8080/examples/beauty.jpg?username=Tom *      协议      主机名  端口号    资源地址            参数列表 * @author dopphu * @create 2021-04-24 20:00 */public class Test1314 &#123;    public static void main(String[] args) &#123;//        URL url = new URL(&quot;&quot;);        /*        * 常用方法：见截图        *        *        *        * *///        获取资源的方法演示见:https://www.bilibili.com/video/BV1Kb411W75N?p=630&amp;spm_id_from=pageDriver    &#125;&#125;\n\n","categories":["Java Language Basics","第十三章 File和IO"],"tags":[]},{"title":"1313 客户端发送文件给服务器，服务器保存到本地。并返回“发送成功”给客户端。并关闭相应的连接","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0/1313%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8F%91%E9%80%81%E6%96%87%E4%BB%B6%E7%BB%99%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BF%9D%E5%AD%98%E5%88%B0%E6%9C%AC%E5%9C%B0%E3%80%82%E5%B9%B6%E8%BF%94%E5%9B%9E%E2%80%9C%E5%8F%91%E9%80%81%E6%88%90%E5%8A%9F%E2%80%9D%E7%BB%99%E5%AE%A2%E6%88%B7%E7%AB%AF%E3%80%82%E5%B9%B6%E5%85%B3%E9%97%AD%E7%9B%B8%E5%BA%94%E7%9A%84%E8%BF%9E%E6%8E%A5/","content":"package chapter13Net;import org.junit.Test;import java.io.*;import java.net.InetAddress;import java.net.ServerSocket;import java.net.Socket;/** * * 实现TCP的网络编程 *  * 例题3：从客户端发送文件给服务器，服务器保存到本地。并返回“发送成功”给客户端。 *  * 并关闭相应的连接。 * @author dopphu * @create 2021-04-24 19:16 */public class Test1313 &#123;    @Test    public void cilent()&#123;        Socket socket = null;        OutputStream os = null;        FileInputStream fis = null;        ByteArrayOutputStream baos = null;        try &#123;            //1.            socket = new Socket(InetAddress.getByName(&quot;127.0.0.1&quot;),9090);            //2.            os = socket.getOutputStream();            //3.            fis = new FileInputStream(new File(&quot;未标题-1.png&quot;));            //4.            byte[] buffer = new byte[1024];            int len;            while ((len = fis.read(buffer))!=-1)&#123;                os.write(buffer,0,len);            &#125;            //关闭数据数据的输出            socket.shutdownOutput();            //5.接收来自于服务器的数据，并显示到控制台上            InputStream is = socket.getInputStream();            baos = new ByteArrayOutputStream();            byte[] buffer2 = new byte[20];            int len1;            while ((len1 = is.read(buffer2)) != -1)&#123;                baos.write(buffer2,0,len1);            &#125;            System.out.println(baos.toString());        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; finally &#123;            //6.关闭连接            if(fis!=null)&#123;                try &#123;                    fis.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;            if(os!=null)&#123;                try &#123;                    os.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;            if(socket!=null)&#123;                try &#123;                    socket.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;            if(baos!=null)&#123;                try &#123;                    baos.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;    /* 还是要用try-catch-finally */    @Test    public void server() throws IOException &#123;        ServerSocket ss = new ServerSocket(9090);        Socket socket = ss.accept();        InputStream is = socket.getInputStream();        FileOutputStream fos = new FileOutputStream(new File(&quot;getFromclient2.jpg&quot;));        byte[] buffer = new byte[1024];        int len;        while ((len=is.read(buffer))!= -1)&#123;            fos.write(buffer,0,len);        &#125;        OutputStream os = socket.getOutputStream();        os.write(&quot;你好照片已经收到了&quot;.getBytes());        fos.close();        is.close();        socket.close();        ss.close();        os.close();    &#125;&#125;\n\n","categories":["Java Language Basics","第十三章 File和IO"],"tags":[]},{"title":"1312 客户端发送文件给服务器，服务端将文件保存在本地","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0/1312%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8F%91%E9%80%81%E6%96%87%E4%BB%B6%E7%BB%99%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8C%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%B0%86%E6%96%87%E4%BB%B6%E4%BF%9D%E5%AD%98%E5%9C%A8%E6%9C%AC%E5%9C%B0/","content":"package chapter13Net;import org.junit.Test;import java.io.*;import java.net.InetAddress;import java.net.ServerSocket;import java.net.Socket;/** * * 实现TCP的网络编程 * 例题2：客户端发送文件给服务器，服务端将文件保存在本地 * * @author dopphu * @create 2021-04-24 18:46 */public class Test1312 &#123;    @Test    public void cilent()&#123;        Socket socket = null;        OutputStream os = null;        FileInputStream fis = null;        try &#123;            //1.            socket = new Socket(InetAddress.getByName(&quot;127.0.0.1&quot;),9090);            //2.            os = socket.getOutputStream();            //3.            fis = new FileInputStream(new File(&quot;未标题-1.png&quot;));            //4.            byte[] buffer = new byte[1024];            int len;            while ((len = fis.read(buffer))!=-1)&#123;                os.write(buffer,0,len);            &#125;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; finally &#123;            if(fis!=null)&#123;                try &#123;                    fis.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;            if(os!=null)&#123;                try &#123;                    os.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;            if(socket!=null)&#123;                try &#123;                    socket.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;    /* 还是要用try-catch-finally */    @Test    public void server() throws IOException &#123;        ServerSocket ss = new ServerSocket(9090);        Socket socket = ss.accept();        InputStream is = socket.getInputStream();        FileOutputStream fos = new FileOutputStream(new File(&quot;getFromclient.jpg&quot;));        byte[] buffer = new byte[1024];        int len;        while ((len=is.read(buffer))!= -1)&#123;            fos.write(buffer,0,len);        &#125;        fos.close();        is.close();        socket.close();        ss.close();    &#125;&#125;\n\n","categories":["Java Language Basics","第十三章 File和IO"],"tags":[]},{"title":"1311 客户端发送信息给服务器，服务器将数据显示在控制台上","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0/1311%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8F%91%E9%80%81%E4%BF%A1%E6%81%AF%E7%BB%99%E6%9C%8D%E5%8A%A1%E5%99%A8%EF%BC%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B0%86%E6%95%B0%E6%8D%AE%E6%98%BE%E7%A4%BA%E5%9C%A8%E6%8E%A7%E5%88%B6%E5%8F%B0%E4%B8%8A/","content":"package chapter13Net;import org.junit.Test;import java.io.*;import java.net.InetAddress;import java.net.ServerSocket;import java.net.Socket;/** * * 实现TCP的网络编程 * 例子1：客户端发送信息给服务器，服务器将数据显示在控制台上 * * * @author dopphu * @create 2021-04-23 19:55 */public class Test1311 &#123;    //客户端    @Test    public void client()&#123;        Socket socket = null;        OutputStream os = null;        try &#123;            //1. 创建Socket对象，指明服务器端的ip和端口号            InetAddress inet = InetAddress.getByName(&quot;127.0.0.1&quot;);            socket = new Socket(inet,8899);            //2. 获取一个输出流，用于输出数据            os = socket.getOutputStream();            //3. 写出资源的操作            os.write(&quot;你好，我是客户端mm&quot;.getBytes());        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; finally &#123;            //4. 资源的关闭            if (os!=null)&#123;                try &#123;                    os.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;            if(socket!=null)&#123;                try &#123;                    socket.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;    //服务端    @Test    public void server()&#123;        ServerSocket ss = null;        Socket socket = null;        InputStream is = null;        ByteArrayOutputStream baos = null;        try &#123;            //1. 创建服务器端的ServerSocket，指明自己的端口号            ss = new ServerSocket(8899);            //2. 调用accept()表示接受来自于客户端的socket            socket = ss.accept();            //获取输入流            is = socket.getInputStream();            //不建议这样写，应为可能会有乱码（字符串往byte数组中存）//        byte[] buffer = new byte[20];//        int len;//        while ((len = is.read(buffer))!=-1)&#123;//            String str = new String(buffer,0,len);//            System.out.println(str);//        &#125;            //4.读取输入流中的数据            baos = new ByteArrayOutputStream();            byte[] buffer = new byte[5];            int len;            while ((len = is.read(buffer))!=-1)&#123;                baos.write(buffer,0,len);            &#125;            System.out.println(baos.toString());            //获取消息发送方            System.out.println(&quot;收到了来自于：&quot; + socket.getInetAddress().getHostAddress() + &quot;数据&quot;);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; finally &#123;            //资源关闭            if (baos!=null)&#123;                try &#123;                    baos.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;            if(is!=null)&#123;                try &#123;                    is.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;            if(socket!=null)&#123;                try &#123;                    socket.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;            if(ss!=null)&#123;                try &#123;                    ss.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;        //关闭资源    &#125;&#125;\n\n","categories":["Java Language Basics","第十三章 File和IO"],"tags":[]},{"title":"1310 网络编程","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0/1310%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/","content":"package chapter13Net;import java.net.InetAddress;import java.net.UnknownHostException;/** * * 一、网络编程中有两个主要的问题 * 1.如何准确定位网络上的一台或多台主机；定位主机上的特定的应用。 * 2.找到主机之后，如何高效可靠地进行数据传输 * * 二、网络编程中的两个要素： *      对应问题一：IP和端口号 *      对应问题二：提供网络通信协议：TCP/IP参考模型（应用层、传输层、网络层、物理+数据链路层） * 三、通信要素一：IP和端口号 *  1.IP：唯一的标识Internet上的计算机（通信实体） *  2.在Java中使用InetAdress类代表IP *  3.IP分类：IPv4 和 IPv6 ； 万维网 和 局域网 *  4.域名： www.baidu.com *  5.本地回路地址：127.0.0.1 对应着：localhost *  6.如何实例化InetAddress：两个方法:getHostName(String host)、getHostAddress() *      两个常用方法：getHostName() / getHostAddress() *  7.端口号 *      要求：不同的进程有不同的端口号 *      范围：被规定为一个16位的整数 0~65535 *  8.端口号与IP地址的组合得出一个网络套接字：Socket * * @author dopphu * @create 2021-04-23 19:13 */public class Test1310 &#123;    public static void main(String[] args) &#123;        InetAddress inet1 = null;        try &#123;            inet1 = InetAddress.getByName(&quot;192.168.10.16&quot;);            System.out.println(inet1);            InetAddress inet2 = InetAddress.getByName(&quot;www.baidu.com&quot;);            System.out.println(inet2);            //获取本机的IP            InetAddress inet3 = InetAddress.getLocalHost();            System.out.println(inet3);        &#125; catch (UnknownHostException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\n\n","categories":["Java Language Basics","第十三章 File和IO"],"tags":[]},{"title":"1309 RandomAccessFile的使用","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0/1309%20RandomAccessFile%E7%9A%84%E4%BD%BF%E7%94%A8/","content":"package chapter13;import org.junit.Test;import java.io.File;import java.io.IOException;import java.io.RandomAccessFile;/** * * RandomAccessFile的使用 * 1. RandomAccessFile 直接继承于java.lang.Object，实现了DataInput和DataOutput接口 * 2. 既可以做输出流也可以做输入流 * 3. 如果RandomAccessFile作为输出流时，写出到的文件如果不存在，从开头位置进行覆盖（比原来文件中短的话，就只覆盖前面的，后面的还和原文件中一样） * * 方法: long getFilePointer() : 获取文件记录指针的当前位置 *       void seek(long pos) : 将文件记录指针定位到pos位置 * * 见：https://www.bilibili.com/video/BV1Kb411W75N?p=617&amp;spm_id_from=pageDriver * @author dopphu * @create 2021-04-23 18:27 */public class Test1309 &#123;    @Test    public void test1()&#123;        RandomAccessFile raf1 = null;        RandomAccessFile raf2 = null;        try &#123;            raf1 = new RandomAccessFile(new File(&quot;未标题-1.png&quot;),&quot;r&quot;);            raf2 = new RandomAccessFile(new File(&quot;未标题-11.png&quot;),&quot;rw&quot;);            byte[] buffer = new byte[1024];            int len;            while ((len = raf1.read(buffer))!=-1)&#123;                raf2.write(buffer,0,len);            &#125;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; finally &#123;            if(raf1!=null)&#123;                try &#123;                    raf1.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;            if(raf2!=null)&#123;                try &#123;                    raf2.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;    /*测试第三点 3. */    @Test    public void test3() throws IOException &#123;        RandomAccessFile raf1 = new RandomAccessFile(&quot;hi2.txt&quot;,&quot;rw&quot;);        raf1.write(&quot;xsax&quot;.getBytes());        raf1.close();    &#125;&#125;\n\n","categories":["Java Language Basics","第十三章 File和IO"],"tags":[]},{"title":"1308 对象流的使用","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0/1308%20%E5%AF%B9%E8%B1%A1%E6%B5%81%E7%9A%84%E4%BD%BF%E7%94%A8/","content":"package chapter13;import org.junit.Test;import java.io.*;/** * * 对象流的使用 *  1. ObjectInputStream 和 ObjectOutputStream *  2. 作用：用于存储和读取基本数据类型或对象的处理流。它的强大之处就是可以把Java中的对象写入到 *  数据源中，也能把对象从数据源中还原回来。 * * *  什么样的类可以序列化？ *      以Person类为例，满足如下要求即可进行序列化 *          1. 实现Serializable（常用）或Externalizable接口 *          2. 需要当前类提供一个全局变量：seriaLVersionUID *              如：String中的private static final long serialVersionUID = -6849794470754667710L; *          3. 除了当前Person类需要实现serialVersionUID接口以外，还必须保证其内部的所有属性 *          也必须是可序列化的（比如：有一个Person有个Account类型的（一个类）属性，Account也必须是可序列化的）。（默认情况下，基本数据类型可序列化） *      补充：ObjectOutputStream和ObjectInputStream不能序列化static和transient修饰的成员 * 注：实现Serializable接口，将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会序列化到指定的目的地中。 * @author dopphu * @create 2021-04-21 21:05 */public class Test1308 &#123;    /*     *     * 序列化过程：将内存中的java对象保存到磁盘中或通过网络传输出去     * 使用ObjectOutputStream实现     * 注：写出去的文件主要是为了保存数据，不是让我们双击打开看的     * */    @Test    public void ObjectOutputStream()&#123;        ObjectOutputStream oos = null;        try &#123;            oos = new ObjectOutputStream(new FileOutputStream(&quot;object.dat&quot;));            oos.writeObject(new String(&quot;我爱北京天安门&quot;));        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; finally &#123;            try &#123;                if(oos!=null)&#123;                    oos.close();                &#125;            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;    /*    *    * 将对象从文件中还原出来——反序列化    *   使用ObjectInputStream来实现    * */    @Test    public void testObjectInputStream()&#123;        ObjectInputStream ois = null;        try &#123;            ois = new ObjectInputStream(new FileInputStream(&quot;object.dat&quot;));            Object obj = ois.readObject();            String s = (String)obj;            System.out.println(s);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; catch (ClassNotFoundException e) &#123;            e.printStackTrace();        &#125; finally &#123;            try &#123;                if(ois!=null)&#123;                    ois.close();                &#125;            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;    /*    *    * 自定义类进行序列化和反序列化    *    * */    @Test    public void test3()&#123;//        oos = new ObjectOutputStream(new FileOutputStream(&quot;object.dat&quot;));//        oos.writeObject(new String(&quot;我爱北京天安门&quot;));        ObjectOutputStream oos = null;        try &#123;            oos = new ObjectOutputStream(new FileOutputStream(&quot;PersonDemo.dat&quot;));            oos.writeObject(new Person(&quot;Jerry&quot;,2));            oos.flush();            oos.writeObject(new String(&quot;123asd&quot;));            oos.flush();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; finally &#123;            if(oos!=null)&#123;                try &#123;                    oos.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;        ObjectInputStream ois = null;        try &#123;            ois = new ObjectInputStream(new FileInputStream(&quot;PersonDemo.dat&quot;));            //me：读取的顺序是和写入的顺序是一致的；否则报错：            //java.lang.ClassCastException: class chapter13.Person cannot be cast to class java.lang.String (chapter13.Person is in unnamed module of loader &#x27;app&#x27;; java.lang.String is in module java.base of loader &#x27;bootstrap&#x27;)            Person p = (Person)ois.readObject();            String str = (String)ois.readObject();            System.out.println(p);            System.out.println(str);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; catch (ClassNotFoundException e) &#123;            e.printStackTrace();        &#125; finally &#123;            if(ois!=null)&#123;                try &#123;                    ois.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;&#125;class Person implements Serializable&#123;    private static final long serialVersionUID = -6849794480754667710L;//String 类中的    String name;    int age;    public Person() &#123;    &#125;    public Person(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;    @Override    public String toString() &#123;        return &quot;Person&#123;&quot; +                &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +                &quot;, age=&quot; + age +                &#x27;&#125;&#x27;;    &#125;&#125;\n\n","categories":["Java Language Basics","第十三章 File和IO"],"tags":[]},{"title":"1307 其它流的使用","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0/1307%20%E5%85%B6%E5%AE%83%E6%B5%81%E7%9A%84%E4%BD%BF%E7%94%A8/","content":"package chapter13;import org.junit.Test;/** * * 其它流的使用 * 1. 标准的输入、输出流 * 2. 打印流 * 3. 数据流 * * * @author dopphu * @create 2021-04-21 20:17 */public class Test1307 &#123;    /*    *    * 1.标准的输入、输出流    *  1.1    *  System.in:标准的输入流，默认从键盘输入    *  System.out:标准的输出流，默认从控制台输出    *  1.2    *  System类的setIn(InputStream is) / setOut(PrintStream ps)方式重新指定输入和输出的流    *  1.3练习：    *   从键盘输入字符串，要求将读取到的整行字符串转换成大写输出，然后继续进行输入操作    * 直至当输入“e”或者“exit”时，退出程序。    *    * 方法一：使用Scanner    * 方法二：使用System.in实现。System.in ——&gt; 转换流 ——&gt; BufferedReader的readLine()    *https://www.bilibili.com/video/BV1Kb411W75N?p=603&amp;spm_id_from=pageDriver    * */    /*    * 打印流：PrintStream 和 PrintWriter    * 2.1 提供了一系列重载的print() 和 println()    * */    /*    *https://www.bilibili.com/video/BV1Kb411W75N?p=605&amp;spm_id_from=pageDriver    * 数据流    *  DataInputStream 和 DataOutputStream    *   作用：用于读取或写出基本数据类型的变量或字符串    * */    @Test    public void test1()&#123;    &#125;&#125;\n\n","categories":["Java Language Basics","第十三章 File和IO"],"tags":[]},{"title":"1306 处理流之二：转换流的使用","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0/1306%20%E5%A4%84%E7%90%86%E6%B5%81%E4%B9%8B%E4%BA%8C%EF%BC%9A%E8%BD%AC%E6%8D%A2%E6%B5%81%E7%9A%84%E4%BD%BF%E7%94%A8/","content":"package chapter13;import org.junit.Test;import java.io.*;/** * * 处理流之二：转换流的使用 * 1. 转化流：属于字符流 *      InputStreamReader ：将一个字节的输入流转换为字符的输入流 *      OutputStreamWriter ：将一个字符的输出流转换为字节的输出流 * * 2. 作用：提供字节流与字符流之间的转换 * * 3. 解码：字节、字符数组 ——&gt; 字符数组、字符串 *    编码：字符数组、字符串 ——&gt; 字节、字节数组 * 4.字符集 *  ASCII：美国标准信息交换码 *      用一个字节的7位可以表示 *  ISO8859-1：拉丁码表。欧洲码表 *      用一个字节的八位表示 *  GB2321：中国的中文编码表。最多两个字节编码所有字符 *  GBK：中国的中文编码表的升级，融合了更多的中文文字符号。最多两个字节编码 *  Unicode：国际标准码。融合了目前人类使用的所有字符。为每个字符分配唯一的字符码。 *      所有的文字都用两个字节来表示 *  UTF-8：变长的编码方式，可用1-4个字节来表示一个字符 * * @author dopphu * @create 2021-04-20 19:34 */public class Test1306 &#123;    /*    *    * InputStreamReader的使用，实现字节的输入流到字符的输出流的转换    *    * */    @Test    public void test1()&#123;        InputStreamReader isr = null;        try &#123;            FileInputStream fis = new FileInputStream(&quot;hi.txt&quot;);//        InputStreamReader isr = new InputStreamReader(fis);//使用系统默认的字符            //参数2指明了字符集，具体使用哪个字符集，取决于文件保存时使用的字符集            isr = new InputStreamReader(fis,&quot;utf-8&quot;);            char[] cbuf = new char[20];            int len;            while ((len = isr.read(cbuf))!=-1)&#123;                String str = new String(cbuf,0,len);                System.out.println(str);            &#125;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; finally &#123;            try &#123;                if(isr!=null)&#123;                    isr.close();                &#125;            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;    /*    *    * 综合使用InputStreamReader和OutputStreamWriter    * 注：下面抛异常的方式处理是为了简便演示，开发中还是要用try-catch-finally    * */    @Test    public void test2() throws IOException &#123;        File file1 = new File(&quot;hi.txt&quot;);        File file2 = new File(&quot;h1_gbk.txt&quot;);        FileInputStream fis = new FileInputStream(file1);        FileOutputStream fos = new FileOutputStream(file2);        //解码        InputStreamReader isr = new InputStreamReader(fis,&quot;utf-8&quot;);        //编码        OutputStreamWriter osw = new OutputStreamWriter(fos,&quot;gbk&quot;);        //读写过程        char[] cbuf = new char[20];        int len;        while ((len = isr.read(cbuf))!=-1)&#123;            osw.write(cbuf,0,len);        &#125;        isr.close();        osw.close();    &#125;&#125;\n\n","categories":["Java Language Basics","第十三章 File和IO"],"tags":[]},{"title":"1305 图片简单的加密和解密","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0/1305%20%E5%9B%BE%E7%89%87%E7%AE%80%E5%8D%95%E7%9A%84%E5%8A%A0%E5%AF%86%E5%92%8C%E8%A7%A3%E5%AF%86/","content":"package chapter13;import org.junit.Test;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;/** * * 图片简单的加密和解密 * 注：下面的方法图片的大小不会发生改变 * * @author dopphu * @create 2021-04-20 19:12 */public class Test1305 &#123;    //图片的加密    @Test    public void test1()&#123;        FileInputStream fis = null;        FileOutputStream fos = null;        try &#123;            fis = new FileInputStream(new File(&quot;未标题-1.png&quot;));            //可以这样简洁一点写            fos = new FileOutputStream(&quot;未标题-1Secret加密版.png&quot;);            byte[] buffer = new byte[20];            int len;            while ((len = fis.read(buffer))!=-1)&#123;                //字符数组进行修改                //错误的:这样并不会对原有 数据进行修改（类似按值传递参数）    //            for (byte b : buffer)&#123;    //                b = (byte)(b^5);    //            &#125;                //正确的                for (int i = 0;i&lt;len;i++)&#123;                    buffer[i] = (byte)(buffer[i]^5);                &#125;                fos.write(buffer,0,len);            &#125;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; finally &#123;            try &#123;                if(fos!=null)&#123;                    fos.close();                &#125;            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;            try &#123;                if(fis!=null)&#123;                    fis.close();                &#125;            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;    //图片的解密    @Test    public void test2()&#123;        FileInputStream fis = null;        FileOutputStream fos = null;        try &#123;            fis = new FileInputStream(new File(&quot;未标题-1Secret加密版.png&quot;));            //可以这样简洁一点写            fos = new FileOutputStream(&quot;未标题-1Secret解密版.png&quot;);            byte[] buffer = new byte[20];            int len;            while ((len = fis.read(buffer))!=-1)&#123;                //字符数组进行修改                //错误的:这样并不会对原有 数据进行修改（类似按值传递参数）    //            for (byte b : buffer)&#123;    //                b = (byte)(b^5);    //            &#125;                //正确的                for (int i = 0;i&lt;len;i++)&#123;                    buffer[i] = (byte)(buffer[i]^5);                &#125;                fos.write(buffer,0,len);            &#125;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; finally &#123;            try &#123;                if(fos!=null)&#123;                    fos.close();                &#125;            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;            try &#123;                if(fis!=null)&#123;                    fis.close();                &#125;            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;\n\n","categories":["Java Language Basics","第十三章 File和IO"],"tags":[]},{"title":"1304 处理流之一：缓冲流的使用","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0/1304%20%E5%A4%84%E7%90%86%E6%B5%81%E4%B9%8B%E4%B8%80%EF%BC%9A%E7%BC%93%E5%86%B2%E6%B5%81%E7%9A%84%E4%BD%BF%E7%94%A8/","content":"package chapter13;import org.junit.Test;import java.io.*;/** * * 处理流之一：缓冲流的使用 * * 1.缓冲流 * BufferedInputStream * BufferedOutputStream * BufferedReader * BufferedWriter * * 2.作用：提供流的读取、写入的速度 * * @author dopphu * @create 2021-04-20 18:23 */public class Test1304 &#123;    /*    *    * 实现非文本文件的复制    *    * */    @Test    public void BufferedStreamTest()&#123;        BufferedInputStream bis = null;        BufferedOutputStream bos = null;        try &#123;            //1.造文件            File srcFile = new File(&quot;未标题-1.png&quot;);            File destFile = new File(&quot;未标题Copy2.png&quot;);            //2.造流            //2.1 造节点流            FileInputStream fis = new FileInputStream(srcFile);            FileOutputStream fos = new FileOutputStream(destFile);            //2.2 造缓冲流            bis = new BufferedInputStream(fis);            bos = new BufferedOutputStream(fos);            //3. 复制的细节：读取、写入            byte[] buffer = new byte[10];            int len;            while((len = bis.read(buffer))!=-1)&#123;                bos.write(buffer,0,len);//                bos.flush();/* 刷新缓冲区 */ //使用缓冲流会自动调用这个方法            &#125;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; finally &#123;            //4.资源关闭（现在包了一层，关闭流的顺序就有了要求）            //要求：先关闭外层的流，再关闭内层的流            try &#123;                if(bos!=null)&#123;                    bos.close();                &#125;            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;            try &#123;                if(bis!=null)&#123;                    bis.close();                &#125;            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;            //说明：关闭外层流的同时，内层流也会自动进行关闭。关于内层流的关闭，我们可以省略//        fos.close();//        fis.close();        &#125;    &#125;    //实现文件复制的方法    public void copyFileWithBuffered(String srcPath, String destPath) &#123;        BufferedInputStream bis = null;        BufferedOutputStream bos = null;        try &#123;            //1.造文件            File srcFile = new File(srcPath);            File destFile = new File(destPath);            //2.造流            //2.1 造节点流            FileInputStream fis = new FileInputStream(srcFile);            FileOutputStream fos = new FileOutputStream(destFile);            //2.2 造缓冲流            bis = new BufferedInputStream(fis);            bos = new BufferedOutputStream(fos);            //3. 复制的细节：读取、写入            byte[] buffer = new byte[1024];            int len;            while ((len = bis.read(buffer)) != -1) &#123;                bos.write(buffer, 0, len);            &#125;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; finally &#123;            //4.资源关闭（现在包了一层，关闭流的顺序就有了要求）            //要求：先关闭外层的流，再关闭内层的流            try &#123;                if (bos != null) &#123;                    bos.close();                &#125;            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;            try &#123;                if (bis != null) &#123;                    bis.close();                &#125;            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;    /* 测试缓冲流文件复制的操作 */    @Test    public void testCopyFileWithBuffered()&#123;        long start = System.currentTimeMillis();        copyFileWithBuffered(&quot;E:\\\\视频\\\\符华[A]ddiction _2160p_HDR_Extreme\\\\[A]ddiction _2160p_HDR_Extreme.mp4&quot;,&quot;E:\\\\视频\\\\符华[A]ddiction _2160p_HDR_Extreme\\\\copy.mp4&quot;);        long end = System.currentTimeMillis();        System.out.println(&quot;（withBuffered）所用毫秒数为：&quot; + (end - start) );    &#125;    /*    使用Buffered和BufferedWriter实现文本文件的复制     */    @Test    public void testBufferedReaderBufferedWriter() &#123;        BufferedReader br = null;        BufferedWriter bw = null;        try &#123;            //简洁一下            br = new BufferedReader(new FileReader(new File(&quot;hi.txt&quot;)));            bw = new BufferedWriter(new FileWriter(new File(&quot;hicopy&quot;)));            //读写操作            //方式一：//            char[] cbuf = new char[1024];//            int len;//            while ((len = br.read(cbuf))!=-1)&#123;//                bw.write(cbuf,0,len);//            &#125;            //方式二：            String data;            while ((data = br.readLine())!=null)&#123;                //方法1：//                bw.write(data+&quot;\\n&quot;);//data中不包含换行符                //方法2：                bw.write(data);                bw.newLine();//提供换行的操作            &#125;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; finally &#123;            //关闭资源            try &#123;                if(bw!=null)&#123;                    bw.close();                &#125;            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;            try &#123;                if(br!=null)&#123;                    br.close();                &#125;            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;\n\n","categories":["Java Language Basics","第十三章 File和IO"],"tags":[]},{"title":"1303 FileInputStream和FileOutPutStream的使用","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0/1303%20FileInputStream%E5%92%8CFileOutPutStream%E7%9A%84%E4%BD%BF%E7%94%A8/","content":"package chapter13;import org.junit.Test;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;/** * * 测试FileInputStream和FileOutPutStream的使用 * * 结论： *      1. 对于文本文件（.txt，.java，.c），使用字符流进行处理 *      2. 对于非文本文件(.jpg，.mp3，mp4，avi，doc，ppt)，使用字节流处理 * @author dopphu * @create 2021-04-19 20:57 */public class Test1303 &#123;    //使用字节流FileInputStream处理文本文件是可能出现乱码的    @Test    public void testFileInputStream1() &#123;        FileInputStream fis = null;        try &#123;            //1. 造文件            File file = new File(&quot;hi.txt&quot;);            //2. 造流            fis = new FileInputStream(file);            //3.读数据            byte[] buffer = new byte[5];            /* 注：utf-8中一个汉字要三个字节存，所以用byte数组可能会导致汉字被“劈开” */            int len;//记录每次读取的字节的个数            while((len = fis.read(buffer))!=-1)&#123;                String str = new String(buffer,0,len);                System.out.print(str);            &#125;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; finally &#123;            //4.关闭流资源            if(fis!=null)&#123;                try &#123;                    fis.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;    /*    * 实现对图片的复制操作    *    * */    @Test    public void testFileInputStream2()&#123;        FileInputStream fis = null;        FileOutputStream fos = null;        try &#123;            File srcFile = new File(&quot;未标题-1.png&quot;);            File destFile = new File(&quot;未标题-1copy.png&quot;);            fis = new FileInputStream(srcFile);            fos = new FileOutputStream(destFile);            //复制的过程            byte[] buffer = new byte[5];            int len;            while ((len = fis.read(buffer))!=-1)&#123;                fos.write(buffer,0,len);            &#125;            System.out.println(&quot;复制成功！&quot;);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; finally &#123;            try &#123;                if(fos!=null)&#123;                    fos.close();                &#125;            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;            try &#123;                if(fis!=null)&#123;                    fis.close();                &#125;            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;    void copyFile(String src,String dest)&#123;        FileInputStream fis = null;        FileOutputStream fos = null;        try &#123;            File srcFile = new File(src);            File destFile = new File(dest);            fis = new FileInputStream(srcFile);            fos = new FileOutputStream(destFile);            //复制的过程            byte[] buffer = new byte[1024];            int len;            while ((len = fis.read(buffer))!=-1)&#123;                fos.write(buffer,0,len);            &#125;            System.out.println(&quot;复制成功！&quot;);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; finally &#123;            try &#123;                if(fos!=null)&#123;                    fos.close();                &#125;            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;            try &#123;                if(fis!=null)&#123;                    fis.close();                &#125;            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;    //指定路径下文件的复制    @Test    public void testCopyFile()&#123;        long start = System.currentTimeMillis();        String srcPath = &quot;E:\\\\视频\\\\2021寒假翻山 (1).mp4&quot;;        String destPath = &quot;E:\\\\视频\\\\Copy.mp4&quot;;        copyFile(srcPath,destPath);        long end = System.currentTimeMillis();        System.out.println(end - start);    &#125;&#125;\n\n","categories":["Java Language Basics","第十三章 File和IO"],"tags":[]},{"title":"1302 IO原理及流的分类","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0/1302%20IO%E5%8E%9F%E7%90%86%E5%8F%8A%E6%B5%81%E7%9A%84%E5%88%86%E7%B1%BB/","content":"package chapter13;import org.junit.Test;import java.io.File;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;/** * * 一、IO流原理及流的分类 *  &gt; 按照作数据单位的不同： *       字节流（8 bit）——如：图片等非文本，字符流（16 bit）——如：文本 *  &gt; 按照数据流的流向不同分为：输入流、输出流 *  &gt; 按照流的角色不同分为：节点流、处理流 *       抽象基类    字节流         字符流 *        输入流    InputStream     Reader *        输出流    OutputStream    Writer * *       1. Java的IO流共涉及40多个类，实际上非常规则，都是从如下4个 *       抽象基类派生的。 *       2. 有这四个类派生出来调度子类名称都是以其父类名作为子类名的后缀 *  抽象基类            节点流（或文件流）       缓冲流（处理流的一种） *  InputStream         FileInputStream（read(byte[] buffer)）                  BufferedInputStream（read(byte[] buffer)） *  OutputStream        FileOutputStream（write(byte[] buffer, 0, len)）        BufferedOutputStream（write(byte[] buffer, 0, len)）/ flush() *  Reader              FileReader（read(char[] cbuf)）                         BufferedReader（read(char[] cbuf) / readLine()） *  Writer              FileWriter（write(char[] cbuf, 0, len)）                BufferedWriter（write(char[] cbuf, 0, len)） / flush() * * @author dopphu * @create 2021-04-19 18:25 */public class test1302 &#123;    public static void main(String[] args) &#123;        File file = new File(&quot;hello.txt&quot;);//相较于当前工程        //方法中的相对路径相对的是module        System.out.println(file.getAbsolutePath());    &#125;    /*    * 将硬盘中的文件读入到程序中，并输出到控制台    * 说明：    *   1. read()的理解：返回读入的一个字符。如果达到文件末尾，返回-1    *   2. 异常的处理 ：为了保证一定可以执行关闭类操作。需要使用try-catch-finally处理    *   3. 读入的文件一定要存在否则就会报FileNotFoundException    * */    @Test    public void testFileReader()&#123;        FileReader fr = null;//me：声明在外面，让finally后面可以关闭        try &#123;            //1.实例化File类的对象，指明要操作的文件            File file = new File(&quot;E:\\\\Java学习\\\\Java_IDEA_projects\\\\txtTest\\\\hello.txt&quot;);            //2.提供具体的流            fr = new FileReader(file);            //3.数据的读入            //read() : 返回读入的一个字符。如果到达文件末尾，返回-1            //原本的方式//        int data = fr.read();//        while (data!=-1)&#123;//            System.out.print((char)data);//            data = fr.read();//        &#125;            //优化一下 : 更加简洁，运行效率没有差别╮(╯_╰)╭            int data;            while((data = fr.read())!=-1)&#123;                System.out.print((char)data);            &#125;            System.out.println();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; finally &#123;            //4.流的关闭操作            /* 注：对于其它的物理连接，比如数据库连接、输入输入流、Socket连接，JVM无能为力(不会自动关闭) */            try &#123;                if(fr != null)                    fr.close();            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;        //抛异常的处理方式可能会导致流没有关闭，所以还是try-catch-finally进行处理    &#125;    /*    * 注：除了下面的重载的read()，还提供了一个重载的read()方法    * public abstract int read(char cbuf[], int off, int len) throws IOException;    *   说明：这个方法就指定了传入的数组可以不填满    *    * */    @Test    public void testFileReader1()&#123;        FileReader fr = null;        try &#123;            //1. File类的实例化            File file = new File(&quot;E:\\\\Java学习\\\\Java_IDEA_projects\\\\txtTest\\\\hello.txt&quot;);            //2. FileReader流的实例化            fr = new FileReader(file);            //3.读入的操作            /*使用read()重载的方法*/            //read(char[] cbuf) : 返回每次读入cbuf数组中的字符个数。如果达到文件末尾，返回            char[] cbuffer = new char[5];            int len;            while((len = fr.read(cbuffer)) != -1)&#123;                //正确的写法↓//                for(int i = 0; i &lt;len; i++)&#123;//                    System.out.print(cbuffer[i]);//                &#125;                //错误的写法↓                /*                *       一开始声明的数组的长度是5，一次最多只能读5个字符，最后一次读的时候可能不够5个，比如                *   可能是3个，然后最后两个还是上一次读出5个字符时的最后两个，这是不符合我们的期望的。                *                *                * *///                for(int i = 0; i &lt;cbuffer.length; i++)&#123;//                    System.out.print(cbuffer[i]);//                &#125;                //另一个的错误的写法↓//                String str = new String(cbuffer);//                System.out.print(str);                //正确的写法↓                String str = new String(cbuffer,0,len);                System.out.print(str);            &#125;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; finally &#123;            //4.(流)资源的关闭            try &#123;                if(fr!=null)                    fr.close();            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;    /*    *    * 从内存中写出数据到硬盘的文件里    * 说明：    *   1. 输出操作，对应的File可以不存在的    *       如果不存在，在输出的过程中，会自动创建此文件。    *       如果存在，对原有文件进行覆盖或追加    *       注：    *           FileWriter fw = new FileWriter(file, false);//这个构造器第二个参数是true：追加，默认是false    *           FileWriter fw = new FileWriter(file);//这个构造器就是覆盖写入    * */    @Test    public void testFileWriter()&#123;        FileWriter fw = null;        try &#123;            //1. 提供File类的对象，指明写出到的文件            File file = new File(&quot;E:\\\\Java学习\\\\Java_IDEA_projects\\\\txtTest\\\\Write01.txt&quot;);            //2. 提供FileWriter的对象，用于数据的写出            fw = new FileWriter(file, false);            //3. 写出的操作            fw.write(&quot;123132&quot;);            fw.write(&quot;\\nad asd &quot;);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; finally &#123;            //4. 流资源的关闭            try &#123;                fw.close();            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;    @Test    public void testFileReaderFileWriter() &#123;        FileReader fr = null;        FileWriter fw = null;        try &#123;            //1.创建File类的对象，指明读入和写出的文件            File srcFile = new File(&quot;E:\\\\Java学习\\\\Java_IDEA_projects\\\\txtTest\\\\Write01.txt&quot;);            File destFile = new File(&quot;E:\\\\Java学习\\\\Java_IDEA_projects\\\\txtTest\\\\dest01.txt&quot;);            /* 不能使用字符流来处理图片等字节数据 *///            File srcFile = new File(&quot;未标题-1.png&quot;);//            File destFile = new File(&quot;未标题-1new.png&quot;);            //2.创建输入流和输出流的对象            fr = new FileReader(srcFile);            fw = new FileWriter(destFile);            //3.数据的读入和写出操作            char[] cbuf = new char[5];            int len;//记录每次对到cbuf数组中的字符的个数            while ((len = fr.read(cbuf))!=-1)&#123;                //每次写出len个字符                fw.write(cbuf,0,len);            &#125;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; finally &#123;            //4.关闭流资源            try &#123;                fw.close();            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;            try &#123;                fr.close();            &#125; catch (IOException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;\n\n","categories":["Java Language Basics","第十三章 File和IO"],"tags":[]},{"title":"1301 File类的使用","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0/1301%20File%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/","content":"package chapter13File;import org.junit.Test;import java.io.File;import java.io.IOException;/** * * File类的使用 * * 1. File类的一个对象代表一个文件或文件目录（俗称文件夹） * 2. File类声明在java.io包下 * 3. File类中涉及到关于文件或目录的创建、删除、重命名、修改时间、文件大小等方法， * 并未涉及到写入或读取文件内容操作。如果需要读取或写入文件内容，必须使用IO流来完成。 * 4. 后续File类的对象常会作为参数传递到流的构造器中，指明读取或写入的“终点”。 * @author dopphu * @create 2021-04-18 16:44 */public class Test1301 &#123;    /*    *    * 1. 如何创建File类的实例    *       File(String filePath)    *       File(String parentPath,String childPath)    *       File(String parentFile,String childPath)    *    * 2.    *   相对路径：相较于某个了路径下，指明的路径    *   绝对路径：包含盘符在内的文件或目录    *    * 3. 路径分隔符    *   windows：\\\\    *   unix：/    *    * */    @Test    public void test1()&#123;        //构造器1        File file1 = new File(&quot;hello.txt&quot;);//相对路径是相对于module        System.out.println(file1);        //构造器2        File file3 = new File(&quot;E:\\\\Java学习\\\\Java_IDEA_projects\\\\txtTest&quot;,&quot;javaSenior&quot;);        System.out.println(file3);        //构造器3        File file4 = new File(file3,&quot;h1.txt&quot;);        System.out.println(file4);    &#125;    /*    *    * 方法：    *   public String getAbsolutePath()：获取绝对路径    *   public String getPath()：获取路径    *   public String getName()：获取名称    *   public String getParent()：获取上层文件目录路径。若无，则返回null    *   public long length()：获取文件长度（即：字节数）。不能获取目录的长度    *   public long LastModified()：最后一次的修改时间，毫秒值    *    *   //如下的两个方法适用于文件目录（目录必须存在，这样才能获取嘛，否则运行报错java.lang.NullPointerException）    *   public String[] list() : 获取指定目录下的所有文件或者文件目录的名称数组    *   public File[] listFiles() : 获取指定目录下的所有文件或文件目录的File数组    *    * */    @Test    public void test2()&#123;        File file1 = new File(&quot;hello.txt&quot;);        File file2 = new File(&quot;E:\\\\Java学习\\\\Java_IDEA_projects\\\\txtTest\\\\h1.txt&quot;);        System.out.println(file1.getAbsolutePath());        System.out.println(file1.getPath());        System.out.println(file1.getName());        System.out.println(file1.getParent());        System.out.println(file1.length());        System.out.println(file1.lastModified());        System.out.println();        System.out.println(file2.getAbsolutePath());        System.out.println(file2.getPath());        System.out.println(file2.getName());        System.out.println(file2.getParent());        System.out.println(file2.length());        System.out.println(file2.lastModified());//得到一个毫秒数：1618822284182    &#125;    @Test    public void test3()&#123;        //        File file1 = new File(&quot;E:\\\\Java学习&quot;);        String[] list = file1.list();        for(String s : list)&#123;            System.out.println(s);        &#125;        System.out.println();        File[] files = file1.listFiles();        for(File s:files)&#123;            System.out.println(s);        &#125;    &#125;    /*    * public boolean renameTo(File dest)：把文件重命名为指定的文件路径    * 比如：file1.renameTo(file2)为例：    *       要想保证返回true，需要file1在硬盘中是存在的，且file2不能再硬盘中存在（file2存在返回false，且不会发生改变）    *    *    * */    @Test    public void test4()&#123;        File file1 = new File(&quot;E:\\\\Java学习\\\\Java_IDEA_projects\\\\txtTest\\\\h1.txt&quot;);        File file2 = new File(&quot;E:\\\\Java学习\\\\Java_IDEA_projects\\\\txtTest\\\\h2.txt&quot;);        boolean renameTo = file1.renameTo(file2);        System.out.println(renameTo);    &#125;    /*    * public boolean isDirectory() : 判断是否是文件目录    * public boolean isFile() : 判断是否是文件    * public boolean exits() : 判断是否存在    * public boolean canRead() : 判断是否可读    * public boolean canWrite() : 判断是否可写    * public boolean isHidden() : 判断是都隐藏    *    * */    @Test    public void test5()&#123;        File file1 = new File(&quot;E:\\\\Java学习\\\\Java_IDEA_projects\\\\txtTest\\\\h1.txt&quot;);        System.out.println(file1.isDirectory());        System.out.println(file1.isFile());        System.out.println(file1.exists());        System.out.println(file1.canRead());        System.out.println(file1.canWrite());        System.out.println(file1.isHidden());    &#125;    /*    * File类的创建功能    * public boolean createNewFile() : 创建文件。若文件存在，则不创建，返回false    * public boolean mkdir() : 创建文件目录。如果此文件目录存在，就不创建了。如果此文件目录的上层目录不存在，也不创建    * public boolean mkdirs() : 创建文件目录。如果上层文件目录不存在，一并创建。    *    * 删除    * public boolean delete() : 删除文件或文件夹（这个文件夹要是空的才能删）    *       删除注意事项：    *           Java中的删除不走回收站    * */    @Test    public void test6() throws IOException &#123;        //文件创建        File file1 = new File(&quot;hi.txt&quot;);        if(!file1.exists())&#123;            file1.createNewFile();            System.out.println(&quot;创建成功！&quot;);        &#125;else &#123;            file1.delete();            System.out.println(&quot;删除成功！&quot;);        &#125;        //目录创建        File file2 = new File(&quot;E:\\\\Java学习\\\\Java_IDEA_projects\\\\txtTest\\\\front\\\\txt&quot;);        if(!file2.exists())&#123;            if(!file2.mkdir())&#123;                System.out.println(&quot;上层目录不存在&quot;);                file2.mkdirs();                System.out.println(&quot;上层目录一并创建！&quot;);            &#125;        &#125;    &#125;&#125;\n\n","categories":["Java Language Basics","第十三章 File和IO"],"tags":[]},{"title":"11 Employee类","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/11%E7%AB%A0%20Employee/","content":"package Chapter11exer;/** * 定义一个Employee类 *  该类包含：private成员变量name、age、birthday，其中birthday 为 MyDate 类的对象。 *  并未每一个属性定义getter和setter方法 *  并重写 toString() 方法输出 name、age、birthday * @author dopphu * @create 2021-04-16 20:11 */public class Employee &#123;    private String name;    private MyDate birthday;    private int age;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public MyDate getBirthday() &#123;        return birthday;    &#125;    public void setBirthday(MyDate birthday) &#123;        this.birthday = birthday;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;    @Override    public String toString() &#123;        return &quot;Employee&#123;&quot; +                &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +                &quot;, birthday=&quot; + birthday +                &quot;, age=&quot; + age +                &#x27;&#125;&#x27;;    &#125;&#125;\n\n","categories":["Java Language Basics","第十一章 集合"],"tags":[]},{"title":"1112 Collections：操作Collection、Map的工具类","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/1112%20Collections%EF%BC%9A%E6%93%8D%E4%BD%9CCollection%E3%80%81Map%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB/","content":"package chapter11;import org.junit.Test;import java.util.ArrayList;import java.util.Arrays;import java.util.Collections;import java.util.List;/** * * Collections：操作Collection、Map的工具类 * * 面试题：Collection 和 Collections的区别？ * Collection是一个接口，Collections是操作Collection实现类的一个工具类 * * @author dopphu * @create 2021-04-17 16:00 */public class Test1112 &#123;    /*    * reverse(List): 反转List中元素    * shuffle(List): 对List集合元素进行随机排序（随机化处理）    * sort(List): 根据元素的自然排序对指定的List集合元素按升序排序    * sort(List, Comparator): 根据指定的Comparator产生的顺序对List集合元素进行排序    * swap(List,int,int): 将指定集合中的i处元素和j处元素进行交换    *    * Object max(Collection): 根据元素的自然排序，返回给指定集合中的最大元素    * Object max(Collection, Comparator): 根据Comparator指定的顺序，返回给定集合中最大的元素    * Object min(Collection): 根据元素的自然排序，返回给指定集合中的最小元素    * Object min(Collection, Comparator): 根据Comparator指定的顺序，返回给定集合中最小的元素    * int frequency(Collection,Object): 返回指定集合中指定元素的出现次数    * void copy(List dest, List src): 将src中的内容复制到dest中    * boolean replaceAll(List list, Object oldVal, Object newVal): 使用新值替换List对    *    *    * */    @Test    public void test1()&#123;        List list = new ArrayList&lt;&gt;();        list.add(123);        list.add(43);        list.add(43);        list.add(43);//        list.add(43.3);        list.add(7564);        list.add(-12);        list.add(0);        System.out.println(list);//        Collections.reverse(list);//        Collections.shuffle(list);        Collections.sort(list);        System.out.println(list);        System.out.println(Collections.frequency(list,43));    &#125;    @Test    public void test2()&#123;        List list = new ArrayList&lt;&gt;();        list.add(123);        list.add(43);        list.add(43);        list.add(43);        list.add(43);        list.add(7564);        list.add(-12);        list.add(0);        //报异常java.lang.IndexOutOfBoundsException: Source does not fit in dest//        List dest = new ArrayList();//        Collections.copy(dest,list);        //正确的        List dest = Arrays.asList(new Object[list.size()]);        Collections.copy(dest,list);        System.out.println(dest);        /*        * Collections 类中提供了多个synchronizedXxx()方法，        * 该方法可使将指定集合包装成线程同的集合，从而可以        * 解决多线程开发并发访问集合时的线程安全问题        * */        //返回的list1即为线程安全的、        List list1 = Collections.synchronizedList(list);    &#125;&#125;\n\n","categories":["Java Language Basics","第十一章 集合"],"tags":[]},{"title":"1111 Properties的简单使用","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/1111%20Properties%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/","content":"package MapTest;import java.io.FileInputStream;import java.io.IOException;import java.util.Properties;/** * * Properties的简单使用 * * @author dopphu * @create 2021-04-17 13:24 */public class Test1111 &#123;    //Properties：常用来处理配置文件。key和value都是String类型    public static void main(String[] args)  &#123;        Properties pros = new Properties();        FileInputStream fis = null;        try &#123;            /*            *            * 目前主要过一下try中的内容即可            *            * */            fis = new FileInputStream(&quot;jdbc.properties&quot;);            pros.load(fis);            String name = pros.getProperty(&quot;name&quot;);            String password = pros.getProperty(&quot;password&quot;);            System.out.println(&quot;password = &quot;+name + &quot;,  password = &quot; + password);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; finally &#123;            if(fis!=null)&#123;                try &#123;                    fis.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;&#125;\n\n","categories":["Java Language Basics","第十一章 集合"],"tags":[]},{"title":"1110 向TreeMap中添加key-value自然排序和定制排序","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/1110%20%E5%90%91TreeMap%E4%B8%AD%E6%B7%BB%E5%8A%A0key-value%E8%87%AA%E7%84%B6%E6%8E%92%E5%BA%8F%E5%92%8C%E5%AE%9A%E5%88%B6%E6%8E%92%E5%BA%8F/","content":"package MapTest;import org.junit.Test;import java.util.*;/** * @author dopphu * @create 2021-04-17 12:28 */public class Test1110 &#123;    //向TreeMap中添加key-value，要求key必须是由同一个类创建的对象    //因为要按照key进行排序：自然排序、定制排序    //自然排序Comparable接口    public void test1()&#123;        TreeMap map = new TreeMap();        User u1 = new User(3,&quot;Tom&quot;);        User u2 = new User(23,&quot;Jack&quot;);        User u3 = new User(2,&quot;Jerry&quot;);        User u4 = new User(21,&quot;Rose&quot;);        map.put(u1,99);        map.put(u2,69);        map.put(u3,82);        map.put(u4,74);        Set entrySet = map.entrySet();        Iterator iterator1 = entrySet.iterator();        while (iterator1.hasNext())&#123;            Object obj = iterator1.next();            Map.Entry entry = (Map.Entry)obj;            System.out.println(entry.getKey()+&quot;——&gt;&quot;+entry.getValue());        &#125;    &#125;    //定制排序Comparator    @Test    public void test2()&#123;        TreeMap map = new TreeMap(new Comparator() &#123;            @Override            public int compare(Object o1, Object o2) &#123;                if(o1 instanceof User &amp;&amp; o2 instanceof User)&#123;                    User u1 = (User)o1;                    User u2 = (User)o2;                    return Integer.compare(u1.getAge(),u2.getAge());                &#125;                throw new RuntimeException(&quot;输入类型不匹配！&quot;);            &#125;        &#125;);        User u1 = new User(3,&quot;Tom&quot;);        User u2 = new User(23,&quot;Jack&quot;);        User u3 = new User(2,&quot;Jerry&quot;);        User u4 = new User(21,&quot;Rose&quot;);        map.put(u1,99);        map.put(u2,69);        map.put(u3,82);        map.put(u4,74);        Set entrySet = map.entrySet();        Iterator iterator1 = entrySet.iterator();        while (iterator1.hasNext())&#123;            Object obj = iterator1.next();            Map.Entry entry = (Map.Entry)obj;            System.out.println(entry.getKey()+&quot;——&gt;&quot;+entry.getValue());        &#125;    &#125;&#125;\n\n","categories":["Java Language Basics","第十一章 集合"],"tags":[]},{"title":"1109 Map接口的具体实现类","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/1109%20Map%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E7%B1%BB/","content":"package MapTest;import org.junit.Test;import java.util.*;/** * * |--- Map：双列数据，存储key-value对的数据    —— 类似于高中的函数：y=f(x)。me：字典 *          |--- HashMap：作为Map的主要实现类：线程不安全，效率高；存储null的key和value *              |---LinkedHashMap：保证在遍历map元素时，可以按照添加的顺序实现遍历 *                      原因：在原有的HashMap底层结构基础上，添加了一对指针，指向前一个和后一个元素 *                      对频繁的遍历操作，此类执行效率高于HashMap *          |--- TreeMap：保证按照添加的key-value对进行排序，实现排序遍历。此时考虑key的自然排序和定制排序 *                        底层使用红黑树 *          |--- Hashtable：作为古老的实现类：线程安全，效率低；不能存储null的key和value *              |---Properties： * *      HashMap的底层：数组 + 链表 （JDK 7之前） *                    数组 + 链表 + 红黑树 （jdk 8） * * 面试题： * 1. （极其常考）HashMap的底层实现 * 2.  HashMap 和 Hashtable的异同？ * 3. CurrentHashMap 和 Hashtable的异同？ （暂时不讲） * * 二、Map结构的理解： *      Map中的key：无序的、不可重复的，使用Set存储所有的key ——&gt; key所在的类要重写equals()和hashCode()（以HashMap为例） *      Map中的value：无序的、可重复的，使用Collection存储所有的value ——&gt; value所在类要重写equals() *      一个键值对：key-value构成了一个Entry对象 *      Mao中的entry：无序的、不可重复的，使用set存储所有的entry * * 三、HashMap的底层实现原理？以jdk 7为例 *      HashMap map = new HashMap(); *      在实例化以后，底层创建了长度为16的以为数组Entry[] table。 *      ...可能已经执行过多次put... *      map.put(key1,value1)： *      首先，调用key1所在类的hashCode() 计算key1哈希值，此哈希值经过某种算法以后，得到在Entry数组中的存放位置 *      如果此位置上的数据为空，此时的key1-value1添加成功 ——&gt; 情况一 *      如果此位置上的数据不安全，（意味着此位置上存在一个或多个数据（以链表形式存在））比较key1和已经存在的一个或多个数据的 *      哈希值： *              如果key1的哈希值与已经存在的哈希值都不相同，此时key1-value1添加成功。 ——&gt; 情况二 *              如果key1的哈希值和已经存在的某一个哈希值相同，继续比较：调用key1所在类的equals()方法，比较： *                  如果equals()返回false：此时key1-value1添加成功 ——&gt; 情况三 *                  如果equals()返回true：使用value1替换value2 *          补充：关于情况2和情况三：此时key1-value1和原来的数据以链表的方式存储 * *       在不断的添加过程中，会涉及到扩容问题，当超出临街值（且要存放的位置非空时），默认的扩容方式，扩容为原来的2倍，并将原有的数据复制过来 * *       jdk 8 相较于jdk 7在底层实现方面的不同: *        1. new HashMap():底层没有创建长度为16的数组 *        2. jdk 8底层的数组是：Node[]，而非Entry[] *        3. 首次调用put()方法时，底层创建长度为16的数组 *        4. jdk7底层结构只有：数组+链表；jdk8中底层结构：数组+链表+红黑树（二叉排序树） *              当数组的某一个索引位置上的元素以链表形式存在的数据个数 &gt; 8，并且，当前数组的长度 &gt; 64时， *              此时索引位置上的所有数据改为使用红黑树存储。 *      DEFAULT_INITIAL_CAPACITY : HashMap的默认容量 16 *      DEFAULT_LOAD_FACTOR : HashMap的默认加载因子 0.75 *      threshold : 扩容的临界值 = 容量*填充因子 ： 16*0.75 = 12 *      TREEIFY_THRESHOLD : Bucket中链表长度大于该默认值，转化为红黑树（JDK8中） *      MIN_TREEDIFY_CAPACITY : 桶中的Node被树化时最小的hash表容量：64 * * 四、LinkedHashMap 的底层实现原理（了解） *          源码中： *          static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123; *              Entry&lt;K,V&gt; before, after;//能够记录添加元素的先后顺序 *              Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; *                  super(hash, key, value, next); *              &#125; *          &#125; * 五、Map中定义的方法 *      添加、删除、修改： *          Object put(Object key, Object value): 将指定key-value添加到（或修改）当前当前map对象中 *          void putAll(Map m): 将m中所有key-value对存放到当前map中 *          Object remove(Object key): 移除指定key的key-value对，并返回value *          void clear(): 清空当前map中所有数据 *      元素查询的操作： *          Object get(): 获取指定key对应的value *          boolean containsKey(Object key): 是否包含指定的key *          boolean containsValue(Object value): 是否包含指定的value *          int size(): 返回map中key-value的个数 *          boolean isEmpty(): 判断当前map是否为空 *          boolean equals(Object obj): 判断当前map和参数obj是否相等 *      元始图操作的方法： *          Set keySet(): 返回所有key构成的Set集合 *          Collection values(): 返回所有value构成的Collection集合 *          Set entrySet(): 返回所有key-value对构成的Set集合 * * * 总结：常用方法 *  添加 put *  删除 remove *  修改 put *  查询 get *  长度 size *  遍历 keySet() / values() / entrySet() * * * @author dopphu * @create 2021-04-16 20:55 */public class Test1109 &#123;    @Test    public void test3()&#123;        Map map = new HashMap();        //添加        map.put(&quot;AA&quot;,123);        //key和value的参数类型为Object，所以类型混着来也可以，不过实际开发中一般key的类型时确定统一的，value的类型也是确定统一的        map.put(12,&quot;BB&quot;);        map.put(&quot;CC&quot;,123);        //修改        map.put(&quot;AA&quot;,1223);        System.out.println(map);        Map map1 = new HashMap();        map1.put(&quot;DD&quot;,45);        map1.put(&quot;AA&quot;,999);        map.putAll(map1);        System.out.println(map);        //remove(Object key)        Object value = map.remove(&quot;CCC&quot;);        System.out.println(value);        System.out.println(map);        //clear()        map.clear();//与map=null不同        System.out.println(map.size());        System.out.println(map);    &#125;    @Test    public void test4()&#123;        /*        *        * Object get(): 获取指定key对应的value        * boolean containsKey(Object key): 是否包含指定的key        * boolean containsValue(Object value): 是否包含指定的value        * int size(): 返回map中key-value的个数        * boolean isEmpty(): 判断当前map是否为空        * boolean equals(Object obj): 判断当前map和参数obj是否相等        *        *        * */        Map map = new HashMap();        map.put(&quot;AA&quot;,123);        map.put(45,123);        map.put(&quot;BB&quot;,56);        //Object get(Object key)        System.out.println(map.get(45));        //containsKey(Object key)        System.out.println(map.containsKey(&quot;BB&quot;));        //containsValue()        System.out.println(map.containsValue(123));        //size()        System.out.println(map.size());        //isEmpty()        System.out.println(map.isEmpty());    &#125;    /*    * 元始图操作的方法：     *          Set keySet(): 返回所有key构成的Set集合     *          Collection values(): 返回所有value构成的Collection集合     *          Set entrySet(): 返回所有key-value对构成的Set集合    * */    @Test    public void test5()&#123;        Map map = new HashMap();        map.put(&quot;AA&quot;,123);        map.put(45,123);        map.put(&quot;BB&quot;,56);        //遍历所有的key        Set set1 = map.keySet();        Iterator iterator1 = set1.iterator();        while (iterator1.hasNext())&#123;            System.out.println(iterator1.next());        &#125;        System.out.println(&quot;-------------------&quot;);        //遍历所有的value        Collection values = map.values();        for(Object o:values)&#123;            System.out.println(o);        &#125;        //遍历所有的key-value        //方式1        //entrySet()        Set set2 = map.entrySet();        Iterator iterator = set2.iterator();        while (iterator.hasNext())&#123;            Object obj = iterator.next();            //entrySet集合中的元素都是entry            Map.Entry entry = (Map.Entry)obj;            System.out.println(entry.getKey()+&quot;——&gt;&quot;+entry.getValue());        &#125;        System.out.println(&quot;************************&quot;);        //方式2        Set set3 = map.keySet();        Iterator iterator3 = set1.iterator();        while (iterator3.hasNext())&#123;            Object key = iterator3.next();            Object value = map.get(key);            System.out.println(key+&quot;——&gt;&quot;+value);        &#125;    &#125;    @Test    public void test1()&#123;        Map map = new HashMap();        map.put(null,123);        System.out.println(map);    &#125;    @Test    public void test2()&#123;        Map map = new HashMap();        map = new LinkedHashMap();        map.put(123,&quot;AA&quot;);        map.put(345,&quot;BB&quot;);        map.put(12,&quot;CC&quot;);        System.out.println(map);    &#125;&#125;\n\n","categories":["Java Language Basics","第十一章 集合"],"tags":[]},{"title":"1108 一个面试题，很有意思，很好的体现了hashCode()、equals()","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/1108%20%E4%B8%80%E4%B8%AA%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8C%E5%BE%88%E6%9C%89%E6%84%8F%E6%80%9D%EF%BC%8C%E5%BE%88%E5%A5%BD%E7%9A%84%E4%BD%93%E7%8E%B0%E4%BA%86hashCode()%E3%80%81equals()/","content":"package SetTest;import chapter09Test.Person;import org.junit.Test;import java.util.HashSet;/** * * 一个面试题，很有意思，很好的体现了hashCode()、equals() * 添加元素的时候，先算哈希值，相同了，再用equals()进行比较，然后以链表形式添加 *  这道题的前提是上面的hashCode()、equals()方法都被重写过了哈 *      先 hashCode() 再equals() * @author dopphu * @create 2021-04-16 20:41 */public class Test1108 &#123;    @Test    public void test3()&#123;        HashSet set = new HashSet();        Person p1 = new Person(1001,&quot;AA&quot;);        Person p2 = new Person(1002,&quot;BB&quot;);        set.add(p1);        set.add(p2);        System.out.println(set);        p1.name = &quot;CC&quot;;        set.remove(p1);//要删除就要判断有没有这个元素，既然判断有没有，那和add时判断有没有就是一个逻辑        System.out.println(set);        set.add(new Person(1001,&quot;CC&quot;));        System.out.println(set);        set.add(new Person(1001,&quot;AA&quot;));        System.out.println(set);    &#125;&#125;\n\n","categories":["Java Language Basics","第十一章 集合"],"tags":[]},{"title":"1107 TreeSet的使用","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/1107%20TreeSet%E7%9A%84%E4%BD%BF%E7%94%A8/","content":"package SetTest;import org.junit.Test;import java.util.Comparator;import java.util.Iterator;import java.util.TreeSet;/** * * TreeSet的使用 * * @author dopphu * @create 2021-04-16 19:30 */public class Test1107 &#123;    /* me:返回整数往前放，负数往后放（这个表述歧义比较大，但大概就是这个意思）    *    * 1.向TreeSet中添加数据，要求是相同类的对象    * 2.两种排序方式：自然排序（实现Comparable接口）和定制排序（Comparator）    *    * 3.自然排序中，比较两个对象是否相同的标准为：compareTo()返回0，不再是equals()    * 4.定制排序中，比较两个对象是否相同的标准为：compare()返回0，不再是equals()    * */    @Test    public void test1()&#123;        TreeSet set = new TreeSet();//失败：不能添加不同类的对象//        set.add(123);//        set.add(456);//        set.add(&quot;AA&quot;);//        set.add(new User(12,&quot;Tom&quot;));        //举例一：//        set.add(12);//        set.add(-112);//        set.add(112);//        set.add(2);        //举例二：        set.add(new User(12,&quot;Tom&quot;));        set.add(new User(2,&quot;Jerry&quot;));        set.add(new User(6,&quot;Mike&quot;));        set.add(new User(112,&quot;Jack&quot;));        //TreeSet是按照compareTo()进行是否相同的判断，如果只按姓名进行排序，“Jack”只能添加一个        set.add(new User(56,&quot;Jack&quot;));        Iterator iterator = set.iterator();        while (iterator.hasNext())&#123;            System.out.println(iterator.next());        &#125;    &#125;    @Test    public void test2()&#123;        Comparator com = new Comparator() &#123;            //按照年龄从小到大排序            @Override            public int compare(Object o1, Object o2) &#123;                if(o1 instanceof User &amp;&amp; o2 instanceof User)&#123;                    User u1 = (User)o1;                    User u2 = (User)o2;                    return Integer.compare(u1.getAge(),u2.getAge());                &#125;else&#123;                    throw new RuntimeException(&quot;输入的数据类型不匹配&quot;);                &#125;            &#125;        &#125;;        TreeSet set = new TreeSet(com);        set.add(new User(12,&quot;Tom&quot;));        set.add(new User(2,&quot;Jerry&quot;));        set.add(new User(6,&quot;Mike&quot;));        set.add(new User(112,&quot;Jack&quot;));        set.add(new User(11,&quot;Jack&quot;));        set.add(new User(11,&quot;Marry&quot;));        Iterator iterator = set.iterator();        while (iterator.hasNext())&#123;            System.out.println(iterator.next());        &#125;    &#125;&#125;\n\n","categories":["Java Language Basics","第十一章 集合"],"tags":[]},{"title":"1106 Set接口的具体实现类","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/1106%20Set%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E7%B1%BB/","content":"package SetTest;import org.junit.Test;import java.util.*;/** * * *  |--- Collection接口：单列集合，用来存储一个一个数据 *              |---Set接口：存储无序的、不可重复的数据 ——&gt;无序确定互异 *                    |--- HashSet:作为Set接口的主要实现类，线程不安全，可以存储null值 *                          |--- LinkedHashSet:作为HashSet的子类：遍历其内部数据时，可以按照添加的顺序遍历。 *                              对于频繁的遍历操作，LinkedHashSet效率高于HashSet *                    |--- TreeSet:可以按照添加元素或对象的指定属性进行排序。 * * 1. Set接口中没有额外定义新的方法，使用的都是Collection中声明过的方法。 * * 2.要求：向Set中添加的数据，其所在的类一定要重写hashCode()和equals()方法 *      要求重写的hashCode()和equals()尽可能保持一致性 *      重写两个方法的一个小技巧：对象中用作equals()方法比较Field，都应该用来计算hashCode() * * @author dopphu * @create 2021-04-15 18:07 */public class Test1106 &#123;    /*    * 一、Set：存储无序的、不可重复的数据    * 1.无序性：不等于随机性。存储的数据在底层数组中并非按照数组索引的顺序添加，而是根据数据的哈希值决定的    *   注：hashCode是Object类中的，根据需要进行重写    * 2.不可重复性：保证添加的元素按照equals()判断时，不能返回true。即：相同的元素只能添加一次    *    *    * 二、添加元素的过程，以HashSet为例：    *   我们向HashSet中添加元素a，首先调用元素a所在类的hashCode()方法，计算元素a的哈希值，    *   此哈希值接着通过某种算法计算出所在HashSet底层数组中的存放位置（即为：索引位置），判断    *   数组此位置上是否已经有过元素：    *       如果此位置上没有其他元素，则a添加成功 ——&gt; 情况1    *       如果此位置上有其它元素（或以链表形式存在的多个元素），则比较元素a和元素b的hash值：    *           如果hash值不同，则元素a添加成功 ——&gt; 情况2    *           如果hash值相同，进而需要调用元素a所在类的equals()方法：    *               equals()返回true，元素a添加失败    *               equals()返回false，元素a添加成功 ——&gt; 情况3    *    *       对于添加成功的元素的情况2和3而言，元素a与已经存在指定索引位置上数据以链表的方式存储。    *       jdk 7 ：元素a放到数组中，指向原来的元素    *       jkd 8 ：原来的元素在数组中，指向元素a    *           总结：7上8下    *   注：HashSet底层也是数组，初始容量为16。当如果使用率超过0.75，（16*0.75=12）    *       就会扩大容量为原来的2倍。（16扩容为32，依次为64.128...等）    * */    @Test    public void test1()&#123;        Set set = new HashSet();        set.add(456);        set.add(123);        set.add(123);        set.add(&quot;AA&quot;);        set.add(&quot;CC&quot;);        set.add(new User(12, &quot;Tom&quot;));        set.add(new User(12, &quot;Tom&quot;));        set.add(129);        Iterator iterator = set.iterator();        while (iterator.hasNext())&#123;            System.out.println(iterator.next());        &#125;    &#125;    /*    * LinkedHashSet的使用    *   LinkedHashSet 作为hashSet的子类，在添加数据的同时，每个数据还维护了两个引用，记录此数据前一个数据    * 和后一个数据    * 优点：对于频繁的遍历操作，LinkedHashSet效率高于HashSet    *    *    * */    @Test    public void test2()&#123;        Set set = new LinkedHashSet();        set.add(456);        set.add(123);        set.add(123);        set.add(&quot;AA&quot;);        set.add(&quot;CC&quot;);        set.add(new User(12, &quot;Tom&quot;));        set.add(new User(12, &quot;Tom&quot;));        set.add(129);        Iterator iterator = set.iterator();        while (iterator.hasNext())&#123;            System.out.println(iterator.next());        &#125;    &#125;&#125;class User implements Comparable&#123;    private int age;    private String name;    public User(int age, String name) &#123;        this.age = age;        this.name = name;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    @Override    public boolean equals(Object o) &#123;        if (this == o) return true;        if (o == null || getClass() != o.getClass()) return false;        User user = (User) o;        return age == user.age &amp;&amp;                Objects.equals(name, user.name);    &#125;    @Override    public int hashCode() &#123;        return Objects.hash(age, name);    &#125;    //按姓名从大到小排序    @Override    public int compareTo(Object o) &#123;        if(o instanceof User)&#123;            User user = (User)o;            int compare =  -this.name.compareTo(user.name);//按姓名从大到小排序            if(compare!=0)&#123;                return compare;            &#125;else&#123;                return Integer.compare(this.age,user.age);//这个方法也是从小到大            &#125;        &#125;else&#123;            throw new RuntimeException(&quot;输入的类型不匹配&quot;);        &#125;    &#125;    @Override    public String toString() &#123;        return &quot;User&#123;&quot; +                &quot;age=&quot; + age +                &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +                &#x27;&#125;&#x27;;    &#125;&#125;\n\n","categories":["Java Language Basics","第十一章 集合"],"tags":[]},{"title":"1105 List接口的具体实现类","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/1105%20List%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%E7%B1%BB/","content":"package chapter11;import org.junit.Test;import java.util.ArrayList;import java.util.Arrays;import java.util.Iterator;import java.util.List;/** *  1.接口框架 *  |--- Collection接口：单列集合，用来存储一个一个数据 *             |---List接口：存储有序的、可重复的数据。——&gt;“动态”数据 *                 |--- ArrayList：作为List接口的主要实现类。线程不安全，效率高；底层使用Object[] elementData存储 *                 |--- LinkedList：对于频繁的插入、删除操作，使用此类效率高；底层使用双向链表存储 *                 |--- Vector：作为古老实现类。线程安全，效率低；底层使用Object[] elementData存储 * * 2.ArrayList源码分析： *      2.1 jdk 7情况下 *          ArrayList arr = new ArrayLis();//调用空参构造器，底层创建了长度是10的Object[] 数组elementData *          arr.add(123);//elementData[0] = new Integer(123); *          ...//继续添加 *          arr.add(11);//如果此次添加导致底层elementData数组容量不够，则扩容 *          默认情况下，扩容为原来容量的1.5倍，同时则需要将原数组中的数据复制到新的数组中。 * * *          结论：建议开发中使用带参的构造器：ArrayList list = new ArrayList(int capacity) *          (me：在大概知道需要多长的数组的情况下，免得空参构造器容量不够，需要频繁扩容) *      2.2 jdk 8中ArrayList的变化： *          ArrayList list = new ArrayList();//底层Object[] elementData初始化为&#123;&#125;，并没有创建长度为10的数组 * *          list.add(123);//第一次调用add()时，底层才创建了长度为10的数组，并将数据123添加到elementData中 *          ... *          后续的添加和扩容操作与jdk 7 无异 *      2.3 小结：jdk7中的ArrayList的对象的创建类似于单例的饿汉式，二jdk8中的ArrayList的对象的创建 *      类似于单例的蓝=懒汉式，延迟了数组的创建，节省内存。 * * 3.LinkedList源码分析（7和8没有太大的差别，所以直接在8里边看） *      LinkedList list = new LinkedList();内部声明了Node类型的first和last属性，默认值为null *      list.add(123);//将123封装到Node中，创建了Node对象。 * *      其中，Node定义为:（双向链表） *      private static class Node&lt;E&gt; &#123; *         E item; *         Node&lt;E&gt; next; *         Node&lt;E&gt; prev; * *         Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; *             this.item = element; *             this.next = next; *             this.prev = prev; *         &#125; *     &#125; * 4. Vector的源码分析：jdk7和jdk8中通过Vector()构造器创建对象时，底层都创建了长度为10的数组， *  在扩容方面，默认扩容为原来的数组长度的2倍。 * 面试题：ArrayList、LinkedList、Vector三者的异同： * 同：三个类都是实现了List接口，存储数据的特点相同：存储有序的、可重复的数据 * 异：见上 * * @author dopphu * @create 2021-04-15 8:49 */public class Test1105 &#123;    //List的常用方法    /*    * void add(int index, Object ele):在index位置插入ele元素    * boolean addAll(int index, Collection eles):从index位置开始将eles中的所有元素逐个添加进来    * Object get(int index):获取指定index位置的元素    * int indexOf(Object obj):返回obj在当前集合中首次出现的位置;若不存在，返回-1    * int lastIndexOf(Object obj):返回obj在当前集合中末次出现的位置    * Object remove(int index):移除指定index位置的元素，并返回此元素    * Object set(int index, Object ele):设置指定index位置的元素为ele    * List subList(int fromIndex, int toIndex):返回从fromIndex到toIndex位置的子集合    *   总结：常用方法    *       增：add(Object obj)    *       删：remove(int index) / remove(Object obj) e.g. remove(2) 此时 2 是索引值，而非对象；remove(Integer(2));//删除出元素2    *       改：set(int index, Object ele)    *       查：get(int index)    *       长度：size()    *       遍历：    *           1）Iterator    *           2）增强for循环    *           3）普通的循环    *    *    * */    @Test    public void test3()&#123;        ArrayList list = new ArrayList();        list.add(123);        list.add(456);        list.add(&quot;AA&quot;);        //方式一：Iterator迭代器方式        Iterator iterator = list.iterator();        while (iterator.hasNext())&#123;            System.out.println(iterator.next());        &#125;        //方式二：foreach循环（增强for循环）        for(Object obj : list)&#123;            System.out.println(obj);        &#125;        //方式三：普通for循环        for (int i = 0; i&lt;list.size(); i++)&#123;            System.out.println(list.get(i));        &#125;    &#125;    @Test    public void test()&#123;        ArrayList list = new ArrayList();        list.add(123);        list.add(456);        list.add(&quot;AA&quot;);        list.add(new Person(&quot;Tom&quot;,12));        list.add(456);        System.out.println(list);        //add(int index, Object ele)        list.add(1,&quot;CV&quot;);        System.out.println(list);        //addAll(int index, Collection eles)        List list1 = Arrays.asList(1,2,3);        list.addAll(list1);        System.out.println(list);//        Object get(int index)        System.out.println(list.get(1));    &#125;    @Test    public void test2()&#123;        ArrayList list = new ArrayList();        list.add(123);        list.add(456);        list.add(&quot;AA&quot;);        list.add(new Person(&quot;Tom&quot;,12));        list.add(456);        //indexOf()        int index1 = list.indexOf(&quot;AA&quot;);        int index2 = list.indexOf(&quot;asdasd&quot;);//不存在返回-1        System.out.println(index1);        System.out.println(index2);        //lastIndexOf()：如果不存在，返回-1        System.out.println(list.lastIndexOf(456));        //Object remove()        Object obj1 = list.remove(1);        System.out.println(list);        System.out.println(obj1);        //Object set()        list.set(1,&quot;QAQ&quot;);        System.out.println(list);        //List subList(int fromIndex, int toIndex):左闭右开，产生新的List的对象，原对象不改变        System.out.println(list);        List subList = list.subList(2,3);        System.out.println(subList);    &#125;&#125;\n\n","categories":["Java Language Basics","第十一章 集合"],"tags":[]},{"title":"1104 jdk 5.0 新增了foreach循环，用于遍历集合、数组","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/1104%20jdk%205.0%20%E6%96%B0%E5%A2%9E%E4%BA%86foreach%E5%BE%AA%E7%8E%AF%EF%BC%8C%E7%94%A8%E4%BA%8E%E9%81%8D%E5%8E%86%E9%9B%86%E5%90%88%E3%80%81%E6%95%B0%E7%BB%84/","content":"package chapter11;import org.junit.Test;import java.util.ArrayList;import java.util.Collection;/** * * jdk 5.0 新增了foreach循环，用于遍历集合、数组 * * @author dopphu * @create 2021-04-14 22:04 */public class Test1104 &#123;    @Test    public void test1()&#123;        Collection coll = new ArrayList();        coll.add(123);        coll.add(456);        coll.add(new Person(&quot;Jerry&quot;,20));        coll.add(new String(&quot;Tom&quot;));        coll.add(false);        //for(集合元素的类型 局部变量 : 集合对象)        //内部仍然调用了迭代器。（next、hasNext）        for(Object obj : coll)&#123;            System.out.println(obj);        &#125;    &#125;    //遍历数组    @Test    public void test2()&#123;        int arr[] = new int[]&#123;5,66,123,1&#125;;        //for(数组元素的类型 局部变量 : 数组对象)        for(int i : arr)&#123;            System.out.println(i);        &#125;    &#125;    @Test    public void test3()&#123;        String arr[] = new String[]&#123;&quot;MM&quot;,&quot;MM&quot;,&quot;MM&quot;&#125;;        //方式一：普通for循环//        for (int i = 0; i &lt; arr.length; i++)&#123;//            arr[i] = &quot;GG&quot;;//        &#125;        //方式二：增强for循环（foreach）        for (String s : arr)&#123;            s = &quot;DD&quot;;//不会改变原数组        &#125;        for (int i = 0; i &lt; arr.length; i++)&#123;            System.out.println(arr[i]);        &#125;    &#125;&#125;\n\n","categories":["Java Language Basics","第十一章 集合"],"tags":[]},{"title":"1103 集合元素的遍历操作","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/1103%20%E9%9B%86%E5%90%88%E5%85%83%E7%B4%A0%E7%9A%84%E9%81%8D%E5%8E%86%E6%93%8D%E4%BD%9C/","content":"package chapter11;import org.junit.Test;import java.util.ArrayList;import java.util.Collection;import java.util.Iterator;/** * * 集合元素的遍历操作，使用迭代器Iterator接口（Map的遍历不通过这个迭代器） * 1.内部的方法：hasNext() 和 next() * 2.每当我们调用iterator()都会返回一个新的迭代器， * 默认游标都会在集合的第一个元素之前。 * * 3.内部定义了remove()，可以在遍历的时候，删除集合中的元素。此方法不同于集合直接调用remove() *      —— 就是此处调用的remove方法不是集合中的remove方法 *  注意：如果还未调用next()或在上一次调用next方法之后已经调用了remove方法， *  在调用remove都会报java.lang.IllegalStateException * * @author dopphu * @create 2021-04-14 21:28 */public class Test1103 &#123;    @Test    public void test1()&#123;        Collection coll = new ArrayList();        coll.add(123);        coll.add(456);        coll.add(new Person(&quot;Jerry&quot;,20));        coll.add(new String(&quot;Tom&quot;));        coll.add(false);        Iterator iterator = coll.iterator();        //方式一（不推荐）//        System.out.println(iterator.next());//        System.out.println(iterator.next());//        System.out.println(iterator.next());//        System.out.println(iterator.next());//        System.out.println(iterator.next());//        //报异常java.util.NoSuchElementException//        System.out.println(iterator.next());        //方式二（不推荐）//        for (int i = 0; i&lt;coll.size(); i++)&#123;//            System.out.println(iterator.next());//        &#125;        //方式三（推荐）        while (iterator.hasNext())&#123;            System.out.println(iterator.next());        &#125;    &#125;    @Test    public void test2()&#123;        Collection coll = new ArrayList();        coll.add(123);        coll.add(456);        coll.add(new Person(&quot;Jerry&quot;,20));        coll.add(new String(&quot;Tom&quot;));        coll.add(false);        Iterator iterator = coll.iterator();        //错误方式一：会跳着输出，也避免不了报错//        Iterator iterator = coll.iterator();//        while(iterator.next() != null)&#123;//            System.out.println(iterator.next());//        &#125;        //错误方式二：        /*        * 每当我们调用iterator()都会返回一个新的迭代器        * *///        while (coll.iterator().hasNext())&#123;//            System.out.println(coll.iterator().next());//        &#125;    &#125;    //测试Iterator中的remove()    @Test    public void test3()&#123;        Collection coll = new ArrayList();        coll.add(123);        coll.add(456);        coll.add(new Person(&quot;Jerry&quot;,20));        coll.add(new String(&quot;Tom&quot;));        coll.add(false);        Iterator iterator = coll.iterator();        //删除集合中的“Tom”        while(iterator.hasNext())&#123;            Object obj = iterator.next();            if(&quot;Tom&quot;.equals(obj))&#123;                iterator.remove();            &#125;        &#125;        //遍历集合        Iterator iterator1 = coll.iterator();        while (iterator1.hasNext())&#123;            System.out.println(iterator1.next());        &#125;    &#125;&#125;\n\n","categories":["Java Language Basics","第十一章 集合"],"tags":[]},{"title":"1102 Collection接口中声明的方法测试","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/1102%20Collection%E6%8E%A5%E5%8F%A3%E4%B8%AD%E5%A3%B0%E6%98%8E%E7%9A%84%E6%96%B9%E6%B3%95%E6%B5%8B%E8%AF%95/","content":"package chapter11;import org.junit.Test;import java.util.*;/** * * Collection接口中声明的方法测试 *  结论：（很重要！很重要！很重要！） *      向Collection接口的实现类的对象添加数据obj时，要求obj所在类要重写equals() ！！！ * * * @author dopphu * @create 2021-04-14 16:32 */public class Test1102 &#123;    @Test    public void test1()&#123;        Collection coll = new ArrayList();        coll.add(123);        Person p = new Person(&quot;Jerry&quot;, 12);        coll.add(456);        coll.add(new String(&quot;Tom&quot;));        coll.add(false);        coll.add(p);        //1.contains(Object obj)：判断当前集合中是否包含obj        //我们在判断时，会调用obj对象所在类的equals()方法        boolean contains = coll.contains(123);        System.out.println(contains);        System.out.println(coll.contains(new String(&quot;Tom&quot;)));        System.out.println(coll.contains(p));        System.out.println(coll.contains(new Person(&quot;Jerry&quot;,12)));        //上面的说明：这个contains方法是调用的equals方法，但是由于我们在Person类中没有重写equals方法，故        //仍然调用Object中的equals方法（即用==判断），故不重写equals方法的话结果就为false        //2.containsAll(Collection coll1)：判断形参coll1中所有元素是都都存在于当前集合中        Collection coll1 = Arrays.asList(123,456);        Collection coll2 = Arrays.asList(1203,456);        System.out.println(coll.containsAll(coll1));        System.out.println(coll.containsAll(coll2));    &#125;    @Test    public void test2()&#123;        //3.remove(Object obj)        Collection coll = new ArrayList();        coll.add(123);        Person p = new Person(&quot;Jerry&quot;, 12);        coll.add(456);        coll.add(new String(&quot;Tom&quot;));        coll.add(false);        coll.add(p);        coll.remove(1223233);        coll.remove(new Person(&quot;Jerry&quot;, 12));//也会调用equals，故也需要重写equals方法        //4.removeAll(Collection coll1)：从当前集合移除coll1中所有的元素（两个集合可以有不同的元素，移除交集部分）        Collection coll1 = Arrays.asList(123,456);        coll.removeAll(coll1);        System.out.println(coll);    &#125;    @Test    public void test3()&#123;        Collection coll = new ArrayList();        coll.add(123);        Person p = new Person(&quot;Jerry&quot;, 12);        coll.add(456);        coll.add(new String(&quot;Tom&quot;));        coll.add(false);        coll.add(p);        //5.retainAll()：获取coll和coll1交集部分（coll保留交集部分）        Collection coll1 = Arrays.asList(123,456);        coll.retainAll(coll1);        System.out.println(coll);        //6.equals() 判断当前集合和形参,要想返回true，首先对象都为集合才可//        Collection coll = new ArrayList();        coll.add(123);        coll.add(456);        coll.add(new String(&quot;Tom&quot;));        coll.add(false);        coll.add(p);        System.out.println(coll.equals(coll1));    &#125;    @Test    public void test4()&#123;        Collection coll = new ArrayList();        coll.add(123);        coll.add(456);        coll.add(new Person(&quot;Jerry&quot;,20));        coll.add(new String(&quot;Tom&quot;));        coll.add(false);        //7.hashCode()：返回当前对象的哈希值        System.out.println(coll.hashCode());//hashCode() 定义在Object中        //8.集合转换为数组 toArray()        Object[] arr = coll.toArray();        for(int i = 0; i&lt;arr.length;i++)&#123;            System.out.println(arr[i]);        &#125;        //拓展：数组——&gt;集合        List&lt;String&gt; list = Arrays.asList(new String[]&#123;&quot;AA&quot;,&quot;BB&quot;,&quot;CC&quot;&#125;);        System.out.println(list);        List arr1 = Arrays.asList(new int[]&#123;123, 456&#125;);//这样会识别为一个元素        System.out.println(arr1);//[[I@1990a65e]        System.out.println(arr1.size());//1        List arr2 = Arrays.asList(new Integer[]&#123;123,456&#125;);        System.out.println(arr2.size());//2    &#125;    @Test    public void test5()&#123;        //9.iterator()：返回Iterator接口的实例，用于遍历集合        //见文件Test1103.java    &#125;&#125;class Person&#123;    String name;    int age;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;    @Override    public String toString() &#123;        return &quot;Person&#123;&quot; +                &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +                &quot;, age=&quot; + age +                &#x27;&#125;&#x27;;    &#125;    public Person(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    @Override    public boolean equals(Object o) &#123;        System.out.println(&quot;调用Person类的equals方法&quot;);        if (this == o) return true;        if (o == null || getClass() != o.getClass()) return false;        Person person = (Person) o;        return age == person.age &amp;&amp;                Objects.equals(name, person.name);    &#125;    @Override    public int hashCode() &#123;        return Objects.hash(name, age);    &#125;&#125;\n\n","categories":["Java Language Basics","第十一章 集合"],"tags":[]},{"title":"1101 集合概述和集合知识框架","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/1101%20%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0%E5%92%8C%E9%9B%86%E5%90%88%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6/","content":"package chapter11;import org.junit.Test;import java.util.ArrayList;import java.util.Collection;import java.util.Date;/** * * 一、集合概述 * * 1.集合、数组都是对多个数据进行存储操作的结构，简称Java容器 *  说明：此时的存储，主要指的是内存层面的存储，不涉及到持久化的存储（.txt, .jpg, .avi, 数据库中） * * 2.1 数组在存储多个数据方面的特点： *      &gt; 一旦初始化以后，长度就确定了 *      &gt; 数组一旦定义好，其元素类型也就确定了。我们也就只能操作指定类型的数据了。 *              比如：String[]、int[] * 2.2 数组在存储多个数据方面的缺点： *      &gt; 一旦初始化以后，其长度就不可修改 *      &gt; 数组中提供的方法非常有限，对于添加、删除、插入数据等操作，非常不便 *      &gt; 获取数组中实际元素个数，数组没有现成的属性和方法 *      &gt; 数组存储数据的特点：有序、可重复。对于无序、不可重复等需求，数组无法满足。 * * 二、集合框架 *      |--- Collection接口：单列集合，用来存储一个一个数据 *              |---List接口：存储有序的、可重复的数据。——&gt;“动态”数据 *                  |--- ArrayList、LinkedList、Vector *              |---Set接口：存储无序的、不可重复的数据 ——&gt;无序确定互异 *                  |--- HashSet、LinkedHashSet、TreeSet *      |---Map接口：双列集合，用来存储一对（key·value）一对的数据 *              说明：一个key对应一个value（像函数一样一一对应） *              |---HashMap、LinkedHashMap、TreeMap、Hashtable、Properties * * 三、Collection接口中的方法 * @author dopphu * @create 2021-04-14 10:26 */public class Test1101 &#123;    @Test    public void test1()&#123;        Collection coll = new ArrayList();        //add(Object e)：将元素e添加到集合中        coll.add(456);//自动装箱        coll.add(&quot;CC&quot;);        coll.add(new Date());        //size()：获取数组元素个数        System.out.println(coll.size());        //addAll(Collection coll1):将Coll1集合中的元素添加到当前的集合中        Collection coll1 = new ArrayList();        coll1.add(&quot;asd&quot;);        coll1.add(111);        coll.addAll(coll1);        System.out.println(coll);        System.out.println(coll1);        //clear()：清空，不会变成空指针，就是size变成0        coll1.clear();        //isEmpty()：判断当前集合是否为空        System.out.println(coll1.isEmpty());    &#125;&#125;\n\n","categories":["Java Language Basics","第十一章 集合"],"tags":[]},{"title":"面试题（关于接口）","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%85%AD%E7%AB%A0/%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E5%85%B3%E4%BA%8E%E6%8E%A5%E5%8F%A3%EF%BC%89/","content":"/** * 面试题（关于接口） */package chapter06Test;/** * @author Dopphu * */public class Test03笔试题 &#123;\t&#125;class B&#123;\tint x = 1;&#125;interface A&#123;\tint x = 0;&#125;class C extends B implements A  &#123;\tpublic void pX() &#123;//\t\tSystem.out.println(x);//ambiguous\t\tSystem.out.println(A.x);\t\tSystem.out.println(super.x);\t&#125;\tpublic static void main(String[] args) &#123;\t\t\t&#125;&#125;\n\n","categories":["Java Language Basics","第六章 面向对象(下)"],"tags":[]},{"title":"局部内部类使用的一个注意点","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%85%AD%E7%AB%A0/%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB%E4%BD%BF%E7%94%A8%E7%9A%84%E4%B8%80%E4%B8%AA%E6%B3%A8%E6%84%8F%E7%82%B9/","content":"/** * 局部内部类使用的一个注意点 */package chapter06Test;/** * @author Dopphu * */public class Test05 &#123;\t/**\t * 在局部内部类的方法中（比如：show） 如果调用局部内部类所声明的方法（比如：method）中的局部变量（比如num）\t * 此局部变量要求声明为final\t * \t * JDK7及之前的版本要求显示声明final\t * \t * JDK8及之后，可以省略final的声明（但实际上还是final）\t */\tpublic void method() &#123;\t\tint num = 10;\t\tclass AA&#123;\t\t\tpublic void show() &#123;//\t\t\t\tnum=20;//Local variable num defined in an enclosing scope must be final or effectively final\t\t\t\tSystem.out.println(num);\t\t\t&#125;\t\t&#125;\t&#125;\t&#125;\n\n","categories":["Java Language Basics","第六章 面向对象(下)"],"tags":[]},{"title":"main()方法也可以作为我们与控制台交互的方式。（之前使用Scanner）","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%85%AD%E7%AB%A0/main()%E6%96%B9%E6%B3%95%E4%B9%9F%E5%8F%AF%E4%BB%A5%E4%BD%9C%E4%B8%BA%E6%88%91%E4%BB%AC%E4%B8%8E%E6%8E%A7%E5%88%B6%E5%8F%B0%E4%BA%A4%E4%BA%92%E7%9A%84%E6%96%B9%E5%BC%8F%E3%80%82%EF%BC%88%E4%B9%8B%E5%89%8D%E4%BD%BF%E7%94%A8Scanner%EF%BC%89/","content":"/** * main()方法也可以作为我们与控制台交互的方式。（之前使用Scanner） */package chapter06Test;/** * @author Dopphu * */public class MainDemo &#123;\tpublic static void main(String[] args) &#123;\t\tfor(int i = 0;i&lt;args.length;i++) &#123;\t\t\tSystem.out.println(&quot;*****&quot;+args[i]);\t\t\t\t\t\tint num = Integer.parseInt(args[i]);\t\t\tSystem.out.println(&quot;######&quot;+num);\t\t&#125;\t&#125;&#125;\n\n","categories":["Java Language Basics","第六章 面向对象(下)"],"tags":[]},{"title":"14 内部类","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%85%AD%E7%AB%A0/14%20%E5%86%85%E9%83%A8%E7%B1%BB/","content":"/** * 内部类 * 1.Java中允许将一个类A声明在另一个类B中，则类A就是内部类，B成为外部类 *  * 2.内部类的分类：成员内部类 VS 局部内部类（方法内、代码块内、构造器内） *  * 3.成员内部类： * \t\t一方面：作为成员内部类 * \t\t\t&gt; 调用外部类的结构：外部类名.this.方法或属性 * \t\t\t&gt; 可以被static修饰 * \t\t\t&gt; 可以被四种权限修饰符修饰 *  * \t\t另一方面：作为一个类 * \t\t\t&gt; 类可以定义属性、方法、构造器等 * \t\t\t&gt; 可以被final修饰，此类不能被继承；不使用final就可以被继承 * \t\t\t&gt; 可以被abstract修饰，表示类不能被实例化 *  * 4.关注如下的3个问题 * \t\t4.1 如何实例化成员内部类的对象 * \t\t4.2 如何在成员内部类区分调用外部类的结构 * \t\t\t\t不重名的话好说 * \t\t\t\t重名： * \t\t4.3\t开发中局部内部类的使用(见Test15) */package chapter06;/** * @author Dopphu * */public class Test14 &#123;\tpublic static void main(String[] args) &#123;\t\t\t\t//创建静态的成员内部类\t\tPersonTest14.Leg l = new PersonTest14.Leg();\t\t\t\t//创建Bird实例（非静态的成员内部类）\t\tPersonTest14 p14 = new PersonTest14();\t\tPersonTest14.Brain b = p14.new Brain();\t\tb.print(123);\t&#125;&#125;class PersonTest14&#123;\tint id=1;\t//非静态成员内部类\tclass Brain&#123;\t\tint id=2;\t\tvoid print(int id) &#123;\t\t\tSystem.out.println(id);//方法的形参\t\t\tSystem.out.println(this.id);//内部类的属性\t\t\tSystem.out.println(PersonTest14.this.id);//外部类的属性\t\t&#125;\t&#125;\t//静态成员内部类\tstatic class Leg&#123; \t\t\t&#125;\tpublic void method() &#123;\t\t//局部内部类\t\tclass AA&#123;\t\t\t\t\t&#125;\t&#125;\t&#123;\t\t//局部内部类\t\tclass BB&#123;\t\t\t\t\t&#125;\t&#125;\t/**\t * \t */\tpublic PersonTest14() &#123;\t\t//局部内部类\t\tclass CC&#123;\t\t\t\t\t&#125;\t\t// TODO Auto-generated constructor stub\t&#125;\t&#125;\n\n","categories":["Java Language Basics","第六章 面向对象(下)"],"tags":[]},{"title":"13 JDK8接口","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%85%AD%E7%AB%A0/13%20JDK8%E6%8E%A5%E5%8F%A3/","content":"/**（接口） * JDK8（以后） 除了定义全局常量和抽象方法之外，可以定义静态方法、默认方法 */package chapter06;/** * @author Dopphu * */public class Test13 &#123;\tpublic static void main(String[] args) &#123;\t\tSubClass s = new SubClass();\t\t//\t\ts.method1();//调不了\t\t//接口中定义的静态方法，只能通过接口来调用\t\tCompareA.method1();\t\t\t\t//通过实现类的对象，可以调用接口的默认方法\t\t//如果实现类重写了接口中的默认方法，则调用重写后的方法\t\ts.method2();\t\ts.method3();\t\t\t\t//知识点：类优先原则\t\t//如果子类（或实现类）继承的父类和实现的接口中声明了同名同参数的默认方法，\t\t//那么子类在没有重写此方法的情况下，默认调用的是父类中同名同参数的默认方法\t\t\t\ts.method3();\t\t//那么要是多实现呢？实现的多个接口中有同名同参数的默认方法，则会报错：接口冲突\t\t//冲突了你还想用，那就必须重写了\t\t\t&#125;&#125;interface CompareA&#123;\t//静态方法\tpublic static void method1() &#123;\t\tSystem.out.println(&quot;CompareAMethod&quot;);\t&#125;\t//默认方法\tpublic default void method2() &#123;\t\tSystem.out.println(&quot;CompareA：上海&quot;);\t&#125;\t\tdefault void method3() &#123;\t\tSystem.out.println(&quot;CompareMethod3&quot;);\t&#125;&#125;class SubClass extends SuperClass implements CompareA&#123;\tpublic void method2() &#123;\t\tSystem.out.println(&quot;method2重写&quot;);\t&#125;\t\tpublic void method3() &#123;\t\tSystem.out.println(&quot;接口实现重写的method&quot;);\t&#125;\t\tpublic void myMethod() &#123;\t\tmethod3();//重写的方法\t\tsuper.method3();//调用父类中的方法\t\t//知识点：如何实现调用接口中的默认方法\t\tCompareA.super.method3();//调用接口中的默认方法\t&#125;&#125;class SuperClass &#123;\tpublic void method3() &#123;\t\tSystem.out.println(&quot;SuperClass的method3&quot;);\t&#125;&#125;\n\n","categories":["Java Language Basics","第六章 面向对象(下)"],"tags":[]},{"title":"12 接口的应用：代理模式","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%85%AD%E7%AB%A0/12%20%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%9A%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/","content":"/** * 接口的应用：代理模式 */package chapter06;import java.lang.reflect.Proxy;/** * @author Dopphu * */public class Test12 &#123;\tpublic static void main(String[] args) &#123;\t\tServer server = new Server();\t\tProxyServer proxyServer = new ProxyServer(server);\t\t\t\tproxyServer.browse();\t&#125;&#125;interface NetWork&#123;\tpublic void browse();\t&#125;class Server implements NetWork&#123;\t@Override\tpublic void browse() &#123;\t\t// TODO Auto-generated method stub\t\tSystem.out.println(&quot;真是的服务器网络&quot;);\t&#125;\t&#125;//代理类class ProxyServer implements NetWork&#123;\t\tprivate NetWork work;\t\t\t\t/**\t * @param work\t */\tpublic ProxyServer(NetWork work) &#123;\t\tsuper();\t\tthis.work = work;\t&#125;\tpublic void check() &#123;\t\tSystem.out.println(&quot;联网前的准备工作&quot;);\t&#125;\t\t@Override\tpublic void browse() &#123;\t\t// TODO Auto-generated method stub\t\tcheck();\t\twork.browse();\t&#125;\t&#125;\n\n","categories":["Java Language Basics","第六章 面向对象(下)"],"tags":[]},{"title":"11 接口的使用","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%85%AD%E7%AB%A0/11%20%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BD%BF%E7%94%A8/","content":"/** * 接口的使用,，满足多态性 * 接口，实际上是定义了一种规范 * 在开发中体会面向接口编程 */package chapter06;/** * @author Dopphu * */public class Test11 &#123;\tpublic static void main(String[] args) &#123;\t\tComputer com = new Computer();\t\t\t\t//1.创建了接口的非匿名实现类的非匿名对象\t\tFlash flash = new Flash();\t\tcom.transferData(flash);\t\t\t\t//2.创建了接口的非匿名实现类的匿名对象\t\tcom.transferData(new Printer());\t\t\t\t//3.创建了接口的匿名实现类的非匿名对象\t\tUSB phone = new USB() &#123;\t\t\t\t\tpublic void start() &#123;\t\t\t\tSystem.out.println(&quot;手机开始工作&quot;);\t\t\t&#125;\t\t\t\t\t\tpublic void stop() &#123;\t\t\t\tSystem.out.println(&quot;手机停止工作&quot;);\t\t\t&#125;\t\t&#125;;\t\t\t\t//4.创建匿名实现类的匿名对象\t\tcom.transferData(new USB() &#123;\t\t\t@Override\t\t\tpublic void start() &#123;\t\t\t\t// TODO Auto-generated method stub\t\t\t\tSystem.out.println(&quot;mp3开始工作&quot;);\t\t\t&#125;\t\t\t@Override\t\t\tpublic void stop() &#123;\t\t\t\t// TODO Auto-generated method stub\t\t\t\tSystem.out.println(&quot;mp3停止工作&quot;);\t\t\t&#125;\t\t\t\t\t&#125;);\t\t\t\t\t&#125;&#125;class Computer&#123;\tpublic void transferData(USB usb) &#123;\t\tusb.start();\t\t\t\tSystem.out.println(&quot;具体的工作&quot;);\t\tusb.stop();\t&#125;&#125;interface USB&#123;\t\t//常量：定义了长、宽、高最大最小的传输速度\tvoid start();\tvoid stop();&#125;class Flash implements USB&#123;\tpublic void start() &#123;\t\tSystem.out.println(&quot;U盘开始工作&quot;);\t&#125;\tpublic void stop() &#123;\t\tSystem.out.println(&quot;U盘结束工作&quot;);\t&#125;&#125;class Printer implements USB&#123;\tpublic void start() &#123;\t\tSystem.out.println(&quot;打印机开始工作&quot;);\t&#125;\tpublic void stop() &#123;\t\tSystem.out.println(&quot;打印机结束工作&quot;);\t&#125;&#125;\n\n","categories":["Java Language Basics","第六章 面向对象(下)"],"tags":[]},{"title":"10 接口interface","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%85%AD%E7%AB%A0/10%20%E6%8E%A5%E5%8F%A3interface/","content":"/** * 接口interface * 1.接口的使用interface来定义 * 2.Java中，接口和类是并列的两个结构 * 3.如何定义接口：定义接口中的成员 * \t\t3.1 JDK7及以前：只能定义全局常量和抽象方法 * \t\t\t&gt; 全局常量：public static final的，但是书写时可以省略不写 * \t\t\t&gt; 抽象方法：public abstract * \t\t3.2 JDK8 除了定义全局常量和抽象方法之外，可以定义静态方法、默认方法（略） *  * 4.接口中不能定义构造器，意味着接口不可以实例化 *  * 5. Java开发中，接口通过让类去实现(implements)的方式来使用 * \t如果实现类覆盖了接口中的所有抽象方法，则此实现类就可以实例化 * \t如果实现类没有覆盖接口中所有的抽象方法，则此实现类仍为一个抽象类 *  * 6.Java类可以实现多个接口——&gt;弥补了Java单继承的局限性 * \t\t格式：class AA extends BB implements CC,DD,EE *  * 7. 接口与接口之间可以继承且可以多继承 *  * 8. 接口的具体使用，体现多态性 *  * 9.接口，实际上可以看做是一种规范 *  * 面试题：抽象类和接口有哪些异同 *  */package chapter06;/** * @author Dopphu * */public class Test10 &#123;\tpublic static void main(String[] args) &#123;\t\tPlane p = new Plane();\t\tp.stop();\t&#125;&#125;interface Flyable&#123;\t\t//全局变量\tpublic static final int MAX_SPEED = 7000;//第一宇宙速度\tint MIN_SPEED = 1;//省略了public static final\t\t//抽象的方法\tpublic abstract void fly();\t\tvoid stop();//省略了public abstract&#125;class Plane implements Flyable&#123;\t@Override\tpublic void fly() &#123;\t\t// TODO Auto-generated method stub\t\tSystem.out.println(&quot;Plane can fly&quot;);\t&#125;\t@Override\tpublic void stop() &#123;\t\t// TODO Auto-generated method stub\t\tSystem.out.println(&quot;Plane can stop&quot;);\t&#125;\t&#125;interface AA&#123;\tvoid method1();&#125;interface BB&#123;\tvoid method2();&#125;interface CC extends AA,BB&#123;\t&#125;\n\n","categories":["Java Language Basics","第六章 面向对象(下)"],"tags":[]},{"title":"09 抽象类的应用：模板方法的设计模式","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%85%AD%E7%AB%A0/09%20%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%9A%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","content":"/** * 抽象类的应用：模板方法的设计模式 */package chapter06;/** * @author Dopphu * */public class Test09 &#123;\tpublic static void main(String[] args) &#123;\t    SubTemplate sp = new SubTemplate();\t    sp.spendTime();\t&#125;&#125;abstract class Template&#123;\tpublic void spendTime() &#123;\t\t//计算代码花费的时间\t\tlong start = System.currentTimeMillis();\t\tcode();\t\tlong end = System.currentTimeMillis();\t\tSystem.out.println(end-start);\t&#125;\tpublic abstract void code();&#125;class SubTemplate extends Template&#123;\tpublic void code() &#123;\t\tfor(int i = 1;i&lt;100;i++) &#123;\t\t\tfor(int j = 0; j&lt;Math.sqrt(i);j++) &#123;\t\t\t\tSystem.out.println(i+&quot;:&quot;+j);\t\t\t&#125;\t\t&#125;\t&#125;&#125;\n\n","categories":["Java Language Basics","第六章 面向对象(下)"],"tags":[]},{"title":"08 抽象类的匿名子类","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%85%AD%E7%AB%A0/08%20%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BF%E5%90%8D%E5%AD%90%E7%B1%BB/","content":"/** * 抽象类的匿名子类 *  *  */package chapter06;/** * @author Dopphu * */public class Test08 &#123;\tpublic static void main(String[] args) &#123;\t\tmethod(new Student());//匿名对象\t\t\t\tWorker w = new Worker();\t\tmethod(w);//非匿名类的非匿名对象\t\t\t\tmethod(new Worker());//非匿名类的匿名对象\t\t\t\t\t\t//创建了一个匿名子类的对象\t\tPersonTest07 p = new PersonTest07() &#123;\t\t\t\t\t\t@Override\t\t\tvoid walk() &#123;\t\t\t\t// TODO Auto-generated method stub\t\t\t\tSystem.out.println(&quot;匿名子类&quot;);\t\t\t&#125;\t\t&#125;;\t\t\t\tp.walk();\t\t\t\t//创建匿名子类的匿名对象\t\tmethod(new PersonTest07() &#123;\t\t\t@Override\t\t\tvoid walk() &#123;\t\t\t\t// TODO Auto-generated method stub\t\t\t\tSystem.out.println(&quot;匿名子类的匿名方法&quot;);\t\t\t&#125;\t\t\t\t\t&#125; );\t&#125;\t\tpublic static void method(Object obj) &#123;\t\t\t&#125;&#125;class Worker&#123;\t&#125;\n\n","categories":["Java Language Basics","第六章 面向对象(下)"],"tags":[]},{"title":"07 抽象类与抽象方法","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%85%AD%E7%AB%A0/07%20%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95/","content":"/** * 随着继承层次中一个个新子类的定义，类变得越来越具体，而父类更一般更通用。 * 类的设计应该保证父类和子类能够共享特征。有时候将一个父类设计得非常抽象，以至于他没有 * 具体的实例，这样的类叫做抽象类 *  * 抽象类与抽象方法 *  * abstract关键字的使用 *  * abstract可以用来修饰的结构：类、方法 * \t\t修饰类 * \t\t\t&gt; 此类不能实例化 * \t\t\t&gt; 抽象类中一定有构造器，便于子类实例化时调用（涉及子类对象实例化的全过程） * \t\t\t&gt; 开发中，会提供抽象类的子类，让子类对象实例化，完成相关操作 * \t\t修饰方法 * \t\t\t&gt;　抽象方法只有声明，没有方法体 * \t\t\t&gt; 包含抽象方法的类，一定是一个抽象类；反之不成立 * \t\t\t&gt; 若子类重写了父类中的所有抽象方法后，此类方可实例化 * \t\t\t  若没有重写所有父类所有的抽象方法，则此类要为抽象类（需要用abstract修饰），方可实例化 * \t\t\t\t（父类的抽象方法也包括间接父类的抽象方法） *  * abstract使用的注意点： * \t\t1. abstract不能用来修饰属性构造器等结构。 * \t\t2. abstract不能用来修饰私有方法、静态方法、final的方法、final的类。 *       */package chapter06;/** * @author Dopphu * */public class Test07 &#123;\tpublic static void main(String[] args) &#123;//\t\tPersonTest07 p1 = new PersonTest07();//\t\tp1.eat();\t&#125;&#125;abstract class PersonTest07&#123;\tString name;\tint age;\t\t\t\t/**\t * \t */\tpublic PersonTest07() &#123;\t\tsuper();\t&#125;\t/**\t * @param name\t * @param age\t */\tpublic PersonTest07(String name, int age) &#123;\t\tsuper();\t\tthis.name = name;\t\tthis.age = age;\t&#125;\tabstract void walk();\tvoid eat() &#123;\t\tSystem.out.println(&quot;人吃饭&quot;);\t&#125;&#125;class Student extends PersonTest07&#123;\t@Override\tvoid walk() &#123;\t\t// TODO Auto-generated method stub\t\t\t&#125;\t&#125;\n\n","categories":["Java Language Basics","第六章 面向对象(下)"],"tags":[]},{"title":"06 final关键字","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%85%AD%E7%AB%A0/06%20final%E5%85%B3%E9%94%AE%E5%AD%97/","content":"/** * final：最终的 *  * 1.final可以用来修饰的结构：类、方法、变量 *  * 2.final用来修饰一个类：表明此类不能被继承 * \t\t\t比如：String类、System类、StringBuffer类 * 3.final用来修饰方法：表明此方法不可以被重写 * \t\t\t比如：Object中的getClass() * 4.final用来修饰变量：此时变量不可被修改（只能被赋值一次） * \t\t4.1 final修饰属性：可以考虑赋值的位置有：显示初始化、代码块中赋值、构造器中初始化 * \t\t4.2 final修饰局部变量 * \t\t\t\t尤其是使用final修饰形参时，表名形参是一个常量。当我们调用此方法时，给常量形参赋一个实参。一旦赋值以后， * \t\t\t就只能在方法体重使用此形参，但不能进行重新赋值 * static final 用来修饰：属性、方法 * \t\t&gt; 修饰属性：全局常量 * \t\t&gt; 方法：（final）不能被重写，（static）随着类加载 */package chapter06;/** * @author Dopphu * */public class Test06final &#123;\tfinal int num;//此时是一个常量\tpublic void show(final int num)&#123;\t\t\t&#125;\t\t\t&#123;num=1;&#125;\tpublic static void main(String[] args) &#123;\t\tfinal int num;\t\tnum = 10;\t\tSystem.out.println(num);\t&#125;\t&#125;//final class A&#123;//\t//&#125;////class B extends String&#123;//\t//&#125;//class AA&#123;//\tfinal void demo() &#123;//\t\t//\t&#125;//&#125;//class BB extends AA&#123;//\tvoid demo() &#123;//\t\t//\t&#125;//&#125;\n\n","categories":["Java Language Basics","第六章 面向对象(下)"],"tags":[]},{"title":"05 类的成员之：代码块","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%85%AD%E7%AB%A0/05%20%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E4%B9%8B%EF%BC%9A%E4%BB%A3%E7%A0%81%E5%9D%97/","content":"/** * 类的成员之：代码块 *  * 1.代码块的作用：初始化类、对象 * 2.代码块如果有修饰的话，只能用static声明 * 3.分类：静态代码块VS非静态代码块 *  * 静态代码块： * \t\t&gt; 内部可以有输出语句 * \t\t&gt; 随着类的加载而执行(只执行一次) * \t\t&gt; 作用：初始化类的静态属性 * \t\t&gt;只能调用静态结构 * 非静态代码块： * \t\t&gt; 内部可以有输出语句 * \t\t&gt; 随着对象的创建而执行 * \t\t&gt; 每造一个对象就会执行一次\t  * \t\t&gt; 作用：可以在创建对象时，对对象的属性进行赋值 * \t\t&gt;可以调用非静态结构和静态结构 * 静态代码块的执行先于非静态代码块，如果一个类中定义了多个静态代码块（一般不写多个），则按声明的先后顺序执行，非静态也是如此 *  * 对属性可以进行赋值的位置： * 1）默认初始化 * 2）显示初始化 * 3）构造器中初始化 * 4）有了对象以后，使用“对象.属性”或“对象.方法”的方式来进行赋值 * 5）代码块中赋值 *  * \t代码块的执行先于构造器 * 执行先后顺序：1 - 2/5（2和5谁先写谁先执行） - 3 - 4 *  */package chapter06;/** * @author Dopphu * */public class Test05 &#123;\tpublic static void main(String[] args) &#123;\t\tString desc = Person.desc;\t\tSystem.out.println(&quot;*********分割*********&quot;);\t\tPerson p1 = new Person();\t\tPerson p2 = new Person();\t\tSystem.out.println(p1.age);\t\tSystem.out.println(Person.desc);\t&#125;&#125;class Person&#123;\tString name;\tint age;\tstatic String desc = &quot;我是一个人&quot;;\t\tpublic Person() &#123;\t\t\t&#125;\t\tpublic Person(String name, int age) &#123;\t\tthis.name = name;\t\tthis.age = age;\t&#125;\t\tpublic void eat() &#123;\t\tSystem.out.println(&quot;吃饭&quot;);\t&#125;\t@Override\tpublic String toString() &#123;\t\treturn &quot;Person [name=&quot; + name + &quot;, age=&quot; + age + &quot;, desc=&quot; + desc + &quot;]&quot;;\t&#125;\t\t//非静态代码块\t&#123;\t\tSystem.out.println(&quot;你好我是代码块儿&quot;);\t\tage = 1;\t&#125;\t\t//静态代码块\tstatic &#123;\t\tdesc = &quot;我是静态在静态&quot;;\t\tSystem.out.println(&quot;我是静态代码块儿010&quot;);\t&#125;\tstatic &#123;\t\tdesc = &quot;我是静态在静态&quot;;\t\tSystem.out.println(&quot;我是静态代码块儿02&quot;);\t&#125;&#125;\n\n","categories":["Java Language Basics","第六章 面向对象(下)"],"tags":[]},{"title":"04 main()方法的使用说明","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%85%AD%E7%AB%A0/04%20main()%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/","content":"/** * main()方法的使用说明 * 1.main()方法作为程序的入口 * 2.main()方法也是一个普通的静态方法 * 3.main()方法也可以作为我们与控制台交互的方式。（之前使用Scanner） */package chapter06;/** * @author Dopphu * */public class Test04mainInfo &#123;\tpublic static void main(String[] args) &#123;//\t\tSystem.out.println(&quot;public类的main方法&quot;);\t\tMain.main(new String[100]);\t&#125;&#125;class Main&#123;\t\tpublic static void main(String[] args) &#123;\t\tSystem.out.println(&quot;Main 的main方法&quot;);\t&#125;&#125;\n\n","categories":["Java Language Basics","第六章 面向对象(下)"],"tags":[]},{"title":"03 单例设计模式","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%85%AD%E7%AB%A0/03%20%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","content":"/** * 单例设计模式： * \t\t1.所谓单例设计模式，就是采用一定的方法保证在整个软件体系中，对某个类只能存在一个对象实例 *  * \t\t2.如何实现 * \t\t\t懒汉式 VS　饿汉式 * \t\t3.区分懒汉式和饿汉式 * \t\t\t饿汉式： * \t\t\t\t缺点：对象加载时间过长 * \t\t\t\t优点：懒汉式是线程安全的 * \t\t\t懒汉式： * \t\t\t\t优点：延迟对象的创建（不用的时候不占内存） * \t\t\t\t目前的写法缺点：线程不安全——&gt;到线程内容时，再修改让它变成安全的 */package chapter06;/** * @author Dopphu * */public class Test03 &#123;\tpublic static void main(String[] args) &#123;\t\t\t\tOrder o1 = Order.getInstance();\t\tOrder o2 = Order.getInstance();\t\tSystem.out.println(o1==o2);\t\t\t\tBank b1 = Bank.getInstance();\t\tBank b2 = Bank.getInstance();\t\tSystem.out.println(b1==b2);\t&#125;&#125;//饿汉式class Bank&#123;\t\t//1.私有化类的构造器\tprivate Bank() &#123;\t\t\t&#125;\t//2.内部创建类的对象\t//4.要求此对象也必须声明为静态的\tprivate static Bank instance = new Bank();\t\t//3.提供公共的方法，返回类的对象\tpublic static Bank getInstance() &#123;\t\treturn instance;\t&#125;&#125;//懒汉式（巧记：比较懒，用的时候再造）class Order&#123;//\t1.私有化类的构造器\tprivate Order() &#123;\t\t\t&#125;\t\t//2.声明当前类对象，没有初始化\tprivate static Order instance = null;\t\t//3.声明public、static的返回当前类对象的方法\tpublic static Order getInstance() &#123;\t\tif(instance==null) &#123;\t\t\tinstance = new Order();\t\t\t&#125;\t\treturn instance;\t\t\t\t\t&#125;&#125;\n\n","categories":["Java Language Basics","第六章 面向对象(下)"],"tags":[]},{"title":"02 static关键字的使用","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%85%AD%E7%AB%A0/02%20static%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%BF%E7%94%A8/","content":"/** * static关键字的使用 */package chapter06;/** * @author Dopphu * */public class Test02 &#123;\tpublic static void main(String[] args) &#123;\t\tCircle c1 = new Circle();\t\tCircle c2 = new Circle();\t\t\t\tSystem.out.println(&quot;c1的id：&quot;+c1.getId());\t\tSystem.out.println(&quot;c2的id：&quot;+c2.getId());\t\t\t\tSystem.out.println(&quot;创建的圆的个数：&quot;+Circle.getTotal());\t\t\t\t\t\t\t&#125;&#125;class Circle&#123;\tprivate double radius;\tprivate int id;//自动赋值\t/**\t * @param radius\t */\tpublic Circle(double radius) &#123;\t\tthis();\t\tthis.radius = radius;\t&#125;\t/**\t * @return the total\t */\tpublic static int getTotal() &#123;\t\treturn total;\t&#125;\t\t\tpublic Circle() &#123;\t\tid = init++;\t\ttotal++;\t&#125;\tprivate static int total;//记录创建圆的个数\tprivate static int init = 1001;\t\tpublic double findArea() &#123;\t\treturn Math.PI * radius * radius;\t&#125;\t/**\t * @return the radius\t */\tpublic double getRadius() &#123;\t\treturn radius;\t&#125;\t/**\t * @param radius the radius to set\t */\tpublic void setRadius(double radius) &#123;\t\tthis.radius = radius;\t&#125;\t/**\t * @return the id\t */\tpublic int getId() &#123;\t\treturn id;\t&#125;\t/**\t * @param id the id to set\t */\tpublic void setId(int id) &#123;\t\tthis.id = id;\t&#125;\t&#125;\n\n","categories":["Java Language Basics","第六章 面向对象(下)"],"tags":[]},{"title":"01 static关键字的使用","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%85%AD%E7%AB%A0/01%20static%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%BF%E7%94%A8/","content":"/** * static关键字的使用 *  * 1.static：静态的 * 2.static可以用来修饰：属性、方法、代码块、内部类 *  * 3.使用static修饰属性:静态变量（或类变量） * \t\t3.1属性按是否用static修饰分为：非静态变量和静态变量（实例变量） * \t\t实例变量：我们创建了类的多个变量，每个对象都独立的拥有一套类中的非静态属性，当修改其中一个对象的 * \t\t\t非静态属性时，不会导致其他对象中同样的属性值的修改 * \t\t3.2静态变量：所有类的对象共享同一个静态变量。当通过某一个对象来修改其值时， * \t\t\t其他对象调用该静态变量的时候，是修改过的 * \t\t3.3 static修饰属性的其他说明： * \t\t\t1）静态变量随着类的加载而加载 * \t\t\t * \t\t\t2）静态变量的加载要早于对象的创建 *  * \t\t\t3）由于类只会加载一次，则静态变量在内存中也只会存在一份，存在方法区的静态域中 *  * \t\t\t4）\t\t类变量\t\t实例变量 * \t\t\t类\t\tyes\t\t\tno * \t\t\t对象\t\tyes\t\t\tyes *  * 4.使用static修饰方法：静态方法 * \t\t\tme：主要原因是生命周期不同 * \t\t\t1）随着类的加载而加载，可以通过“类.静态方法”的方式进行调用 * \t\t\t2）\t\t\t静态方法\t\t非静态方法 * \t\t\t\t类\t\tyes\t\t\tno * \t\t\t\t对象\t\tyes\t\t\tyes * \t\t\t3）静态方法中只能调用静态方法或属性 * \t\t\t4）非静态方法中，既可以调用非静态方法或属性，也可以调用静态的方法或属性 * 5.static注意点 * \t\t在静态的方法内，不能用this、super（me：静态属性或方法前省略的不是this，而是类） * \t\t要从生命周期的角度进行理解\t\t * 6.如何确定一个属性是否要声明为static的？ * \t\t&gt; 属性是可以被多个对象共享的，不会随着对象的不同而不同\\ * \t\t&gt; final修饰的变量就不再是变量了，而是常量了，常量习惯上也常常声明为static * \t\t * \t 如何确定一个方法是否要声明为static的？ * \t\t&gt; 操作静态属性的方法通常就设置为静态的 * \t\t&gt; 工具类中的方法，习惯上声明为static的。比如：Math、Arrays、Collection * \t\t */\t\tpackage chapter06;/** * @author Dopphu * */public class Test01 &#123;\tpublic static void main(String[] args) &#123;\t\t\t\tChinese.nation = &quot;中国&quot;;\t\t\tSystem.out.println(Chinese.nation);\t\t\t\tChinese c1 = new Chinese();\t\tc1.nation = &quot;CHN&quot;;\t\tChinese c2 = new Chinese();\t\t\t\tSystem.out.println(c2.nation);\t\t\t&#125;&#125;//中国人class Chinese&#123;\tString name;\tstatic String nation;&#125;\n\n","categories":["Java Language Basics","第六章 面向对象(下)"],"tags":[]},{"title":"0815 创建线程的方式四：使用线程池","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%85%AB%E7%AB%A0/0815%20%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F%E5%9B%9B%EF%BC%9A%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0/","content":"package chapter08;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.ThreadPoolExecutor;/** * * 创建线程的方式四：使用线程池 * * 好处： * 1.提高响应速度（减少了创建线程的时间） * 2.降低资源消耗（重复使用线程池中的线程，不需要每次都创建） * 3.便于线程管理 *          corePoolSize：核心线程池大小 *          maximumPoolSize：最大线程数 *          keepAliveTime：线程没有任务时最多保持多长时间后会终止 * * 面试题 * 创建线程的方式有几种?四种 * * @author dopphu * @create 2021-04-10 0:00 */public class Test0815 &#123;    public static void main(String[] args) &#123;        //1.提供指定线程数量的线程池        ExecutorService service = Executors.newFixedThreadPool(10);        //EecutorService是一个接口,它没有那么多属性，所以要找它的实现类        ThreadPoolExecutor  service1 = (ThreadPoolExecutor)service;        //设置线程的属性//        service1.setCorePoolSize(15);//        service1.setKeepAliveTime();//        System.out.println(service.getClass());        //2.执行指定的线程的操作，需要提供实现Runnable接口或Callable接口实现类的对象        service.execute(new NumberThread());//适合使用于Runnable//        service.submit();//适合使用于Callable        service.execute(new NumberThread1());        //关闭连接池        service.shutdown();    &#125;&#125;class NumberThread implements Runnable&#123;    @Override    public void run() &#123;        for(int i = 0;i&lt;100;i++)&#123;            if(i%2==0)&#123;                System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i);            &#125;        &#125;    &#125;&#125;class NumberThread1 implements Runnable&#123;    @Override    public void run() &#123;        for(int i = 0;i&lt;100;i++)&#123;            if(i%2!=0)&#123;                System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i);            &#125;        &#125;    &#125;&#125;\n\n","categories":["Java Language Basics","第八章 多线程"],"tags":[]},{"title":"0814 创建线程的方式三：实现Callable接口————JDK5.0新增","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%85%AB%E7%AB%A0/0814%20%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F%E4%B8%89%EF%BC%9A%E5%AE%9E%E7%8E%B0Callable%E6%8E%A5%E5%8F%A3%E2%80%94%E2%80%94%E2%80%94%E2%80%94JDK5.0%E6%96%B0%E5%A2%9E/","content":"package chapter08;import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;import java.util.concurrent.FutureTask;/** * * 创建线程的方式三：实现Callable接口————JDK5.0新增 * * 如何理解实现Callable接口的方式创建多线程比实现Runnable接口创建多线程方式强大？ * 1.call()可以有返回值的 * 2.call()可以抛出异常，被外面的操作捕获，获取异常的信息 * 3.Callable是支持泛型的 * * @author dopphu * @create 2021-04-09 23:22 */public class Test0814 &#123;    public static void main(String[] args) &#123;        //3.创建Callable接口实现类的对象        NumThread n = new NumThread();        //4.将此Callable接口实现类的对象作为参数传递到FuturaTask构造器中，创建FutureTask的对象        FutureTask futureTask = new FutureTask(n);        //5.将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()        new Thread(futureTask).start();        try &#123;            //6.（需要的话）获取Callable中call方法的返回值            //get()返回值即为FutureTask构造器参数Callable实现类的重写的call()的返回值            System.out.println(&quot;总和为：&quot;+futureTask.get());        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125; catch (ExecutionException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;//1.创建一个实现Callable的实现类class NumThread implements Callable&#123;    //2.实现 call方法，将此线程需要执行的操作声明在call中   @Override    public Object call() throws Exception &#123;        int sum = 0;        for (int i = 1; i&lt;=100; i++)&#123;            if(i%2==0)&#123;                System.out.println(i);                sum+=i;            &#125;        &#125;        return sum;    &#125;&#125;\n\n","categories":["Java Language Basics","第八章 多线程"],"tags":[]},{"title":"0813 线程通信的应用——生产者消费者问题","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%85%AB%E7%AB%A0/0813%20%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E7%9A%84%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98/","content":"package chapter08;/** * 线程通信的应用 * 生产者消费者问题： * * 生产者（Productor）将产品交给店员（Clerk），而消费者（Customer）从店员处取走 * 产品，店员一次只能持有固定数量的产品（比如：20个），如果生产者试图生产更多的产品， * 店员就会叫生产者停一下，如果店中有空位放产品了再通知生产者继续生产；如果店中没有产 * 品了，店员会告诉消费者等一下，如果店中有产品了再通知消费者来取走产品 * * * 这里可能出现两个问题： * &gt; 生产者比消费者快时，消费者会漏掉一些数据没有取到 * &gt; 消费者比生产者快时，消费者会取到相同的数据 * * 分析： * 1.是否是多线程问题？是，生产者线程，消费者线程 * 2.是否有共享数据？是，店员（或产品） * 3.如何解决线程的安全问题？同步机制，有三种方法 * 4.是否涉及到线程的通信？是 * * @author dopphu * @create 2021-04-09 22:41 */public class Test0813 &#123;    public static void main(String[] args) &#123;        Clerk clerk = new Clerk();        Producer p1 = new Producer(clerk);        p1.setName(&quot;生产者1&quot;);        Consumer c1 = new Consumer(clerk);        c1.setName(&quot;消费者1&quot;);        Consumer c2 = new Consumer(clerk);        c2.setName(&quot;消费者2&quot;);        p1.start();        c1.start();        c2.start();    &#125;&#125;class Clerk&#123;    private int productCount = 0;    //生产产品    public synchronized void produceProduct() &#123;        if(productCount &lt; 20)&#123;            productCount++;            System.out.println(Thread.currentThread().getName()+&quot;:开始生产第&quot;+productCount+&quot;个产品&quot;);            //只要生产者生产产品就可唤醒消费者            notify();        &#125;else&#123;            try &#123;                wait();            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;    //消费产品    public synchronized void consumeProduct() &#123;        if(productCount &gt; 0)&#123;            System.out.println(Thread.currentThread().getName()+&quot;:开始消费第&quot;+productCount+&quot;个产品&quot;);            productCount--;            //只要消费者消费产品就可以唤醒生产者            notify();        &#125;else&#123;        //等待            try &#123;                wait();            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;class Producer extends Thread&#123;    private Clerk clerk;    public Producer(Clerk clerk) &#123;        this.clerk = clerk;    &#125;    @Override    public void run() &#123;        System.out.println(getName()+&quot;:开始生产产品&quot;);        while (true)&#123;            try &#123;                sleep(10);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            clerk.produceProduct();        &#125;    &#125;&#125;class Consumer extends Thread&#123;//消费者    private Clerk clerk;    public Consumer(Clerk clerk) &#123;        this.clerk = clerk;    &#125;    @Override    public void run() &#123;        System.out.println(getName()+&quot;:开始消费产品&quot;);        while (true)&#123;            try &#123;                sleep(20);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            clerk.consumeProduct();        &#125;    &#125;&#125;\n\n","categories":["Java Language Basics","第八章 多线程"],"tags":[]},{"title":"0812 线程通信的例子：使用两个线程打印1-100.线程1、线程2交替打印","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%85%AB%E7%AB%A0/0812%20%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E7%9A%84%E4%BE%8B%E5%AD%90%EF%BC%9A%E4%BD%BF%E7%94%A8%E4%B8%A4%E4%B8%AA%E7%BA%BF%E7%A8%8B%E6%89%93%E5%8D%B01-100.%E7%BA%BF%E7%A8%8B1%E3%80%81%E7%BA%BF%E7%A8%8B2%E4%BA%A4%E6%9B%BF%E6%89%93%E5%8D%B0/","content":"package chapter08;/** * * 线程通信的例子：使用两个线程打印1-100.线程1、线程2交替打印 * * *  （线程通信）涉及到的三个方法： *  wait()：一旦执行此方法，当前线程就进入阻塞状态，并释放同步监视器。 *  notify()：一旦执行此方法，就会唤醒被wait()的一个线程，如果有多个线程被wait，就唤醒优先级高的 *  notifyAll()：一旦执行此方法，就会唤醒所有被wait()的线程 * *  说明： *  1.wait()，notify()，notifyAll()三个方法都必须使用在同步代码块或同步方法中 *  2.wait()，notify()，notifyAll()三个方法的调用者都必须是同步代码块或同步方法中的同步监视器， *  否则会出现异常java.lang.IllegalMonitorStateException *  3.wait()，notify()，notifyAll()三个方法都定义在java.lang.Object中（me：因为每个对象都可以当多同步监视器） * * 面试题：sleep() 和 wait()的异同？ * 1.相同点：一旦执行方法，都可以使得当前的线程进入阻塞状态。 * 2.不同点：1）两个方法的声明位置不同：Thread类中声明静态的sleep()，Object类中声明wait() *          2）调用要求的不同：sleep()可以在任何需要的场景下使用；wait()必须使用在同步代码块或同步方法中 *          3）关于是否释放同步监视器：如果两个方法都使用在同步代码或同步方法中，sleep()不释放，wait()释放 * * * @author dopphu * @create 2021-04-09 22:13 */public class Test0812 &#123;    public static void main(String[] args) &#123;        Number number = new Number();        Thread t1 = new Thread(number);        Thread t2 = new Thread(number);        t1.setName(&quot;线程1&quot;);        t2.setName(&quot;线程2&quot;);        t1.start();        t2.start();    &#125;&#125;class Number implements Runnable&#123;    private int number = 1;    private Object obj = new Object();    @Override    public void run() &#123;        while (true)&#123;            synchronized (this) &#123;                notify();                if(number&lt;=100)&#123;                    try &#123;                        Thread.sleep(100);                    &#125; catch (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                    System.out.println(Thread.currentThread().getName()+&quot;:&quot;+number);                    number++;                    try &#123;                        //使得调用如下wait()方法的线程进入阻塞状态                        wait();//注意！阻塞后释放锁                    &#125; catch (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                &#125;else&#123;                    break;                &#125;            &#125;        &#125;    &#125;&#125;\n\n","categories":["Java Language Basics","第八章 多线程"],"tags":[]},{"title":"0811 解决线程安全问题的方式三：Lock锁——JDK5.0新增","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%85%AB%E7%AB%A0/0811%20%E8%A7%A3%E5%86%B3%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E7%9A%84%E6%96%B9%E5%BC%8F%E4%B8%89%EF%BC%9ALock%E9%94%81%E2%80%94%E2%80%94JDK5.0%E6%96%B0%E5%A2%9E/","content":"package chapter08;import java.util.concurrent.locks.ReentrantLock;/** * * 解决线程安全问题的方式三：Lock锁——JDK5.0新增 * * 1.面试题：synchronize 与 lock的异同？ *  相同：二者都可以解决线程安全问题 *  不同：synchronize机制在执行完相应的同步代码以后，自动的释放同步监视器 *          Lock需要手动的启动同步（Lock()），同时结束同步也需要手动的实现（unlock()） * * 2.优先使用顺序： * Lock——&gt;同步代码块（已经进入了方法体，分配了相应资源）——&gt;同步方法（在方法体之外） * * 面试题：如何解决线程安全问题？有几种方式 * @author dopphu * @create 2021-04-09 20:22 */public class Test0811 &#123;    public static void main(String[] args) &#123;        Window5 w = new Window5();        Thread t1 = new Thread(w);        Thread t2 = new Thread(w);        Thread t3 = new Thread(w);        t1.start();        t2.start();        t3.start();    &#125;&#125;class Window5 implements Runnable&#123;    private int ticket = 100;    //1.实例化ReentrantLock    private ReentrantLock lock = new ReentrantLock(true);//公平意味着先进先出    @Override    public void run() &#123;        while (true)&#123;            try &#123;                //2.调用锁定方法lock()                lock.lock();                if(ticket&gt;0)&#123;//                try &#123;//                    Thread.sleep(1000);//                &#125; catch (InterruptedException e) &#123;//                    e.printStackTrace();//                &#125;                    System.out.println(Thread.currentThread().getName() + &quot;卖票了，票号为:&quot;+ticket);                    ticket--;                &#125;else&#123;                    break;                &#125;            &#125;finally &#123;                //3.调用解锁的方法：unlock()                lock.unlock();            &#125;        &#125;    &#125;&#125;\n\n","categories":["Java Language Basics","第八章 多线程"],"tags":[]},{"title":"0810 演示线程死锁","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%85%AB%E7%AB%A0/0810%20%E6%BC%94%E7%A4%BA%E7%BA%BF%E7%A8%8B%E6%AD%BB%E9%94%81/","content":"package chapter08;/** * * 演示线程死锁 * * 1.死锁的理解：不同的线程分别占用对方需要的同步资源不放， * 都在等待对方放弃自己需要的同步资源，就形成了线程的死锁 * * 2.说明： * 1）出现死锁后，不会出现异常，只是所有的线程处于阻塞状态，无法继续 * 2）我们使用同步时，要避免出现死锁。 * * 程序正常执行不意味着没死锁，可能还是有死锁的概率，只是这次执行没有发生死锁而已 * @author dopphu * @create 2021-04-09 16:24 */public class Test0810 &#123;    public static void main(String[] args) &#123;        StringBuffer s1 = new StringBuffer();        StringBuffer s2 = new StringBuffer();        new Thread()&#123;            @Override            public void run() &#123;                synchronized(s1)&#123;                    try &#123;                        Thread.sleep(1000);                    &#125; catch (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                    s1.append(&quot;a&quot;);                    s2.append(&quot;1&quot;);                    synchronized(s2)&#123;                        s1.append(&quot;B&quot;);                        s2.append(&quot;2&quot;);                        System.out.println(s1);                        System.out.println(s2);                    &#125;                &#125;            &#125;        &#125;.start();        new Thread(new Runnable() &#123;//提供实现Runnable接口的类的对象            @Override            public void run() &#123;                synchronized(s2)&#123;                    s1.append(&quot;c&quot;);                    s2.append(&quot;3&quot;);                    synchronized(s1)&#123;                        s1.append(&quot;d&quot;);                        s2.append(&quot;4&quot;);                        System.out.println(s1);                        System.out.println(s2);                    &#125;                &#125;            &#125;        &#125;).start();    &#125;&#125;\n\n","categories":["Java Language Basics","第八章 多线程"],"tags":[]},{"title":"0809 使用同步机制将当前单例模式中的懒汉式改写为线程安全的","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%85%AB%E7%AB%A0/0809%20%E4%BD%BF%E7%94%A8%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E5%B0%86%E5%BD%93%E5%89%8D%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E6%87%92%E6%B1%89%E5%BC%8F%E6%94%B9%E5%86%99%E4%B8%BA%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84/","content":"package chapter08;/** * * 使用同步机制将当前单例模式中的懒汉式改写为线程安全的 * * @author dopphu * @create 2021-04-09 16:03 */public class Test0809 &#123;    public static void main(String[] args) &#123;    &#125;&#125;class Bank&#123;    private Bank()&#123;&#125;    private static Bank instance = null;    public static Bank getInstance()&#123;//还可以使用同步方法的方式        //方式一：效率稍差。当已经创建过对象以后，线程还是可能卡在if语句那儿//        synchronized (Bank.class) &#123;//            if(instance==null)&#123;//                instance = new Bank();//            &#125;//            return instance;//        &#125;        //方式二：效率更高        if(instance==null)&#123;            synchronized (Bank.class) &#123;                if (instance == null) &#123;                    instance = new Bank();                &#125;            &#125;        &#125;        return instance;    &#125;&#125;\n\n","categories":["Java Language Basics","第八章 多线程"],"tags":[]},{"title":"0808 使用同步方法处理继承Thread类的方式中的线程安全问题","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%85%AB%E7%AB%A0/0808%20%E4%BD%BF%E7%94%A8%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%E5%A4%84%E7%90%86%E7%BB%A7%E6%89%BFThread%E7%B1%BB%E7%9A%84%E6%96%B9%E5%BC%8F%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/","content":"package chapter08;/** * * 使用同步方法处理继承Thread类的方式中的线程安全问题 * * 关于同步方法的总结： * 1.同步方法仍然涉及同步监视器，只是不需要我们显式的声明 * 2.非静态的同步方法，同步监视器——this *   静态的同步方法，同步监视器——当前类本身（类名.class） * * @author dopphu * @create 2021-04-08 23:12 */public class Test0808 &#123;    public static void main(String[] args) &#123;        Window4 w1 = new Window4();        Window4 w2 = new Window4();        Window4 w3 = new Window4();        w1.setName(&quot;窗口一&quot;);        w2.setName(&quot;窗口二&quot;);        w3.setName(&quot;窗口三&quot;);        w1.start();        w2.start();        w3.start();    &#125;&#125;class Window4 extends Thread&#123;    private static int ticket = 100;    @Override    public void run() &#123;        while (true)&#123;            show();            if(ticket&lt;=0)&#123;                break;            &#125;        &#125;    &#125;    private static synchronized void show()&#123;//同步监视器：Window4.class        //private synchronized void show() 同步监视器：(仍然是this)w1、w2、w3，监视器不唯一， 是错误的        if(ticket&gt;0)&#123;            System.out.println(Thread.currentThread().getName()+&quot;卖票了，票号为：&quot;+ticket);            ticket--;        &#125;    &#125;&#125;\n\n","categories":["Java Language Basics","第八章 多线程"],"tags":[]},{"title":"0807 使用同步方法解决实现Runnable接口的线程安全问题","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%85%AB%E7%AB%A0/0807%20%E4%BD%BF%E7%94%A8%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%E8%A7%A3%E5%86%B3%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/","content":"package chapter08;/** * * 使用同步方法解决实现Runnable接口的线程安全问题 * * * @author dopphu * @create 2021-04-08 22:58 */public class Test0807 &#123;    public static void main(String[] args) &#123;        Window3 w3 = new Window3();        Thread t1 = new Thread(w3);        Thread t2 = new Thread(w3);        Thread t3 = new Thread(w3);        t1.setName(&quot;窗口1&quot;);        t2.setName(&quot;窗口2&quot;);        t3.setName(&quot;窗口3&quot;);        t1.start();        t2.start();        t3.start();    &#125;&#125;class Window3 implements Runnable&#123;    private int ticket = 100;    @Override    public void run() &#123;        while(true)&#123;            show();            if(ticket&lt;=0)&#123;                break;            &#125;        &#125;    &#125;    private synchronized void show()&#123;//同步监视器是：this        if(ticket&gt;0)&#123;            System.out.println(Thread.currentThread().getName()+&quot;卖票了,票号为：&quot;+ticket);            ticket--;        &#125;    &#125;&#125;\n\n","categories":["Java Language Basics","第八章 多线程"],"tags":[]},{"title":"0806 解决三窗口卖票线程安全问题(继承Thread类的方式)","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%85%AB%E7%AB%A0/0806%20%E8%A7%A3%E5%86%B3%E4%B8%89%E7%AA%97%E5%8F%A3%E5%8D%96%E7%A5%A8%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98(%E7%BB%A7%E6%89%BFThread%E7%B1%BB%E7%9A%84%E6%96%B9%E5%BC%8F)/","content":"package chapter08;/** * * 例子：创建三个窗口卖票，总票数为100张，使用继承Thread类的方式 * * 使用同步代码块来解决继承Thread类的方式的线程安全问题 * * 说明：在继承Thread类创建多线程的方式中，慎用this充当同步监视器， * 考虑使用当前类充当同步监视器，如：本例子中的Window2.class * @author dopphu * @create 2021-04-07 23:08 */public class Test0806 &#123;    public static void main(String[] args) &#123;        Window2 w1 = new Window2();        Window2 w2 = new Window2();        Window2 w3 = new Window2();        w1.setName(&quot;窗口1&quot;);        w2.setName(&quot;窗口2&quot;);        w3.setName(&quot;窗口3&quot;);        w1.start();        w2.start();        w3.start();    &#125;&#125;class Window2 extends Thread&#123;    private static int ticket = 100;    private static Object obj = new Object();//声明一个静态变量来当监视器    @Override    public void run() &#123;        while(true)&#123;//            synchronized(obj)&#123;            synchronized(Window2.class)&#123;                if(ticket&gt;0)&#123;                    try &#123;                        Thread.sleep(100);                    &#125; catch (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                    System.out.println(getName()+&quot;:卖票，票号为：&quot;+ticket);                    ticket--;                &#125;else&#123;                    break;                &#125;            &#125;        &#125;    &#125;&#125;\n\n","categories":["Java Language Basics","第八章 多线程"],"tags":[]},{"title":"0805 解决三窗口卖票线程安全问题(实现Runnable接口的方式)","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%85%AB%E7%AB%A0/0805%20%E8%A7%A3%E5%86%B3%E4%B8%89%E7%AA%97%E5%8F%A3%E5%8D%96%E7%A5%A8%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/","content":"package chapter08;/** * * 例子：创建三个窗口卖票，总票数为100张，使用实现Runnable接口的方式 * *  存在线程安全问题，待解决 * *  1.问题：卖票过程中，出现了重票、错票——&gt;出现了线程的安全问题 *  2.问题出现的原因：当某个线程操作车票的过程中，尚未操作完成时，其它线程参与进来，也操作车票。 *  3.如何解决：当一个线程a在操作ticket的时候，其它线程不能参与进来，直到线程a操作完成ticket时，其它线程才可以 *  开始操作ticket。这种情况即使线程a出现了阻塞，也不能改变。 * *  4.在java中，我们通过同步机制，来解决线程安全问题 * *      方式一：同步代码块 *          synchronize(同步监视器)&#123; *              //需要被同步的代码 *          &#125; *          说明：1.操作共享数据的代码，即为需要被同步的代码——&gt;不能包多了，也不能包少了 *               2.共享数据：多个线程共同操作的变量，如：本问题的ticket *               3.同步监视器，俗称：锁。任何一个对象都能充当锁 *                     要求：多个线程必须要共用同一把锁 * *      补充：在实现Runnable接口创建多线程的方式中，我们可以考虑使用this充当同步监视器。 * *      方式二：同步方法 *  5.同步的方式，解决了线程的安全问题。——好处 *    操作同步代码时，只能有一个线程参与，其它线程等待。相当于是一个单线程的过程，效率低。 * * @author dopphu * @create 2021-04-07 23:39 */public class Test0805 &#123;    public static void main(String[] args) &#123;        Window1 w1 = new Window1();        Thread t1 = new Thread(w1);        Thread t2 = new Thread(w1);        Thread t3 = new Thread(w1);        t1.setName(&quot;窗口1&quot;);        t2.setName(&quot;窗口2&quot;);        t3.setName(&quot;窗口3&quot;);        t1.start();        t2.start();        t3.start();    &#125;&#125;class Window1 implements Runnable&#123;    private int ticket = 100;//    Object obj = new Object();    private Dog d = new Dog();    @Override    public void run() &#123;        while (true)&#123;            synchronized (this)&#123;//这this是唯一的，在本例子中指w1  //synchronized (d) &#123;                if (ticket &gt; 0) &#123;//                    try &#123;//                        Thread.sleep(100);//sleep会抛异常，所以要用try-catch包一下//                    &#125; catch (InterruptedException e) &#123;//                        e.printStackTrace();//                    &#125;                    System.out.println(Thread.currentThread().getName()+&quot;卖票了，票号为：&quot; + ticket);                    ticket--;                &#125; else &#123;                    break;                &#125;            &#125;        &#125;    &#125;&#125;class Dog&#123;&#125;\n\n","categories":["Java Language Basics","第八章 多线程"],"tags":[]},{"title":"0804 创建多线程的方式二：实现Runnable接口","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%85%AB%E7%AB%A0/0804%20%E5%88%9B%E5%BB%BA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9A%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3/","content":"package chapter08;/** * 创建多线程的方式二：实现Runnable接口 * 1.创建一个实现了Runnable接口的类 * 2.实现类去实现Runnable中的抽象方法：run() * 3.创建实现类的对象 * 4.将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象 * 5.通过Thread类的对象调用start() * * 比较创建线程的两种方式：继承Thread有局限性（比如Window已经继承了一个类，就没法继承Thread） * 实现Runnable的方式体现了数据共享 * * 开发中，优先选择实现Runnable接口的方式 * 原因： *      1）实现的方式没有类的单继承性的局限性 *      2）实现的方式更适合来处理多个线程共享数据的情况 * * 联系：Thread类本身也实现了Runnable接口 * 相同点：两种方式都需要重写run(),将线程要执行的逻辑声明在run()中 * * * @author dopphu * @create 2021-04-07 23:18 */public class Test0804 &#123;    public static void main(String[] args) &#123;        //3.创建实现类的对象        MThread mThread = new MThread();        //4.将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象        Thread t1 = new Thread(mThread);        //5.通过Thread类的对象调用start()：①启动线程；②调用当前线程的run()——&gt;调用了Runnable类型的target的run()        t1.setName(&quot;第一个线程&quot;);//起名要在start()前        t1.start();        //再启动一个线程，遍历100以内的偶数        Thread t2 = new Thread(mThread);        t2.start();    &#125;&#125;//1.创建一个实现了Runnable结口的类class MThread implements Runnable&#123;    //2.实现类去实现Runnable中的抽象方法：：run()    @Override    public void run() &#123;        for(int i = 0; i&lt;100; i++)&#123;            if(i%2==0)&#123;                System.out.println(Thread.currentThread().getName()+&quot;:&quot;+i);            &#125;        &#125;    &#125;&#125;\n\n","categories":["Java Language Basics","第八章 多线程"],"tags":[]},{"title":"0803 例子：创建三个窗口卖票(存在线程安全问题，待解决)","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%85%AB%E7%AB%A0/0803%20%E4%BE%8B%E5%AD%90%EF%BC%9A%E5%88%9B%E5%BB%BA%E4%B8%89%E4%B8%AA%E7%AA%97%E5%8F%A3%E5%8D%96%E7%A5%A8(%E5%AD%98%E5%9C%A8%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%EF%BC%8C%E5%BE%85%E8%A7%A3%E5%86%B3)/","content":"package chapter08;/** * * 例子：创建三个窗口卖票，总票数为100张，使用继承Thread类的方式 * * 存在线程安全问题，待解决。 * @author dopphu * @create 2021-04-07 23:08 */public class Test0803 &#123;    public static void main(String[] args) &#123;        Window w1 = new Window();        Window w2 = new Window();        Window w3 = new Window();        w1.setName(&quot;窗口1&quot;);        w2.setName(&quot;窗口2&quot;);        w3.setName(&quot;窗口3&quot;);        w1.start();        w2.start();        w3.start();    &#125;&#125;class Window extends Thread&#123;    private static int ticket = 100;    @Override    public void run() &#123;        while(true)&#123;            if(ticket&gt;0)&#123;                System.out.println(getName()+&quot;:卖票，票号为：&quot;+ticket);                ticket--;            &#125;else&#123;                break;            &#125;        &#125;    &#125;&#125;\n\n","categories":["Java Language Basics","第八章 多线程"],"tags":[]},{"title":"0802 Thread类中的常用方法和线程的优先级","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%85%AB%E7%AB%A0/0802%20Thread%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7/","content":"package chapter08;/** * * 测试Thread类中的常用方法： * 1.start():启动当前线程；调用当前线程的run() * 2.run():通常需要重写Thread类中的此方法，将创建的线程要执行的操作声明在此方法中 * 3.currentThread():静态方法，返回执行当前代码的线程 * 4.getName():获取当前线程的名字 * 5.setName():设置当前线程的名字 * 6.yield():释放当前CPU的执行权，但是也有可能下一时刻又被分配到执行权 * 7.join():在线程A中调用线程B的join()，此时线程A就进入阻塞状态，知道线程B完全执行以后，线程A才 * 结束阻塞状态 * 8.stop()——已经过时，官方不建议使用：当执行此方法时，前置结束当前线程 * 9.sleep(long millitime);//静态方法，可以用类名调：让当前线程“睡眠”执行的millitime毫秒，在指定的millitime毫秒时间内， * 当前线程是阻塞状态 * 10.isAlive()：判断当前线程是否存活 * * 线程的优先级： * 1. * MAX_PRIORITY: 10 * MIN_PRIORITY: 1 * NORM_PRIORITY: 5 ——&gt;默认优先级 * 2.如何获取和设置当前线程的优先级 *  getPriority():获取 *  setPriority():设置 * 说明：高优先级的线程要抢占低优先级线程cpu的执行权。但是只是从概率上讲，高优先级的线程高概率地被执行， * 并不意味着只有当高优先级线程执行完以后，低优先级的线程才执行。 * * 线程通信：wait()/notify()/notifyAll() : 此三个方法定义在Object类中 * * * @author dopphu * @create 2021-04-07 17:11 * * */class MyThread02 extends Thread&#123;    @Override    public void run() &#123;        for(int i = 0;i&lt;100;i++)&#123;            if(i%2==0)&#123;//                try &#123;//                    sleep(10);//                &#125; catch (InterruptedException e) &#123;//                    e.printStackTrace();//                &#125;                System.out.println(Thread.currentThread().getName()+ &quot;:&quot;+ Thread.currentThread().getPriority()+&quot;:&quot;+i);            &#125;//            if(i%20==0)&#123;//                yield();//释放执行权//            &#125;        &#125;    &#125;    public MyThread02(String name)&#123;        super(name);    &#125;&#125;public class Test0802 &#123;    public static void main(String[] args) &#123;        MyThread02 m1 = new MyThread02(&quot;Thread_1&quot;);//        m1.setName(&quot;线程一&quot;);        //设置分线程的优先级        m1.setPriority(Thread.MAX_PRIORITY);        m1.start();        //给主线程命名        Thread.currentThread().setName(&quot;主线程&quot;);        for(int i = 0;i&lt;100;i++)&#123;            if(i%2==0)                System.out.println(Thread.currentThread().getName()+&quot;:&quot;+Thread.currentThread().getPriority()+&quot;:&quot;+i);            if(i==20)&#123;                try &#123;                    m1.join();//在m1执行完后才能继续执行主线程                &#125; catch (InterruptedException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;        System.out.println(m1.isAlive());//false:m1线程已经结束    &#125;&#125;\n\n","categories":["Java Language Basics","第八章 多线程"],"tags":[]},{"title":"0801 多线程的创建方式一：继承于Thread类","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E5%85%AB%E7%AB%A0/0801%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9A%E7%BB%A7%E6%89%BF%E4%BA%8EThread%E7%B1%BB/","content":"package chapter08;/** * 多线程的创建，方式一：继承于Thread类 * 1.创建一个继承于thread类的子类 * 2.重写Thread类的run()方法——&gt;将此线程执行的操作声明在run()中 * 3.创建Thread类的子类的对象 * 4.通过此对象调用start() * * 例子：遍历100以内的所有偶数 * * @author dopphu * @create 2021-04-07 10:10 */public class Test0801 &#123;    public static void main(String[] args) &#123;        //3.创建Thread类的子类的对象//        MyThread myThread = new MyThread();//        //4.通过此对象调用start():①启动当前线程 ②调用当前线程的run()//        myThread.start();        //问题一：我们不能通过直接调用run()的方式启动线程//        myThread.run();        //问题二：再启动一个线程，遍历100以内的偶数，不可以让已经start()的线程去执行，会报java.lang.IllegalThreadStateException//        myThread.start();//java.lang.IllegalThreadStateException//        MyThread t2 = new MyThread();//        t2.start();        MyThread m1 = new MyThread();        MyThread2 m2 = new MyThread2();        m1.start();        m2.start();        //如下的操作仍然是在main线程中执行//        for(int i = 0; i&lt;100;i++)&#123;//            if(i%2==0)&#123;//                System.out.println(i+&quot;********&quot;);//            &#125;//        &#125;        //创建Thread类的匿名子类的方式        new Thread()&#123;            @Override            public void run() &#123;                for(int i = 0; i&lt;=100;i++)&#123;                    if(i%2==0)&#123;                        System.out.println(Thread.currentThread().getName() + &quot;:&quot; + i);                    &#125;                &#125;            &#125;        &#125;.start();    &#125;&#125;//1.创建一个继承于Thread类的子类class MyThread extends Thread&#123;    //2.重写Thread类的run()    @Override    public void run() &#123;        for(int i = 0; i&lt;=100;i++)&#123;            if(i%2==0)&#123;                System.out.println(Thread.currentThread().getName() + &quot;:&quot; + i);            &#125;        &#125;    &#125;&#125;class MyThread2 extends Thread&#123;    //2.重写Thread类的run()    @Override    public void run() &#123;        for(int i = 0; i&lt;=100;i++)&#123;            if(i%2!=0)&#123;                System.out.println(Thread.currentThread().getName() + &quot;:&quot; + i);            &#125;        &#125;    &#125;&#125;\n\n","categories":["Java Language Basics","第八章 多线程"],"tags":[]},{"title":"面试题：== 和 equals() 的区别","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E4%BA%94%E7%AB%A0/%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A==%20%E5%92%8C%20equals()%20%E7%9A%84%E5%8C%BA%E5%88%AB/","content":"/** * 面试题：== 和 equals() 的区别 *  * 一、回顾 == 的使用 *  * ==：运算符 *  * 1.可以使用在基本数据类型变量和引用数据变量 * 2.如果比较的是基本数据类型变量，比较的是两个变量保存的数据是否相等（类型可以不同） * \t 如果比较的是引用数据类型变量，比较两个对象的地址值是否相同，即两个引用是否指向同一个 * 对象实体 * 补充：== 使用时，变量类型要能统一在一起，否则编译都不通过 *  * 二、equals()方法的使用 * 这是一个方法，基本数据类型没法调用，所有就只考虑引用数据类型 * 1.Object类中equals()方法的定义 *\t public boolean equals(Object obj) &#123;        return (this == obj);     &#125; * 2.像String、Date、File，包装类等类都重写了Object类中的equals()方法。重写以后。 * 比较的不是两个引用的地址是否相同，而是比较两个对象的“实体内容”是否相同 * 3.通常情况下，我们自定义类如果使用equals()的话，也通常是比较两个对象的“实体内容”是否相同， * 那么，我们就需要对Object类中的equals()方法进行重写 */package chapter05;import java.util.Date;/** * @author Dopphu * */public class TestEquals &#123;\tpublic static void main(String[] args) &#123;\t\tSystem.out.println(1==1.);//true\t\tSystem.out.println(97==&#x27;a&#x27;);//true//\t\tSystem.out.println(1==true);//编译报错\t\t\t\tObj a = new Obj();\t\tObj b = new Obj();\t\t\t\tString s1 = new String(&quot;asd&quot;);\t\tString s2 = new String(&quot;asd&quot;);\t\t\t\tSystem.out.println(a==b);//false\t\tSystem.out.println(s1==s2);//false\t\t\t\tSystem.out.println(s1.equals(s2));//true\t\tSystem.out.println(a.equals(b));//false(未重写时)\t\t\t\tDate date1 = new Date(315464646L);\t\tDate date2 = new Date(315464646L);\t\t\t\tSystem.out.println(date1.equals(date2));//true\t\t\t\tSystem.out.println(&quot;*****************************&quot;);\t\t\t\tString s3 = &quot;asd&quot;;\t\tString s4 = &quot;asd&quot;;\t\tSystem.out.println(s3==s4);//true\t&#125;&#125;class Obj&#123;\tint age;\tString name;\t\t/**\t * \t */\tpublic Obj() &#123;\t\tsuper();\t&#125;\t/**\t * @param age\t * @param name\t */\tpublic Obj(int age, String name) &#123;\t\tsuper();\t\tthis.age = age;\t\tthis.name = name;\t&#125;\t//自动生成的equals()方法（开发基本上都是自动生成）\t@Override\tpublic boolean equals(Object obj) &#123;\t\tif (this == obj)\t\t\treturn true;\t\tif (obj == null)\t\t\treturn false;\t\tif (getClass() != obj.getClass())\t\t\treturn false;\t\tObj other = (Obj) obj;\t\tif (age != other.age)\t\t\treturn false;\t\tif (name == null) &#123;\t\t\tif (other.name != null)\t\t\t\treturn false;\t\t&#125; else if (!name.equals(other.name))\t\t\treturn false;\t\treturn true;\t&#125;\t//\t//重写的原则：比较两个对象的实体内容是否相等//\t@Override\t//自己重写的方法//\tpublic boolean equals(Object obj) &#123;//\t\tif(this == obj) &#123;//\t\t\treturn true;//\t\t&#125;//\t\t//\t\tif(obj instanceof Obj) &#123;//\t\t\tObj objTemp = (Obj)obj;//\t\t\t//比较两个对象的每个属性是否相同//\t\t\treturn this.age==objTemp.age &amp;&amp; this.name==objTemp.name;//\t\t&#125;//\t\t//\t\treturn false;//\t&#125;&#125;\n\n","categories":["Java Language Basics","第五章 面向对象(中)"],"tags":[]},{"title":"包装类练习","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E4%BA%94%E7%AB%A0/%E5%8C%85%E8%A3%85%E7%B1%BB%E7%BB%83%E4%B9%A0/","content":"/** * 包装类练习 */package chapter05Test;/** * @author Dopphu *\t */public class Test01 &#123;\tpublic static void main(String[] args) &#123;\t\tObject o1 = true ? new Integer(1) : new Double(2.0);\t\t//三元运算符的两个表达式类型要进行统一，所以本来是1，统一成后边的Double类型1.0\t\tSystem.out.println(o1);//1.0\t\t\t\tInteger i = new Integer(1);\t\tInteger j = new Integer(1);\t\tSystem.out.println(i==j);//false\t\t\t\tInteger m = 1;\t\tInteger n = 1;\t\tSystem.out.println(m == n);//true\t\t\t\tInteger x = 128;\t\tInteger y = 128;\t\t//语法细节https://www.bilibili.com/video/BV1Kb411W75N?p=309&amp;spm_id_from=pageDriver\t\t//Integer类中的机制可以理解为一个缓存，已经有了一个数组，里面存了-128 到 127 的int数，当给一个128时，超出了\t\t//这个数组的范围，所以就会new一个，因此地址不同，然后就false\t\t\t\t//视频解释：\t\t/*\t\t * Integer内部定义了IntegerCache结构，IntegerCache中定义了Integer[]\t\t * 保存了-128~127范围的整数，如果我们使用自动装箱的方式，给Integer赋值的范围在\t\t * -128~127范围内时，可以直接使用数组中标中的元素，不用再去new。目的，提高效率\t\t * */\t\t\t\tSystem.out.println(x == y);//false\t\t\t\t\t\t\t&#125;&#125;\n\n","categories":["Java Language Basics","第五章 面向对象(中)"],"tags":[]},{"title":"体会四种权限修饰符","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E4%BA%94%E7%AB%A0/%E4%BD%93%E4%BC%9A%E5%9B%9B%E7%A7%8D%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6/","content":"/** * 体会4种不同的权限修饰符  *  */package chapter05;/** * @author Dopphu * */public class Test04 &#123;\tint orderDefault;\tprivate int orderPrivate;\tprotected int orderProtected;\tpublic int orderPublic;\tprivate void methodPrivate() &#123;\t\tSystem.out.println(&quot;private&quot;);\t&#125;\tvoid methodDefault() &#123;\t\tSystem.out.println(&quot;Default&quot;);\t&#125;\tpublic void methodPublic() &#123;\t\tSystem.out.println(&quot;Public&quot;);\t&#125;\tprotected void methodProtected() &#123;\t\tSystem.out.println(&quot;Protected&quot;);\t&#125;//\tpublic static void main(String[] args) &#123;//\t\tTestDesc demo = new TestDesc();//\t\tdemo.methodDefault();//\t&#125;&#125;////class TestDesc&#123;//\t//&#125;\n\n","categories":["Java Language Basics","第五章 面向对象(中)"],"tags":[]},{"title":"Java中的JUnit单元测试","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E4%BA%94%E7%AB%A0/Java%E4%B8%AD%E7%9A%84JUnit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/","content":"/** * Java中的JUnit单元测试 *  * 步骤： * 1.选中当前工程，右键选择build path——&gt;add libraries - JUnit 4 - 下一步 * 2.创建Java类，进行单元测试。 * \t\t此时的Java类要求：①此类是public的 ②此类提供公共的无参的构造器 * 3.此类中声明单元测试的方法 * \t\t此时的单元测试的方法：方法的权限是public，没有返回值，没有形参 *  * 4.此单元测试方法上需要声明注解：@Test，并在单元测试类中导入：import org.junit.Test *  * 5.声明好单元测试方法以后，就可以在方法体内测试相关的代码 *  * 6.写完代码以后，左键双击单元测试方法名，右键：run as - JUnit *  * 说明：正常——绿条 * \t   异常——红条 */package chapter05;import org.junit.Test;/** * @author Dopphu * */public class Test11 &#123;\t\t@Test\tpublic void testEquals() &#123;\t\tString s1 = &quot;MM&quot;;\t\tString s2 = &quot;MM&quot;;\t\t\t\tSystem.out.println(s1.equals(s2));\t&#125;&#125;\n\n","categories":["Java Language Basics","第五章 面向对象(中)"],"tags":[]},{"title":"10 包装类的使用","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E4%BA%94%E7%AB%A0/10%20%E5%8C%85%E8%A3%85%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/","content":"/** * 包装类的使用：(因为JUnit（单元测试不会整）出问题解决不了，所以还是用main进行测试) * 1.java提供了8种基本数据类型，使得基本数据类型的变量具有类的特征 *  * 2.掌握的：基本数据类型、包装类、String三者之间的转换 */package chapter05;import org.junit.Test;/** * @author Dopphu * */public class Test12 &#123;\t\t@Test\tpublic void test1() &#123;\t\t\t&#125;\tpublic static void main(String[] args) &#123;\t\tint num1 = 10;//\t\tSystem.out.println(num1.toString());//编译报错\t\tInteger in1 = new Integer(num1);\t\tSystem.out.println(in1.toString());\t\t\t\tInteger in2 = new Integer(&quot;123&quot;);\t\tSystem.out.println(in2.toString());\t\t\t\t//报异常//\t\tInteger in3 = new Integer(&quot;123asd&quot;);//\t\tSystem.out.println(in3.toString());\t\t\t\tFloat f1 = new Float(12.3f);\t\tFloat f2 = new Float(&quot;12.3&quot;);\t\tSystem.out.println(f1);\t\tSystem.out.println(f2);\t\t\t\tBoolean b1 = new Boolean(true);\t\tBoolean b2 = new Boolean(&quot;true&quot;);\t\t\t\tBoolean b3 = new Boolean(&quot;trueasd1523&quot;);\t\tSystem.out.println(b3);//false\t\t\t\tOrderTest order = new OrderTest();\t\tSystem.out.println(order.isMale);//false\t\tSystem.out.println(order.isFemale);//null\t\t\t\t//包装类转基本数据类型\t\t//方法：调用某包装类Xxx的xxxvalue()\t\tFloat f3 = new Float(12.3);\t\tfloat f4 = f1.floatValue();\t\tSystem.out.println(f2+1);\t\t\t\tSystem.out.println(&quot;******************************&quot;);\t\t\t\t//JDK 5.0新特性：自动装箱与自动拆箱\t\tint num2 = 10;\t\t//基本数据类型——&gt;包装类的对象\t\tmethod(num2);\t\t\t\t//自动装箱\t\tint num3 = 10;\t\tInteger in3 = num3;//自动装箱\t\tSystem.out.println(in3);\t\tboolean b5 = true;\t\tBoolean b4 = b5;//自动装箱\t\t\t\t//自动拆箱：包装类——&gt;基本数据类型\t\tSystem.out.println(in1.toString());\t\t\t\tint num4 = in1;//自动拆箱\t\tSystem.out.println(&quot;**********************&quot;);\t\t//基本数据类型——&gt;String类型，调用String重载的valueOf(Xxx xxx)//\t\tint num1 = 10;\t\t//方式一：连接运算\t\tString str1 = num1 + &quot;&quot;;\t\t//方式二：调用String的valueOf(Xxx xxx)\t\t//基本数据类型和包装类都可以这么做\t\tfloat f5 = 12.3f;\t\tString str2 = String.valueOf(f5);\t\tSystem.out.println(str2);//&quot;12.3&quot;\t\t\t\tDouble d1 = new Double(124.4);\t\tString str3 = String.valueOf(d1);\t\tSystem.out.println(str3);\t\t\t\t\t\t\t\tSystem.out.println(&quot;-------------------------&quot;);\t\t\t\t//String类型——&gt;基本数据类型、包装类：调用包装类的parseXxx(String s)\t\t//不同类的强制类型装换必须有子父类的关系，基本数据类型不能强转为引用数据类型（否则都会编译报错）\t\tString str4 = &quot;123&quot;;\t\t//错误的情况//\t\tint num5 = (int)str1;//编译报错//\t\tInteger in4 = (Integer)str1;\t\t//可能会报NumberFormatException（字符串不是规矩的数字就会报这个错）\t\tint num6 = Integer.parseInt(str1);\t\tSystem.out.println(num4);\t\t\t\tString str5 = &quot;true&quot;;//不是true的都是false\t\tboolean b6 = Boolean.parseBoolean(str5);\t\tSystem.out.println(b6);\t\t\t&#125;\tpublic static void method(Object obj) &#123;\t\tSystem.out.println(obj);\t&#125;&#125;class OrderTest&#123;\tboolean isMale;\tBoolean isFemale;&#125;\n\n","categories":["Java Language Basics","第五章 面向对象(中)"],"tags":[]},{"title":"09 Object类中toString()的使用","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E4%BA%94%E7%AB%A0/09%20Object%E7%B1%BB%E4%B8%ADtoString()%E7%9A%84%E4%BD%BF%E7%94%A8/","content":"/** * Object类中toString()的使用 *  * 1.当我们输出一个对象的引用时，实际上就是调用当前对象的toString() *  * 2.Object类中toString()的定义 * \t\t public String toString() &#123;        \treturn getClass().getName() + &quot;@&quot; + Integer.toHexString(hashCode());\t\t&#125;\t3.像String、Date、File、包装类等都重写了Object类中的toString()方法\t使得在调用对象的toString()时，返回“实体内容”信息 * * 4.自定义类也可以重写toString()方法，当调用此方法时，返回实体内容 */package chapter05;/** * @author Dopphu * */public class Test10toString &#123;\tpublic static void main(String[] args) &#123;\t\tCustomer cust1 = new Customer(12,&quot;Dophu&quot;);\t\tSystem.out.println(cust1.toString());\t\tSystem.out.println(cust1);\t\t\t\tString s1 = new String(&quot;MM&quot;);\t\tSystem.out.println(s1.toString());//String类对toString()方法重写过\t&#125;&#125;class Customer&#123;\tint age;\tString name;\t\t//自动快捷生成toString()方法\t@Override\tpublic String toString() &#123;\t\treturn &quot;Customer [age=&quot; + age + &quot;, name=&quot; + name + &quot;]&quot;;\t&#125;\t/**\t * \t */\tpublic Customer() &#123;\t\tsuper();\t&#125;\t/**\t * @param age\t * @param name\t */\tpublic Customer(int age, String name) &#123;\t\tsuper();\t\tthis.age = age;\t\tthis.name = name;\t&#125;\t&#125;\n\n","categories":["Java Language Basics","第五章 面向对象(中)"],"tags":[]},{"title":"08 Object类","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E4%BA%94%E7%AB%A0/08%20Object%E7%B1%BB/","content":"/** * java.lang.Object 类 * 1.Object类是所有java类的根父类 * 2.如果在类的声明中未使用extends关键字指明其父类，则默认父类为java.lang.Object类 * 3.Object类中的功能（方法、属性）就具有通用性 *  * 4.Object类只声明了一个空参的构造器 *  * 方法：equals、toString、getClass、hashCode、clone、finalize、wait、notify、notifyAll *  * 面试题：final、finally、finalize的区别 */package chapter05;/** * @author Dopphu * */public class Test09 &#123;\tpublic static void main(String[] args) &#123;\t\tOrder order = new Order();\t\tSystem.out.println(order.getClass().getSuperclass());\t\t\t&#125;&#125;class Order&#123;\tvoid demo() &#123;\t\t\t&#125;&#125;\n\n","categories":["Java Language Basics","第五章 面向对象(中)"],"tags":[]},{"title":"07 多态性的使用举例","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E4%BA%94%E7%AB%A0/07%20%E5%A4%9A%E6%80%81%E6%80%A7%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%BE%E4%BE%8B/","content":"/** * 多态性的使用举例 */package chapter05;/** * @author Dopphu * */public class Test08 &#123;\tpublic static void main(String[] args) &#123;\t\tTest08 test = new Test08();\t\t//有了多态性就省了重载方法了了\t\ttest.func(new Animal());\t\ttest.func(new Dog());\t\ttest.func(new Cat());\t&#125;\t\tpublic void func(Animal animal) &#123;\t\tanimal.eat();\t\tanimal.shout();\t&#125;&#125;class Animal&#123;\tpublic void eat() &#123;\t\tSystem.out.println(&quot;动物吃饭&quot;);\t&#125;\tpublic void shout() &#123;\t\tSystem.out.println(&quot;动物叫&quot;);\t&#125;&#125;class Dog extends Animal &#123;\t public  void eat() &#123;\t\t System.out.println(&quot;狗吃骨头&quot;);\t &#125;\t public void shout() &#123;\t\t System.out.println(&quot;汪汪汪&quot;);\t &#125;&#125;class Cat extends Animal &#123;\tpublic void eat() &#123;\t\tSystem.out.println(&quot;猫爱吃鱼&quot;);\t&#125;\tpublic void shout()&#123;\t\tSystem.out.println(&quot;喵喵喵&quot;);\t&#125;&#125;\n\n","categories":["Java Language Basics","第五章 面向对象(中)"],"tags":[]},{"title":"06 面向对象特征之多态性","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E4%BA%94%E7%AB%A0/06%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%89%B9%E5%BE%81%E4%B9%8B%E5%A4%9A%E6%80%81%E6%80%A7/","content":"/** * 面向对象特征之多态性 *  * 1.理解多态性：可以理解为一个事物的多种形态 * 2.何为多态性 * \t\t对象的多态性：父类的引用指向子类的对象（或者子类的对象赋给父类的引用） * 3.多态的使用，虚拟方法调用 * \t\t有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但在运行期，我们实际执行的是 * \t\t子类重写父类的方法 * 总结：编译看右边，运行看右边 *  * 4.多态性的使用前提：1）类的继承关系；2）方法的重写 *  * 5.对象的多态性：只适用于方法，不适用与属性，属性的话都看右边 *  * instanceof 关键字的使用 */package chapter05;/** * @author Dopphu * */public class Test07 &#123;\tpublic static void main(String[] args) &#123;\t\tPerson p1 = new Person();\t\t\t\tMan man = new Man();\t\tman.eat();\t\tman.earnMoney();\t\t\t\t//*******************************\t\tSystem.out.println(&quot;**********&quot;);\t\t//对象的多态性:父类的引用指向子类的对象\t\tPerson p2 = new Man();\t\t\t\tp2.eat();//调用的是子类重写的eat()方法，虽然p2是Person类型，\t\t//但是实际上赋了Man类型，所以调用的是重写的eat()方法//\t\tp2.walk();//不能调用，因为p2是Person类的\t\t\t\t\t\t\t\tSystem.out.println(&quot;*********************&quot;);//\t\t对于p2来说不能调用子类特有的属性和方法//\t\tp2.isSmoking = true;//\t\tp2.earnMoney();\t\t//有了对象的多态性以后，内存中实际是加载了子类特有的属性和方法，但是由于变量声明为父类类型，\t\t//导致编译时，只能调用父类中声明的属性和方法。子类特有的属性和方法不能调用。\t\t\t\t//那么如何才能调用子类特有的属性和方法呢？使用强制类型转换\t\tMan m1 = (Man)p2;\t\tm1.earnMoney();\t\tm1.isSomking  = true;\t\t//下面这么转就不行//\t\tWoman w1 = (Woman)p2;//\t\tw1.goShopping();\t\t\t\t//为了正确的转换，引入instanceof关键字的使用\t\t/*\t\t * instanceof关键字的使用\t\t *\t\t * a instanceof A ——判断对象a是否是A的实例，如果是返回，true否则返回false\t\t *\ta是A的子类，则是true\t\t * */\t\t\t\tif(p2 instanceof Woman) &#123;\t\t\tSystem.out.println(&quot;is womon&quot;);\t\t&#125;\t\tif(p2 instanceof Person) &#123;\t\t\tSystem.out.println(&quot;is Person&quot;);\t\t&#125;\t\tif(p2 instanceof Object) &#123;\t\t\tSystem.out.println(&quot;is Object&quot;);\t\t&#125;\t\t\t\t//练习\t\t//问题一：编译通过，运行不通过//\t\tPerson p3 = new Woman();//\t\tMan m3 = (Man)p3;\t\t\t\t//问题二：编译通过，运行也通过\t\tObject obj = new Woman();\t\tPerson p = (Person)obj;\t\tSystem.out.println(p2.age);//0\t\t//问题三：编译不过，运行也过(编译都不通过，运行就更不可能了)//\t\tMan m4 = new Woman();//\t\tMan m5 = new Person();\t&#125;&#125;class Man extends Person&#123;\tpublic boolean isSomking;\tdouble age=123;\t\tpublic void earnMoney() &#123;\t\tSystem.out.println(&quot;男人负责赚钱养家&quot;);\t&#125;\t\tpublic void eat() &#123;\t\tSystem.out.println(&quot;男人多吃肉，长肌肉&quot;);\t&#125;\t\tpublic void walk() &#123;\t\tSystem.out.println(&quot;男人霸气的走路&quot;);\t&#125;&#125;class Woman extends Person&#123;\tboolean isBeauty;\tpublic void goShopping() &#123;\t\tSystem.out.println(&quot;女人喜欢购物&quot;);\t&#125;\tpublic void eat() &#123;\t\tSystem.out.println(&quot;女人少吃，为了减肥&quot;);\t&#125;\tpublic void walk() &#123;\t\tSystem.out.println(&quot;女人窈窕的走路&quot;);\t&#125;&#125;\n\n","categories":["Java Language Basics","第五章 面向对象(中)"],"tags":[]},{"title":"05 子类对象实例化的全过程","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E4%BA%94%E7%AB%A0/05%20%E5%AD%90%E7%B1%BB%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E7%9A%84%E5%85%A8%E8%BF%87%E7%A8%8B/","content":"/** * 子类对象实例化的全过程 *  * 1.从结果上看：（继承性） * \t\t子类继承父类以后，就获得了父类中声明的属性或方法 * \t\t创建子类对象时，在堆空间中，就会加载所有父类声明的属性 * 2.从过程上看： * \t\t当我们通过子类的构造器创建子类对象时，我们一定会直接或间接调用其父类的构造器。 * \t\t直到调用了java.lang.Object类中空参的构造器为止，正因为加载过所有的父类的结构，所以才可以看到内存中有父类中的结构 * \t\t子类对象才可以考虑进行调用。 * 明确：虽然创建子类对象时调用了父类的构造器，但是自始至终只创建过一个对象，即为new的子类对象 */package chapter05;/** * @author Dopphu * */public class Test06 &#123;&#125;\n\n","categories":["Java Language Basics","第五章 面向对象(中)"],"tags":[]},{"title":"04 super关键字的使用","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E4%BA%94%E7%AB%A0/04%20super%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%BF%E7%94%A8/","content":"/** * super关键字的使用 * 1.super理解为：父类的 * 2.super可以用来调用：属性、方法、构造器 * 3.super的使用 * \t\t3.1我们可以在子类的方法或构造器中，通过使用“super.属性”或“super.方法”的方式显式地调用 * \t\t父类中声明的属性或方法。但是，通常情况下，我们习惯省略“super”（跟省略this的道理差不多） * \t\t3.2特殊情况：当子类和父类中定义了同名的属性时，我们要想在子类中调用父类声明的属性，则必须 * \t\t显式使用“super.属性”的方式，表名调用的是父类中声明的属性 * \t\t3.3同3.2，重写父类的方法后，super可以调用父类被重写的方法 *  * 4.super来调用构造器 * \t\t4.1我们可以在子类的构造器中显示的使用“super(形参列表)”的方式，调用父类中声明的构造器 * \t\t4.2“super(形参列表)”的使用，必须声明在子类构造器的首行！ * \t\t4.3我们在类的构造器中，针对于“this(形参列表)”和“super(形参列表)”只能二选一（因为只有一个首行） * \t\t4.4默认会调用super() * \t\t4.5在类的多个构造器中，至少有一个构造器使用了“super(形参列表)”,调用父类中的构造器 * \t\t   */package chapter05;/** * @author Dopphu * */public class Test05super extends Student&#123;\tTest05super()&#123;//\t\tsuper(12);\t\t//啥也不写，默认就会调用super()\t&#125;\tvoid method()&#123;\t\tsuper.study();\t&#125;\t&#125;////class Test&#123;//\tpublic static void main(String[] args) &#123;//\t\tTest05super demo =  new Test05super();//\t&#125;//&#125;\n\n","categories":["Java Language Basics","第五章 面向对象(中)"],"tags":[]},{"title":"03 方法的重写（override、overwrite）","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E4%BA%94%E7%AB%A0/03%20%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99%EF%BC%88override%E3%80%81overwrite%EF%BC%89/","content":"/** * 子类的方法覆盖父类符方法——方法的重写（override、overwrite） * 方法名和形参列表都一致 * 重写后子类的对象调用时，就执行子类重写的方法 * 子类重写的方法的权限要求不小于父类 *  * 重写的规定： * \t\t方法的声明：权限修饰符 返回值类型 方法名()&#123;//方法体&#125; * \t * \t\t特殊情况：子类不能重写父类中被private修饰的方法， * \t\t\t因为不可见了嘛，就和自己又定义一个方法一样，这种形式不叫重写而已 * \t\t返回值类型： * \t\t\t父类方法为void，子类也要求为void * \t\t\t父类被重写的返回值类型为A，则子类重写的方法返回值为A或A的自子类 * \t\t\t（基本数据类型就必须保持一致） * \t\t\t子类重写的方法抛出的异常类型大小不大于父类被重写的方法抛出的异常（具体的异常处理再讲） * -------------------------------------------------------------------- * \t\t\t子类和父类中同名同参数的方法要么都声明为非static（考虑重写），要么都声明为static的（不考虑重写或者不称为重写） * \t\t\tstatic方法不能被覆盖，是随着类的加载而加载的 */package chapter05;/** * @author Dopphu * */public class Test03 &#123;\tpublic static void main(String[] args) &#123;\t\tStudentOverrideTest demo = new StudentOverrideTest();\t\tPersonOverrideTest fa = new PersonOverrideTest();\t\t\t\tdemo.test();\t\tfa.test();\t&#125;&#125;class PersonOverrideTest&#123;\tvoid test() &#123;\t\tSystem.out.println(&quot;Person&quot;);\t&#125;\tObject testR() &#123;\t\treturn 2.3;\t&#125;\t\tstatic void walooo() &#123;\t\t\t&#125;&#125;class StudentOverrideTest extends PersonOverrideTest&#123;\tvoid test() &#123;\t\tSystem.out.println(&quot;Students&quot;);\t&#125;\t\tString  testR() &#123;//String 是 Object的子类\t\treturn &quot;123&quot;;\t&#125;\t\tstatic void wallooo() &#123;\t\t\t&#125;\t&#125;\n\n","categories":["Java Language Basics","第五章 面向对象(中)"],"tags":[]},{"title":"02 一个继承的练习","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E4%BA%94%E7%AB%A0/02%20%E4%B8%80%E4%B8%AA%E7%BB%A7%E6%89%BF%E7%9A%84%E7%BB%83%E4%B9%A0/","content":"/** * 一个继承的练习 */package chapter05;/** * @author Dopphu * */public class Test01Extend01 &#123;\tpublic static void main(String[] args) &#123;\t\tKids demo = new Kids(12);\t&#125;&#125;class ManKind&#123;\tprivate int sex;//man:1,women:0\tprivate int salary;\t\t/**\t * \t */\tpublic ManKind() &#123;\t\t\t&#125;\t/**\t * @param sex\t * @param salary\t */\tpublic ManKind(int sex, int salary) &#123;\t\tthis.sex = sex;\t\tthis.salary = salary;\t&#125;\tvoid manOrWoman() &#123;\t\tif(sex==1) &#123;\t\t\tSystem.out.println(&quot;man&quot;);\t\t&#125;else &#123;\t\t\tSystem.out.println(&quot;woman&quot;);\t\t&#125;\t&#125;\t\tvoid employeed() &#123;\t\tif(salary==0) &#123;\t\t\tSystem.out.println(&quot;no job&quot;);\t\t&#125;else &#123;\t\t\tSystem.out.println(&quot;job&quot;);\t\t&#125;\t&#125;\t&#125;class Kids extends ManKind&#123;\tprivate int yearOld;\t\t/**\t * \t */\tpublic Kids() &#123;\t\t\t&#125;\t/**\t * @param yearOld\t */\tpublic Kids(int yearOld) &#123;\t\tthis.yearOld = yearOld;\t&#125;\tvoid printAge() &#123;\t\tSystem.out.println(&quot;yearsOld:&quot;+yearOld);\t&#125;&#125;\n\n","categories":["Java Language Basics","第五章 面向对象(中)"],"tags":[]},{"title":"01 面向对象的特征之一——继承","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E4%BA%94%E7%AB%A0/01%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E5%BE%81%E4%B9%8B%E4%B8%80%E2%80%94%E2%80%94%E7%BB%A7%E6%89%BF/","content":"/** * 面向对象的特征——继承 *  * 一、继承性的好处 * \t1）减少了代码的冗余，提高了代码的复用性 * \t2）便于功能的扩展 * \t3）为之后多态性的使用提供了前提 *  * 二、继承的格式：class A extends B&#123;&#125; * \t\tA 子类、派生类、subclass * \t\tB 父类、超类、基类、superclass *  * \t1.体现：一旦子类继承了父类以后，子类就获得了父类中声明的结构（属性和方法） * 特别地，父类中声明为private的属性或方法，子类继承父类以后，仍然认为获得了父类中私有的结构。 * 只有因为封装性的影响，使得子类不能直接调用父类的结构 * \t2.子类继承父类以后，还可以声明自己特有的属性和方法，实现功能的扩展。 * 子类通常比父类更加丰富，不同于集合与子级的关系 *  * 三、Java中关于继承的规定 * \t1.一个类可以被多个子类继承 * \t2.一个类只能有一个父类 * \t3.子父类是相对的概念，可以多层继承 * \t4.子类直接继承的类叫直接父类，间接继承的父类称为间接父类 * \t5.子类继承父类以后，就获取了直接父类以及所有间接父类中声明的属性和方法 *  * 四、 * \t1.如果我们没有显式声明一个类的父类的话，则此类继承于java.lang.Object类 * \t2.所有的java类（除java.lang.Object类之外）都直接或间接继承于java.lang.Object类 * \t3.意味着，所有的java类具有java.lang.Object类声明的功能 */package chapter05;/** * @author Dopphu * */public class Test00继承 &#123;\tpublic static void main(String[] args) &#123;\t\tStudent demo = new Student();demo.study();\t&#125;&#125;//继承格式class Person&#123;\tint age;\t/**\t * @return the age\t */\tpublic int getAge() &#123;\t\treturn age;\t&#125;\t/**\t * @param age the age to set\t */\tpublic void setAge(int age) &#123;\t\tthis.age = age;\t&#125;\t/**\t * @return the name\t */\tpublic String getName() &#123;\t\treturn name;\t&#125;\t/**\t * @param name the name to set\t */\tpublic void setName(String name) &#123;\t\tthis.name = name;\t&#125;\tprivate String name=&quot;dopphu&quot;;\tpublic void eat() &#123;\t\tSystem.out.println(&quot;Person在吃饭&quot;);\t&#125;&#125;class Student extends Person&#123;\tint id;\t\t/**\t * @param id\t */\t\tpublic Student(int id) &#123;\t\tsuper();\t\tthis.id = id;\t&#125;\t\t/**\t * \t */\tpublic Student() &#123;\t\tsuper();\t\tSystem.out.println(&quot;我无处不在（）&quot;);\t&#125;\tvoid study()&#123;\t\tSystem.out.println(getName()+&quot;正在学习&quot;);\t&#125;&#125;\n\n","categories":["Java Language Basics","第五章 面向对象(中)"],"tags":[]},{"title":"键盘输入三个整数,进行排序并输出","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5%E4%B8%89%E4%B8%AA%E6%95%B4%E6%95%B0,%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F%E5%B9%B6%E8%BE%93%E5%87%BA/","content":"/** * 键盘输入三个整数，进行排序并输出 */import java.util.Scanner;class testOrder&#123;    public static void main(String[] args) &#123;        Scanner scan = new Scanner(System.in);        System.out.println(&quot;请输入第一个整数：&quot;);        int num1=scan.nextInt();        System.out.println(&quot;请输入第二个整数：&quot;);        int num2=scan.nextInt();        System.out.println(&quot;请输入第三个整数：&quot;);        int num3=scan.nextInt();        //if...else可以嵌套使用，但开发当中不建议过多嵌套        if(num1&gt;num2)&#123;            if(num1&lt;num3)&#123;                System.out.println(num3);                System.out.println(num1);                System.out.println(num2);            &#125;else if(num2&gt;num3)&#123;                System.out.println(num1);                System.out.println(num2);                System.out.println(num3);            &#125;else&#123;                System.out.println(num1);                System.out.println(num3);                System.out.println(num2);            &#125;        &#125;else&#123;            if(num2&lt;num3)&#123;                System.out.println(num3);                System.out.println(num2);                System.out.println(num1);            &#125;else if(num3&lt;num1)&#123;                System.out.println(num2);                System.out.println(num1);                System.out.println(num3);            &#125;else&#123;                System.out.println(num2);                System.out.println(num3);                System.out.println(num1);            &#125;        &#125;        scan.close();    &#125;&#125;\n\n","categories":["Java Language Basics","第二章 基本语法"],"tags":[]},{"title":"逻辑运算符","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6/","content":"/** * 短路或——|| * 短路与——&amp;&amp; * 开发中短路求值用的多一些 */class TestL&#123;    public static void main(String[] args) &#123;        int i = 3;        int k = 3;        if(i&gt;0|(i++&gt;0))&#123;            System.out.println(&quot;i=&quot;+i);        &#125;        if(k&gt;0||(k++)&gt;0)&#123;            System.out.println(&quot;k=&quot;+k);        &#125;    &#125;&#125;\n\n","categories":["Java Language Basics","第二章 基本语法"],"tags":[]},{"title":"赋值运算符","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6/","content":"class testF&#123;    public static void main(String[] args) &#123;        //连续赋值        int j1=1,j2=3;        j1=j2=100;        System.out.println(&quot;j1=&quot;+j1+&quot;\\nj2=&quot;+j2);        short s1=1;        // s1=s1+1;//编译失败        s1+=1;//这样的写法不会改变数据类型        System.out.println(s1);        System.out.print(j1=9);//赋值运算返回左值：9    &#125;&#125;\n\n","categories":["Java Language Basics","第二章 基本语法"],"tags":[]},{"title":"算数运算符","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E7%AE%97%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6/","content":"/*    运算符之一：算数运算符*/class operatortest&#123;    public static void main(String[] args)&#123;        //除号        int num1=12;        int num2=5;        System.out.println(num1/num2);        System.out.println(num1/(num2+0.0));        System.out.println(2%1.13);        System.out.println(&quot;----------------&quot;);        //测试取模运算符        int m1=12;        int n1=5;        System.out.println(m1%n1);//2        int m2=-12;        int n2=5;        System.out.println(m2%n2);//-2        int m3=12;        int n3=-5;        System.out.println(m3%n3);//2        int m4=-12;        int n4=-5;        System.out.println(m4%n4);//-2        //自增自减        int a=9;        System.out.println(a++);        a=9;        System.out.println(++a);        a=9;        System.out.println(a--);        System.out.println(&quot;***************************&quot;);        //三位数输出其个位十位百位        int b = 123;        int b1 = b%10;        int b2 = (b%100-b1)/10;        int b3 = (b-b2*10-b1)/100;        System.out.println(&quot;个位:&quot;+b1);        System.out.println(&quot;十位:&quot;+b2);        System.out.println(&quot;百位:&quot;+b3);    &#125;&#125;\n\n","categories":["Java Language Basics","第二章 基本语法"],"tags":[]},{"title":"比较运算符","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6/","content":"/** * 比较运算符 *  ==  !=  &gt;   &lt;   &gt;=  &lt;=  instanceof * 比较运算符的结果是boolean类型 */class TestB &#123;    &#125;\n\n","categories":["Java Language Basics","第二章 基本语法"],"tags":[]},{"title":"循环练习","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%BE%AA%E7%8E%AF%E7%BB%83%E4%B9%A0/","content":"// import java.util.Scanner;class Test&#123;    public static void main(String[] args) &#123;        // System.out.println(&quot;请输入数字，输入0结束输入&quot;);        // int count = 0;        // Scanner scan= new Scanner(System.in);        // int sum=-1;        // while(sum!=0)&#123;                    //     if(sum%2==0)&#123;        //         count++;        //     &#125;        //     sum=scan.nextInt();        // &#125;        // System.out.println(&quot;偶数的个数为：&quot;+count);        // scan.close();        for(int i = 0;i&lt;4;i++)&#123;           for(int j = 0;j&lt;=i;j++)&#123;                System.out.print(&quot;*&quot;);           &#125;            System.out.println();        &#125;//进阶：菱形星打印        //九九乘法表        for(int i = 1; i&lt;=9;i++)&#123;            for(int j = 1; j&lt;=i;j++)&#123;                System.out.print(i+&quot;*&quot;+j+&quot;=&quot;+i*j+&quot;    &quot;);            &#125;            System.out.println();        &#125;        //获取当前时间        // long start = System.currentTimeMillis();        //一百以内质数的输出        // int flag=1;        // for(int i = 2;i&lt;=1000;i++)&#123;        //     flag=1;        //     for(int j = 2; j &lt; Math.sqrt(i); j++)&#123;        //         if(i%j==0)&#123;        //             flag=0;        //             break;        //         &#125;        //     &#125;        //     if(flag==1)&#123;        //         System.out.println(i);        //     &#125;        // &#125;        // long end = System.currentTimeMillis();        // System.out.println(end-start);        // 另一个方法        int count = 0;        demo:for(int i = 2;i&lt;=10;i++)&#123;            for(int j = 2; j &lt;= Math.sqrt(i); j++)&#123;                if(i%j==0)&#123;                    continue demo;                &#125;            &#125;           count++;        &#125;        System.out.println(count);        System.out.println(Math.sqrt(2));    &#125;&#125;\n\n","categories":["Java Language Basics","第二章 基本语法"],"tags":[]},{"title":"循环求最大公倍数","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%BE%AA%E7%8E%AF%E6%B1%82%E6%9C%80%E5%A4%A7%E5%85%AC%E5%80%8D%E6%95%B0/","content":"class LowestCommonMultipleTest&#123;    public static void main(String[] args) &#123;        int num1=12,num2=15;        for(int i=num2; i&lt;num1*num2;i++)&#123;            if((i%num2==0) &amp;&amp; (i%num1==0))&#123;                System.out.println(i);                break;            &#125;        &#125;    &#125;&#125;\n\n","categories":["Java Language Basics","第二章 基本语法"],"tags":[]},{"title":"基本数据类型之间的运算规则","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BF%90%E7%AE%97%E8%A7%84%E5%88%99/","content":"/*    基本数据类型之间的运算规则    前提：这里只讨论7种基本数据类型变量间的运算。不包含boolean类型    1.自动类型提升        当容量小的变量和容量大的变量进行运算时，结果自动提升为容量大的数据类型。        byte--&gt;short--&gt;int--&gt;long--&gt;float--&gt;double        字符char、short、byte三种类型的变量做运算时，结果为int型（me：令我没想到的是同类型运算结果也是int型，不过char和char运算倒是可以理解结果为int）        弹幕：书上说java在做运算的时候，如果操作数均在int范围内，那么一律在int的空间内进行运算        说明：此时的容量大小指的是，表示数的范围大小。比如float和int（都是4字节），float的容量大些    2.强制类型转化        1）需要使用强转符：()        2）注意点：强制类型转换可能会导致精度损失（比如浮点数转整型数）    补充：两个小问题（见下）    1.    2.*/class test01&#123;    public static void main(String[] args) &#123;        //1.        // byte a = 2;        // int b = 129;        // byte d=12;        // char demo = &#x27;a&#x27;;        // // byte c = a+b;//编译不通过        // // float c = a+b;        // byte c = a+d;        // System.out.println(c);        //2.        double d1 = 23.5;        int a=128;        byte res = (byte)a;        System.out.println(res);//-128，和二进制有关        //补充            //1.            long l1 = 121212;//末尾忘记加上l/L，没报错            // long l2 = 78364872364872364;//报错超过了int类型的范围（The literal 78364872364872364 of type int is out of range ），末尾加上l/L就好了            //float e2 = 123.2;//不加f就会报错，flaot必须加f/F            //2.            //float f1 = b+12.3;//编译失败，右边会被认为是double类型            float f2 = a+0.2f;//不报错            System.out.println(f2);        do&#123;            System.out.println(&quot;你好&quot;);        &#125;while(false );    &#125;    &#125;\n\n","categories":["Java Language Basics","第二章 基本语法"],"tags":[]},{"title":"初见Scanner类","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%88%9D%E8%A7%81Scanner%E7%B1%BB/","content":"/** * 如何从键盘获取不同类型的变量：需要使用Scanner类 *  * 具体实现步骤: * 1.导包：import java.util.Scanner; */import java.util.Scanner;class ScannerTest&#123;    public static void main(String[] args) &#123;    /*    Scanner scan = new Scanner(System.in);        // int num=scan.nextInt();        String s=scan.nextLine();        // System.out.println(num);        System.out.println(s);        //对于字符（char）的获取        System.out.println(&quot;请输入你的性别：（男/女）&quot;);        // char c = (scan.next()).charAt(0);        String gender = scan.next();        char c = gender.charAt(0);        System.out.println(gender);//输入中文有问题        // scan.close();    */    //练习    Scanner scan = new Scanner(System.in);    System.out.println(&quot;请输入小鹏的成绩：（0--100）&quot;);    int score = scan.nextInt();    if(score==100)&#123;        System.out.println(&quot;奖励一辆BMW&quot;);    &#125;else if(score&gt;80&amp;&amp;score&lt;100)&#123;        System.out.println(&quot;奖励一个iPad&quot;);    &#125;else if(score&gt;60)&#123;        System.out.println(&quot;奖励一次游乐园&quot;);    &#125;    scan.close();&#125;&#125;\n\n","categories":["Java Language Basics","第二章 基本语法"],"tags":[]},{"title":"初见random","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%88%9D%E8%A7%81random/","content":"public class randomtest &#123;    public static void main(String[] args) &#123;        int num = (int)(Math.random()*10);        System.out.println(num);    &#125;&#125;\n\n","categories":["Java Language Basics","第二章 基本语法"],"tags":[]},{"title":"冒泡排序","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/","content":"class SortTest &#123;    public static void main(String[] args) &#123;        int[] sums=&#123;4,5,0,9&#125;;        System.out.print(&quot;Before    &quot;);        for(int i = 0; i&lt;sums.length; i++)&#123;            System.out.print(sums[i]+&quot; &quot;);        &#125;        for(int i = 0; i&lt;sums.length-1; i++)&#123;            for(int j = 0; j&lt;sums.length-i-1; j++)&#123;                if(sums[j]&gt;sums[j+1])&#123;                    int temp = sums[j];                    sums[j] = sums[j+1];                    sums[j+1] = temp;                &#125;            &#125;        &#125;        System.out.println();        System.out.print(&quot;After sorting    &quot;);        for(int i = 0; i&lt;sums.length; i++)&#123;            System.out.print(sums[i]+&quot; &quot;);        &#125;    &#125;&#125;\n\n","categories":["Java Language Basics","第二章 基本语法"],"tags":[]},{"title":"关于进制","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E5%85%B3%E4%BA%8E%E8%BF%9B%E5%88%B6/","content":"class test_base_system&#123;//关于进制    public static void main(String[] args)&#123;        int num1=0b110;        int num2=110;        int num3=0127;        int num4=0x110A;        System.out.println(&quot;num = &quot;+num1);        System.out.println(&quot;num = &quot;+num2);        System.out.println(&quot;num = &quot;+num3);        System.out.println(&quot;num = &quot;+num4);    &#125;&#125;\n\n","categories":["Java Language Basics","第二章 基本语法"],"tags":[]},{"title":"位运算符","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E4%BD%8D%E8%BF%90%E7%AE%97/","content":"/** * 二进制上位移运算 * 1.位运算符操作的都是整型的数据 * 2.在一定范围内相当于*2或/2的操作 * &gt;&gt;：符号位不变,其它补0 * 面试题：最高效的方式计算2*8 * 2&lt;&lt;3     8&lt;&lt;1 这两个的时间复杂度都是O(1) */class TestW&#123;    public static void main(String[] args) &#123;        byte i=-21;        System.out.println(i&lt;&lt;27);        System.out.println(i&gt;&gt;2);        //练习：交换两个变量的值        int num1=10;        int num2=11;        //方式1：临时变量        //方式2：如下(仅限数值型交换，并且有溢出风险)        num1 = num1+num2;        num2 = num1-num2;        num1 = num1-num2;        System.out.println(&quot;num1 = &quot;+num1);        System.out.println(&quot;num2 = &quot;+num2);        //方式三：位运算        num1 = num1^num2;        num2 = num1^num2;        num1 = num1^num2;    &#125; &#125;\n\n","categories":["Java Language Basics","第二章 基本语法"],"tags":[]},{"title":"三元运算符","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E4%BA%8C%E7%AB%A0/%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6/","content":"/** * 三元运算符（三目运算符）： *      (条件表达式)?表达式1:表达式2 * 表达式1和表达式2 得能用一个类型接收 * 比如：()?字符串:数字——这到底用字符串接收还是用数值类型接收呢，所以错误 *  * 凡是可以用三元运算符，都可以改写为if...else；反之不成立 * 当两者都可时，优先使用三元运算符，原因：简洁、执行效率高 */class TestS&#123;    public static void main(String[] args) &#123;        //三元运算符可以嵌套使用        int m=12,n=44;        String maxStr = (m&gt;n) ? &quot;m打&quot; : ((m&lt;n) ? &quot;n大&quot; : &quot;m和n相等&quot;);        System.out.println(maxStr);    &#125;&#125;\n\n","categories":["Java Language Basics","第二章 基本语法"],"tags":[]},{"title":"switch使用","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E4%BA%8C%E7%AB%A0/switch%E4%BD%BF%E7%94%A8/","content":"import java.util.Scanner;public class switchTest &#123;    public static void main(String[] args) &#123;        //语法和执行逻辑和C语言一致        //switch 中的表达式，只能是一下数据类型byte、short、char、int，枚举（JDK5.0新增）、String（JDK7.0新增）        //case后只能跟变量，不能跟条件表达式（可以这么理解，返回布尔，布尔不行，故不行）        //if..else和switch都可时，优先使用switch效率较高        // switch (key) &#123;        //     case value:                        //         break;                //     default:        //         break;        // &#125;        //一个比较有意思的情况。default放在最前面                switch (5) &#123;            default:                System.out.println(&quot;默认情况！&quot;);            case 1:                System.out.println(&quot;你好&quot;);                break;        &#125;//先对case 进行匹配，发现没有，就执行default的内容，因为default后没有break，所以就继续执行case 1的语句，然后从case 1执行break出去        System.out.println(&quot;-------------------------------&quot;);        int score = 58;        switch (score/10) &#123;            case 0:            case 1:            case 2:            case 3:            case 4:            case 5:                System.out.println(&quot;不及格&quot;);                break;            default:                System.out.println(&quot;及格&quot;);                break;        &#125;        //进一步改进        switch (score/60) &#123;            case 0:                System.out.println(&quot;不及格&quot;);                break;            default:                System.out.println(&quot;及格&quot;);                break;        &#125;        System.out.println(&quot;----------------------分割线----------------------&quot;);        Scanner scan = new Scanner(System.in);        System.out.println(&quot;2019年，请输入月份：&quot;);        int month = scan.nextInt();        System.out.println(&quot;请输入&quot;+month+&quot;月的第几日：&quot;);        int day=scan.nextInt();        int res = 0;        switch (month-1)&#123;            case 11:                res+=30;            case 10:                res+=31;            case 9:                res+=30;            case 8:                res+=31;            case 7:                res+=31;            case 6:                res+=30;            case 5:                res+=31;            case 4:                res+=30;            case 3:                res+=31;            case 2:                res+=28;            case 1:                res+=31;            case 0:                res+=day;                System.out.println(month+&quot;月&quot;+day+&quot;日&quot;+&quot;是2019年的第&quot;+res+&quot;天.&quot;);                break;                    default:                System.out.println(&quot;月份输入有误！&quot;);        &#125;        scan.close();    &#125;&#125;\n\n","categories":["Java Language Basics","第二章 基本语法"],"tags":[]},{"title":"String类型变量的使用","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E4%BA%8C%E7%AB%A0/String%E7%B1%BB%E5%9E%8B%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%BF%E7%94%A8/","content":"/** * String类型变量的使用 * 1.String属于引用数据类型，翻译为：字符串 * 2.声明String类型变量时，使用一对 &quot;&quot; * 3.可以为空字符串 * 4.String可以和8种基本数据类型做运算，且只能是连接运算 + //运算似乎先算左边的（没有括号的情况下） *      运算结果仍为String类型 */class StringTest&#123;    public static void main(String[] args)&#123;        String s1 = &quot;Hello ！&quot;;        // String ss = &quot;a&quot;;        System.out.println(s1+(&#x27;A&#x27;+1));//+ ：连接运算        System.out.println(&#x27;a&#x27;+1+s1);        System.out.println(Integer.parseInt(&quot;123512123&quot;));        //    &#125;&#125;\n\n","categories":["Java Language Basics","第二章 基本语法"],"tags":[]},{"title":"if_else","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E4%BA%8C%E7%AB%A0/if_else/","content":"// 只有一行的话 if...else后的大括号是可以省略的。但是不建议省略（方便后续添加语句）,没有大括号时if和else就近配对import java.util.Scanner;class if_else &#123;    public static void main(String[] args) &#123;        Scanner scan = new Scanner(System.in);        int score = scan.nextInt();        if(score&lt;60)            System.out.println(&quot;不及格&quot;);        else if(score&lt;80)&#123;            System.out.println(&quot;良好&quot;);        &#125;else&#123;            System.out.println(&quot;优秀&quot;);        &#125;        scan.close();    &#125;    &#125;\n\n","categories":["Java Language Basics","第二章 基本语法"],"tags":[]},{"title":"0916 Comparable和Comparator的使用","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E4%B9%9D%E7%AB%A0/0916%20Comparable%E5%92%8CComparator%E7%9A%84%E4%BD%BF%E7%94%A8/","content":"package chapter09;import chapter09Test.Goods;import org.junit.Test;import java.util.Arrays;import java.util.Comparator;/** * * 一、说明：Java中的对象，正常情况下，只能进行比较：== 或 != 。不能使用 &gt; 或 &lt; 的。 * 但是在日常开发场景中，我们需要对多个对象进行排序，言外之意，就需要比较对象的大小。 * 如何实现？使用两个接口中的任何一个：Comparable 或 Comparator * * 二、Comparable接口与Comparator使用的对比 *      Comparable接口的方式一旦指定，保证Comparable接口实现类的对象在任何位置都可以比较大小 *      Comparator接口属于临时性的比较。 * * * @author dopphu * @create 2021-04-12 17:12 */public class Test16 &#123;    /*    *   Comparable接口的使用举例：      自然排序    *   1.像String、包装类等实现了Comparable接口，重写了compareTo(obj)方法，给出了比较两个对象大小的规则    *   2.像String、包装类等重写了compareTo()方法以后，进行了从小到大的排序    *   3.重写comparaTo(obj) 的规则：    *       如果当前对象this大于形参对象obj，则返回正整数；    *       如果当前对象this小于形参对象obj，则返回负数；    *       如果当前对象this等于形参对象obj，则返回零    *    * */    @Test    public void test1()&#123;        String[] arr = new String[]&#123;&quot;AA&quot;,&quot;dd&quot;,&quot;ee&quot;,&quot;CC&quot;&#125;;        Arrays.sort(arr);        System.out.println(arr);        System.out.println(arr.toString());        System.out.println(Arrays.toString(arr));    &#125;    @Test    public void test2()&#123;        //使用另一个包下的Goods类，有price、name两个属性        Goods[] arr = new Goods[4];        arr[0] = new Goods(&quot;huawei华为&quot;,50);        arr[1] = new Goods(&quot;xiaomi小米&quot;,10);        arr[2] = new Goods(&quot;lianxiang联想&quot;,70);        arr[3] = new Goods(&quot;shuangfeiyan双飞燕&quot;,10);        Arrays.sort(arr);        System.out.println(Arrays.toString(arr));    &#125;    /*    * Comparator接口的使用：定制排序    * 1.背景：    * 当元素的类型没有实现java.long.Comparable接口而又不方便修改代码，    * 或者实现了java.lang.Comparable接口的排序规则不适合当前操作    * 那么可以考虑使用 Comparator 的对象来排序    * 2.重写compare(Object o1, Object o2)方法，比较o1和o2的大小：    *   如果方法返回正整数，则表示o1大于o2；    *   如果返回0，表示相等    *   返回负数，表示o1小于o2    *    * */    @Test    public void test3()&#123;        String[] arr = new String[]&#123;&quot;AA&quot;,&quot;dd&quot;,&quot;ee&quot;,&quot;CC&quot;&#125;;        Arrays.sort(arr, new Comparator&lt;String&gt;() &#123;            @Override            public int compare(String o1, String o2) &#123;                if(o1 instanceof String &amp;&amp; o2 instanceof String)&#123;                    String s1 = (String) o1;                    String s2 = (String) o2;                    return -s1.compareTo(s2);//默认从小到大，加一个负号变从大到小                &#125;//                return 0;                throw new RuntimeException(&quot;输入的类型不一致&quot;);            &#125;        &#125;);        System.out.println(Arrays.toString(arr));    &#125;    @Test    public void test4()&#123;        //使用另一个包下的Goods类，有price、name两个属性        Goods[] arr = new Goods[4];        arr[0] = new Goods(&quot;h华为&quot;,50);        arr[1] = new Goods(&quot;x小米&quot;,10);        arr[2] = new Goods(&quot;l联想&quot;,70);        arr[3] = new Goods(&quot;s双飞燕&quot;,10);        Arrays.sort(arr, new Comparator() &#123;            //指明商品比较大小的方式：按照产品名称从低到高排序，在按照价格从低到高排序            @Override            public int compare(Object o1, Object o2) &#123;                if(o1 instanceof Goods &amp;&amp; o2 instanceof Goods)&#123;                    Goods g1 = (Goods)o1;                    Goods g2 = (Goods)o2;                    if(g1.getName().equals(g2.getName()))&#123;                        return -Double.compare(g1.getPrice(), g2.getPrice());                    &#125;else&#123;                        return g1.getName().compareTo(g2.getName());                    &#125;                &#125;                throw new RuntimeException(&quot;数据类型不匹配&quot;);            &#125;        &#125;);        System.out.println(Arrays.toString(arr));    &#125;&#125;\n\n","categories":["Java Language Basics","第九章 常用类"],"tags":[]},{"title":"0915 DateTimeFormatter：格式化或解析日期、时间","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E4%B9%9D%E7%AB%A0/0915%20DateTimeFormatter%EF%BC%9A%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%88%96%E8%A7%A3%E6%9E%90%E6%97%A5%E6%9C%9F%E3%80%81%E6%97%B6%E9%97%B4/","content":"package chapter09;import org.junit.Test;import java.time.LocalDate;import java.time.LocalDateTime;import java.time.format.DateTimeFormatter;import java.time.format.FormatStyle;import java.time.temporal.TemporalAccessor;/** * @author dopphu * @create 2021-04-11 22:51 */public class Test15 &#123;    /*    * DateTimeFormatter：格式化或解析日期、时间    * 类似SimpleDateFormatter    *    *    *    * */    @Test    public void test3()&#123;//        方式一：预定义的标准格式。如：ISO_LOCAL_DATE_TIME;ISO_LOCAL_DATE;ISO_LOCAL_TIME//        方式二：本地化相关的格式。如：ofLocalizedDateTime(FormatStyle.LONG)//        方式三：自定义的格式，如：ofPattern(&quot;yyyy-MM-dd hh:mm:ss E&quot;)        DateTimeFormatter formatter = DateTimeFormatter.ISO_DATE_TIME;        System.out.println(formatter);        //格式化：日期——&gt;字符串        LocalDateTime localDateTime = LocalDateTime.now();        System.out.println(localDateTime);        String str1 = formatter.format(localDateTime);        System.out.println(str1);        //解析：字符串——&gt;日期        TemporalAccessor parse= formatter.parse(&quot;2021-04-11T23:23:26.3453121&quot;);        System.out.println(parse);        System.out.println(&quot;********************&quot;);        //方式二：本地化相关格式。如：ofLocalizedDateTime()        //FormatStyle.LONG / FormatStyle.MEDIUM / FormatStyle.SHORT ：使用于LocalDateTime        DateTimeFormatter formatter1 = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.SHORT);        //格式化        String str2 = formatter1.format(localDateTime);        System.out.println(str2);//2021/4/12 下午4:52        //本地化相关格式：如，ofLocalizedDate()        //FormatStyle.FULL / FormatStyle.LONG / FormatStyle.MEDIUM / FormatStyle.SHORT ：使用于LocalDate        DateTimeFormatter formatter2 = DateTimeFormatter.ofLocalizedDate(FormatStyle.MEDIUM);        String str3 = formatter2.format(LocalDate.now());        System.out.println(str3);//2021年4月12日        //方式三：自定义的格式。如：ofPattern(&quot;yyyy-MM-dd hh:mm&quot;ss&quot;)        DateTimeFormatter formatter3 = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd hh:mm:ss&quot;);        String str4 = formatter3.format(LocalDateTime.now());        System.out.println(str4);        //解析        TemporalAccessor accessor = formatter3.parse(&quot;2021-04-12 05:01:04&quot;);        System.out.println(accessor);    &#125;&#125;\n\n","categories":["Java Language Basics","第九章 常用类"],"tags":[]},{"title":"0914 Instant （瞬时点） 的使用","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E4%B9%9D%E7%AB%A0/0914%20Instant%20%EF%BC%88%E7%9E%AC%E6%97%B6%E7%82%B9%EF%BC%89%20%E7%9A%84%E4%BD%BF%E7%94%A8/","content":"package chapter09;import org.junit.Test;import java.time.Instant;import java.time.OffsetDateTime;import java.time.ZoneOffset;/** * * Instant （瞬时点） 的使用 * 类似于java.util.Date类 * * @author dopphu * @create 2021-04-11 22:33 */public class Test14 &#123;    @Test    public void test1()&#123;        //now()：获取本初子午线对应的标准时间        Instant instant = Instant.now();//默认格林威治时间（本初子午线），比东八区晚8个小时        System.out.println(instant);        //添加时间的偏移量        OffsetDateTime offsetDateTime = instant.atOffset(ZoneOffset.ofHours(8));        System.out.println(offsetDateTime);//例子：2021-04-11T22:39:20.840595400+08:00        //toEpochMilli()：获取自1970年1月1日0时0分0秒（UTC）开始的毫秒数——Date类的getTime方法        long milli = instant.toEpochMilli();        System.out.println(milli);        //ofEpochMilli()：通过给定的毫秒数，获取Instant实例 ——&gt; Date(long millis)        Instant instant1 = Instant.ofEpochMilli(1618152169715L);        System.out.println(instant1);    &#125;&#125;\n\n","categories":["Java Language Basics","第九章 常用类"],"tags":[]},{"title":"0913 LocalDate、LocalTime、LocalDateTime 的使用","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E4%B9%9D%E7%AB%A0/0913%20LocalDate%E3%80%81LocalTime%E3%80%81LocalDateTime%20%E7%9A%84%E4%BD%BF%E7%94%A8/","content":"package chapter09;import org.junit.Test;import java.time.LocalDate;import java.time.LocalDateTime;import java.time.LocalTime;import java.util.Date;/** * @author dopphu * @create 2021-04-11 17:01 */public class Test13 &#123;    @Test    public void testDate()&#123;        //偏移量        Date date1 = new Date(2021-1900,4-1,11);        System.out.println(date1);    &#125;    /*    *    * LocalDate、LocalTime、LocalDateTime 的使用    * 日期        时间          日期和时间    * 说明：    *   1.LocalDateTime相较于LocalDate、LocalTime，使用率要高    *   2.类似于Calender    *    *    * */    @Test    public void test1()&#123;//实例化：now() 或 of() 这两种方式        //now()：获取当前的日期、时间、日期+时间        LocalDate localDate = LocalDate.now();        LocalTime localTime = LocalTime.now();        LocalDateTime localDateTime = LocalDateTime.now();        System.out.println(localDate);        System.out.println(localTime);        System.out.println(localDateTime);        System.out.println(&quot;*********************************&quot;);        //of()：设置指定的年月日时分秒是没有偏移量的        LocalDateTime localDateTime1 = LocalDateTime.of(2021,10,11,17,59);        System.out.println(localDateTime1);        //getXxx()        System.out.println(localDateTime.getDayOfMonth());        System.out.println(localDateTime.getDayOfWeek());        System.out.println(localDateTime.getMonth());//如：四月返回 APRIL        System.out.println(localDateTime.getMonthValue());//如：四月，返回 4        System.out.println(localDateTime.getMinute());        //体现不可变性        //withXxx()：设置相关的属性        System.out.println(&quot;-------------------------------------&quot;);        LocalDate localDate1 = localDate.withDayOfMonth(22);        System.out.println(localDate1);        System.out.println(localDate);//并未发生改变        LocalDateTime localDateTime2 = localDateTime.withHour(4);        System.out.println(localDateTime2);        System.out.println(localDateTime1);        System.out.println(&quot;------------------------------------&quot;);        //不可变性        LocalDateTime localDateTime3 = localDateTime.plusMonths(3);        System.out.println(localDateTime3);        System.out.println(localDate);    &#125;&#125;\n\n","categories":["Java Language Basics","第九章 常用类"],"tags":[]},{"title":"0912 Calender 日历类（抽象类）的使用","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E4%B9%9D%E7%AB%A0/0912%20Calender%20%E6%97%A5%E5%8E%86%E7%B1%BB%EF%BC%88%E6%8A%BD%E8%B1%A1%E7%B1%BB%EF%BC%89%E7%9A%84%E4%BD%BF%E7%94%A8/","content":"package chapter09;import org.junit.Test;import java.util.Calendar;import java.util.Date;/** * @author dopphu * @create 2021-04-11 16:37 */public class Test12 &#123;    /*    *    * Calender 日历类（抽象类）的使用    *    * */    @Test    public void tsetCalender()&#123;        //1.实例化        //方式一：创建其子类（GregorianCalendar）的对象        //方式二：调用其静态的方法getInstance()        Calendar calendar = Calendar.getInstance();        System.out.println(calendar.getClass());        //2.常用方法        //get()：获取常用的属性信息        int days = calendar.get(Calendar.DAY_OF_MONTH);        System.out.println(days);        System.out.println(calendar.get(Calendar.DAY_OF_YEAR));        //set()：修改        calendar.set(Calendar.DAY_OF_MONTH,10);        days = calendar.get(Calendar.DAY_OF_MONTH);        System.out.println(days);        //add()        calendar.add(Calendar.DAY_OF_MONTH,3);//        calendar.add(Calendar.DAY_OF_MONTH,-3);//减去天数        days = calendar.get(Calendar.DAY_OF_MONTH);        System.out.println(days);        //getTime()：日历类——&gt;Date        Date date1 = calendar.getTime();        System.out.println(date1);        System.out.println(&quot;**************分割线**************&quot;);        //setTime()：Date——&gt;日历类        Date date = new Date();        calendar.setTime(date);        System.out.println(date);        System.out.println(calendar.get(Calendar.DAY_OF_MONTH));    &#125;&#125;\n\n","categories":["Java Language Basics","第九章 常用类"],"tags":[]},{"title":"0911 JDK 8之前日期时间的API测试","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E4%B9%9D%E7%AB%A0/0911%20JDK%208%E4%B9%8B%E5%89%8D%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E7%9A%84API%E6%B5%8B%E8%AF%95/","content":"package chapter09;import org.junit.Test;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;/** * * JDK 8之前日期时间的API测试 * * 1. System类中currentTimeMillis() * 2. java.util.Date和子类java.sql.Date * 3. SimpleDateFormat * 4. Calender * * * @author dopphu * @create 2021-04-11 15:03 */public class Test11 &#123;        /*        * SimpleDateFormat的使用：SimpleDateFormat对日期Date类的格式化和解析        *        * 1.两个操作        *   1.1 格式化：日期——&gt;字符串        *   1.2 解析：格式化的逆过程，字符串——&gt;日期        *        * 2.SimpleDateFormat的实例化        *        *        *        * */        @Test        public void testSimpleDateFormat() throws ParseException &#123;            //实例化SimpleDateFormat            SimpleDateFormat sdf = new SimpleDateFormat();            //格式化：日期——&gt;字符串            Date date = new Date();            System.out.println(date);            String res = sdf.format(date);            System.out.println(res);//&quot;2021/4/11 下午3:10&quot;            //解析：格式化的逆过程，字符串——&gt;日期            String str = &quot;2011/14/11 下午3:13&quot;;            Date date1 = sdf.parse(str);//因为你可能传一个不符合格式的字符串，所以要么异常处理，要么抛异常            System.out.println(date1);            System.out.println(&quot;********************&quot;);//            按照指定方式进行格式化            SimpleDateFormat sdf2 = new SimpleDateFormat(&quot;yyy-MM-dd hh:mm:ss&quot;);            //格式化            String format1 = sdf2.format(date);            System.out.println(format1);            //解析：要求字符串必须是符合SimpleDateFormat识别的格式(通过构造器参数体现)            //否则就会抛异常            Date date2 = sdf2.parse(&quot;2020-02-11 11:11:11&quot;);            System.out.println(date2);        &#125;        /*        *        * 练习一：字符串&quot;2020-0908&quot;转换为java.sql.Date        *        * */        @Test        public void test2() throws ParseException &#123;            String birth = &quot;2020-06-11&quot;;            SimpleDateFormat sdf1 = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);            Date resDate = sdf1.parse(birth);            System.out.println(resDate);            //将java.util.Date转为java.sql.Date            java.sql.Date resSqlDate = new java.sql.Date(resDate.getTime());            System.out.println(resSqlDate);        &#125;&#125;\n\n","categories":["Java Language Basics","第九章 常用类"],"tags":[]},{"title":"0910 一个易出错的题，可以当做面试题","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E4%B9%9D%E7%AB%A0/0910%20%E4%B8%80%E4%B8%AA%E6%98%93%E5%87%BA%E9%94%99%E7%9A%84%E9%A2%98%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%BD%93%E5%81%9A%E9%9D%A2%E8%AF%95%E9%A2%98/","content":"package chapter09;import org.junit.Test;/** * * 一个易出错的题，可以当做面试题 * * @author dopphu * @create 2021-04-11 14:51 */public class Test10 &#123;    @Test    public void main()&#123;        String str = null;//        System.out.println(str.length());//空指针异常NullPointerException        StringBuffer sb = new StringBuffer();        sb.append(str);//不会报错        System.out.println(sb.length());//4        System.out.println(sb);//&quot;null&quot;，是一个字符串//        StringBuffer sb1 = new StringBuffer(str);//抛异常//        System.out.println(sb1);    &#125;&#125;\n\n","categories":["Java Language Basics","第九章 常用类"],"tags":[]},{"title":"0909 JDK 8之前日期和时间的API测试","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E4%B9%9D%E7%AB%A0/0909%20JDK%208%E4%B9%8B%E5%89%8D%E6%97%A5%E6%9C%9F%E5%92%8C%E6%97%B6%E9%97%B4%E7%9A%84API%E6%B5%8B%E8%AF%95/","content":"package chapter09;import org.junit.Test;import java.util.Date;/** * * JDK 8之前日期和时间的API测试 * * * @author dopphu * @create 2021-04-11 10:29 */public class Test09 &#123;    public static void main(String[] args) &#123;    &#125;    @Test    public void test1()&#123;        //1.System类中的currentTimeMillis()        long time = System.currentTimeMillis();        //返回当前时间与1970年01月01日00时00分00秒之间以毫秒为单位的时间差        //成为时间戳        System.out.println(time);    &#125;    @Test    public void test2()&#123;        /*        * java.util.Date类        *           |--- java.sql.Date类        *        * 1.两个构造器的使用        *       构造器一：创建一个当前时间的Date对象        *       构造器二：创建指定毫秒数的Date对象        * 2.两个方法的使用        *   toString()：显示当前的年、月、日、时、分、秒        *   getTime()：获取当前Date对象对应的毫秒数（时间戳）        *        *        * 3.java.sql.Date对应数据库中的日期类型的变量        *       1）如何实例化        *        *       2）将java.sql.Date 转换为 java.util.Date        *               子类转父类，多态直接强转即可        *       3）将java.util.Date 转换为 java.sql.Date        *        *        *        * */        //构造器一：创建一个当前时间的Date对象        Date date1 = new Date();        System.out.println(date1.toString());        System.out.println(date1.getTime());        //构造器二：创建指定毫秒数的Date对象        Date date2 = new Date(1618108721043L);        System.out.println(date2.toString());        java.sql.Date date3 = new java.sql.Date(1618108875378L);        System.out.println(date3.toString());        //如何将java.util.Date对象转换为java.sql.Date对象        //情况一：        Date date5 = new java.sql.Date(1618108875378L);        java.sql.Date date6 = (java.sql.Date)date5;//        情况二：        //两者共通的就是时间戳（毫秒数）        Date date7 = new Date();        Date dte4 = new java.sql.Date(date7.getTime());    &#125;&#125;\n\n","categories":["Java Language Basics","第九章 常用类"],"tags":[]},{"title":"0908 StringBuffer的常用方法","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E4%B9%9D%E7%AB%A0/0908%20StringBuffer%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/","content":"package chapter09;/** * * StringBuffer的常用方法 * * StringBuffer append(xxx)：提供了很多append()方法，用于字符串的拼接 * StringBuffer delete(int start, int end)：删除指定位置的内容(左闭右开) * StringBuffer replace(int start, int end, String str)：把[start, end)位置替换为str * StringBuffer insert(int offset, xxx)：在指定位置插入xxx * StringBuffer reverse()：将当前字符串反转 * public int indexOf(String str) * public String substring(int start, int end) * public int Length() * public char charAt(int n) * public void setCharAt(int n, char ch) * * * @author dopphu * @create 2021-04-11 10:12 */public class Test08 &#123;    public static void main(String[] args) &#123;        StringBuffer s1 = new StringBuffer(&quot;anc&quot;);        s1.append(11);        System.out.println(s1);        s1.delete(0,2);        System.out.println(s1);        s1.reverse();        System.out.println(s1);    &#125;&#125;\n\n","categories":["Java Language Basics","第九章 常用类"],"tags":[]},{"title":"0907 关于StringBuffer和StringBuilder的使用","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E4%B9%9D%E7%AB%A0/0907%20%E5%85%B3%E4%BA%8EStringBuffer%E5%92%8CStringBuilder%E7%9A%84%E4%BD%BF%E7%94%A8/","content":"package chapter09;import org.junit.Test;/** * * 关于StringBuffer和StringBuilder的使用 * * StringBuffer是线程安全的，方法都加了synchronized 关键字 *  String 效率最低 * * @author dopphu * @create 2021-04-10 20:10 */public class Test07 &#123;    /*    *    * String、StringBuffer、StringBuilder三者的异同？    *    * String：不可变的字符序列：底层使用char[] 进行存储    * StringBuffer：可变的字符序列，线程安全的，效率低：底层使用char[] 进行存储    * StringBuilder：可变的字符序列，jdk5.0新增，线程不安全，效率高：底层使用char[] 进行存储    *    * 源码分析    * String str = new String();//char[] value = new char[0];    * String str1 = new String(&quot;a,b,c&quot;);//char[] value = new char[]&#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;&#125;;    *    * StringBuffer sb1 = new StringBuffer();//char[] value = new char[16];底层创建了一个长度是16的数组。    * sb1.append(&#x27;a&#x27;);//value[0] = &#x27;a&#x27;;    * sb1.append(&#x27;b&#x27;);//value[1] = &#x27;b&#x27;;    *    * StringBuffer sb2 = new StringBuffer(&quot;abc&quot;);//char[] value = new char[&quot;abc&quot;.length()+16];    * 注：StringBuilder也是这么扩容的    * //问题1，System.out.println(sb2.length());//3    * //问题2，扩容问题：如果要添加的数据底层数组盛不下了，那就需要扩容底层的数组。    *       默认情况下，扩容为原来容量的2倍+2，同时、将原有数组中的元素复制的到新的数组中。    *    *        指导意义：建议大家使用：StringBuffer(int capacity) 或 StringBuilder(int capacity)——就是一开始    *           就指定一个长度，省的不够了再扩容。然后根据是否需要线程安全选择用StringBuffer还是StringBuilder    *    * */    @Test    public void test1()&#123;        StringBuffer sb1 = new StringBuffer(&quot;abcde&quot;);        StringBuffer sb2 = new StringBuffer();        System.out.println(sb2.length());//返回0（不是16啊喂）        sb1.setCharAt(0,&#x27;w&#x27;);        System.out.println(sb1);        System.out.println(sb1.length());    &#125;&#125;\n\n","categories":["Java Language Basics","第九章 常用类"],"tags":[]},{"title":"0906 涉及到String类中与其它结构之间的转换","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E4%B9%9D%E7%AB%A0/0906%20%E6%B6%89%E5%8F%8A%E5%88%B0String%E7%B1%BB%E4%B8%AD%E4%B8%8E%E5%85%B6%E5%AE%83%E7%BB%93%E6%9E%84%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/","content":"package chapter09;import org.junit.Test;import java.io.UnsupportedEncodingException;import java.util.Arrays;/** * * 涉及到String类中与其它结构之间的转换 * * @author dopphu * @create 2021-04-10 19:20 */public class Test06 &#123;    public static void main(String[] args) &#123;        /*        * 只有字符类关系的才可以进行强转        *        * 复习：        * String 与基本数据类型、包装类之间的转换        *        * String ——&gt; 基本数据类型、包装类：调用包装类的静态方法——parseXxx(str)        * 基本数据类型、包装类 ——&gt; String：调用String重载的valueOf(xxx)        * */        String str1 = &quot;123&quot;;        String str2 = &quot;121233asd&quot;;//        int num = (int)str1;//错误 的        int num1 = Integer.parseInt(str1);//        int num2 = Integer.parseInt(str2);//java.lang.NumberFormatException 包含字母会报错        System.out.println(num1);        int num3 = 1;        System.out.println(String.valueOf(num3));        String str3 = &quot;1&quot;;        System.out.println(String.valueOf(num3)==str3);//false    &#125;    @Test    public void test1()&#123;        /*        *        * String 与 char[] 之间的转换        *        * String ——&gt; char[]：调用String的toCharArray()        * char[] ——&gt; String：调用String的构造器        *        * */        String s1 = &quot;abc123&quot;;        char[] charArr1 = s1.toCharArray();        for(int i = 0; i &lt; charArr1.length; i++)&#123;            System.out.println(charArr1[i]);        &#125;        char[] charArr2 = new char[]&#123;&#x27;h&#x27;,&#x27;e&#x27;,&#x27;l&#x27;,&#x27;l&#x27;,&#x27;o&#x27;&#125;;        String str2 = new String(charArr2);        System.out.println(str2);    &#125;    @Test    public void test3() throws UnsupportedEncodingException &#123;        /*        * String 与 byte[] 之间的转换        * String ——&gt; byte[]：调用String的getBytes()        *说明：        * 解码时，要求解码使用的字符集必须与编码时使用的字符集一致，否则会出现乱码        *        * */        String str1 = &quot;abc123中国&quot;;//涉及编码集，当前使用utf-8，一个汉字三个字节        byte[] bytes = str1.getBytes();//使用默认的字符集        System.out.println(Arrays.toString(bytes));        try &#123;            System.out.println(Arrays.toString(str1.getBytes(&quot;gbk&quot;)));            /*gbk中一个汉字两个字节*/        &#125; catch (UnsupportedEncodingException e) &#123;            e.printStackTrace();        &#125;        System.out.println(&quot;********************&quot;);        String str2 = new String(Arrays.toString(bytes));///使用默认字符集进行解码        System.out.println(str2);        String str3 = new String(str1.getBytes(&quot;gbk&quot;));        System.out.println(str3);//出现乱码。原因：编码集和解码集不一致。        String str4 = new String(str1.getBytes(&quot;gbk&quot;),&quot;gbk&quot;);        System.out.println(str4);//没有出现乱码，解码与编码使用的字符集一致    &#125;&#125;\n\n","categories":["Java Language Basics","第九章 常用类"],"tags":[]},{"title":"0905 String方法3","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E4%B9%9D%E7%AB%A0/0905%20String%E6%96%B9%E6%B3%953/","content":"package chapter09;/** * * String方法3 * * String replace(char oldChar, char newChar)：返回一个新的字符串，它是通过用newChar替换此字符串 * 中出现的所有oldChar得到 * * String replace(CharSequence target, CharSequence replacement)：使用指定的字面值替换序列 * 替换此字符串所有匹配字面值目标序列的子字符串 * * String replaceAll(String regex, String replacement)：使用给定的replacement替换 * 此字符串所有匹配给定的正则表达式的子字符串 * String replaceFirst(String regex, String replacement)：使用给定的replacement替换 * 此字符串匹配给定的正则表达式的第一个子字符串 * * boolean matches(String regex)：告知此字符串是否匹配给定的正则表达式 * * String[] split(String regex)：根据给定的正则表达式的匹配拆分此字符串 * String[] split(String regex, int limit)：根据匹配给定的正则表达式来拆分此字符串，最多不超过limit个，如果 * 超过了，剩下的全部都放到最后一个元素中。 * * * @author dopphu * @create 2021-04-10 18:52 */public class Test05 &#123;    public static void main(String[] args) &#123;        String str = &quot;12asd12asd12&quot;;        System.out.println(str.replaceAll(&quot;\\\\d+&quot;,&quot;&quot;));        String tel = &quot;0571-4534289&quot;;        //判断这是否是一个杭州的固定电话        System.out.println(tel.matches(&quot;0571-\\\\d&#123;7,8&#125;&quot;));    &#125;&#125;\n\n","categories":["Java Language Basics","第九章 常用类"],"tags":[]},{"title":"","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E4%B9%9D%E7%AB%A0/0904%20String%E6%96%B9%E6%B3%952/","content":"空白\n\n\n","categories":["Java Language Basics","第九章 常用类"],"tags":[]},{"title":"0903 String方法1","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E4%B9%9D%E7%AB%A0/0903%20String%E6%96%B9%E6%B3%951/","content":"package chapter09;/** * * String方法1 * * int Length()：返回字符串的长度：return value.length * char charAt()：返回某索引处的字符return value[index] * boolean isEmpty()：判断是否是空字符串：return value.length == 0 * String toLowerCase()：使用默认语言环境，将String中的所有字符转换为小写 * String toUpperCase()：使用默认语言环境，将String中的所有字符转换为大写 * String trim()：返回字符串的副本，忽略前导空白和尾部空白 * boolean equals()：比较字符串的内容是否相等 * boolean equalsIgnoreCase(String anotherString)：与equals方法类似，忽略大小写 * String concat(String str)：将指定字符串连接到此字符串的结尾。等价于用“+” * int compareTo(String anotherString)：比较两个字符串的大小 * String substring(int beginIndex)：返回一个新的字符串，它是此字符串从beginIndex开始截取到最后的一个子字符串 * String substring(int beginIndex, int endIndex)：返回一个新字符串，它是此字符串从beginIndex开始截取到endIndex（不包含）的一个子字符串 * * * @author dopphu * @create 2021-04-10 18:03 */public class Test03 &#123;    public static void main(String[] args) &#123;        String s1 = &quot;  asd  asd  &quot;;        System.out.println(&quot;***&quot;+s1.trim()+&quot;***&quot;);        String s2 = &quot;fun&quot;;        System.out.println(s2.concat(&quot;ction&quot;));        System.out.println(s2.compareTo(&quot;f1&quot;));        String s3 = &quot;0123456&quot;;        System.out.println(s3.substring(0,5));    &#125;&#125;\n\n","categories":["Java Language Basics","第九章 常用类"],"tags":[]},{"title":"0902 一道面试题","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E4%B9%9D%E7%AB%A0/0902%20%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98/","content":"package chapter09;/** * * 一道面试题 * * 结合下面的博客理解吧(或者就是当成按值传递吧呜呜呜理解不了好难受) *https://blog.csdn.net/qq_41630866/article/details/87915501?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EOPENSEARCH%7Edefault-1.control&amp;dist_request_id=1330144.8379.16180432417820869&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EOPENSEARCH%7Edefault-1.control * @author dopphu * @create 2021-04-10 16:00 */public class Test02 &#123;    String str = new String(&quot;good&quot;);    char[] ch = &#123;&#x27;t&#x27;,&#x27;e&#x27;,&#x27;s&#x27;,&#x27;t&#x27;&#125;;    public void change(String str,char ch[])&#123;        str = &quot;test ok&quot;;        System.out.println(str);        ch[0] = &#x27;b&#x27;;    &#125;    public static void main(String[] args) &#123;        Test02 ex = new Test02();        ex.change(ex.str,ex.ch);        System.out.println(ex.str);        System.out.println(ex.ch);    &#125;&#125;\n\n","categories":["Java Language Basics","第九章 常用类"],"tags":[]},{"title":"0901 String的使用","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E4%B9%9D%E7%AB%A0/0901%20String%E7%9A%84%E4%BD%BF%E7%94%A8/","content":"package chapter09;import chapter09Test.Person;import org.junit.Test;/** * * String的使用 * * @author dopphu * @create 2021-04-10 13:24 */public class Test01 &#123;    /*    *    * 结论：    * 1.常量与常量的拼接结果在常量池。且常量池中不会存在相同内容的常量    * 2.只要其中一个是变量，结果就在堆中。（就new一个在堆里）    * 3.如果拼接的结果调用intern()方法，返回值就在常量池中    *    * */    @Test    public void test3()&#123;        String s1 = &quot;javaEE&quot;;        String s2 = &quot;hadoop&quot;;        String s3 = &quot;javaEEhadoop&quot;;        String s4 = &quot;javaEE&quot; + &quot;hadoop&quot;;        String s5 = s1 + &quot;hadoop&quot;;        String s6 = &quot;javaEE&quot;+s2;        String s7 = s1+s2;        System.out.println(s3==s4);//true        System.out.println(s3==s5);//false        System.out.println(s3==s6);//false        System.out.println(s5==s6);//false        System.out.println(s4==s6);//false        System.out.println(s7==s6);//false        System.out.println(&quot;****************&quot;);        String s8 = s5.intern();//返回值得到得到s8使用的常量池中已经存在得到“javaEEhadoop”        System.out.println(s8==s3);    &#125;    /*    *    * String的实例化的方式：    * 方式一：通过字面量的方式    * 方式二：通过 new + 构造器 的方式    *    * 面试题：String s = new String(&quot;abc&quot;);方式创建对象，在内存中创建了几个对象？    *       两个：一个是堆空间中的new出来的结构，另一个是char[]对应的常量池中的数据：&quot;abc&quot;    *    *    * */    @Test    public void test2()&#123;        //通过字面量定义的方式：此时的s1和s2的数据javaEE声明在方法区中的字符串常量池中。        String s1 = &quot;javaEE&quot;;        String s2 = &quot;javaEE&quot;;        //通过new + 构造器的方式：此时的s3和s4保存的地址值，是数据在堆空间中开辟空间以后对应的地址值。        String s3 = new String(&quot;javaEE&quot;);        String s4 = new String(&quot;javaEE&quot;);        System.out.println(s1==s2);//true        System.out.println(s1==s3);//false        System.out.println(s1==s4);//false        System.out.println(s3==s4);//false        System.out.println(&quot;********************&quot;);        Person p1 = new Person(10,&quot;javaEE&quot;);        Person p2 = new Person(101,&quot;javaEE&quot;);        System.out.println(p1.name.equals(p2.name));//true        System.out.println(p1.name==p2.name);//true        System.out.println(p1.name==s1);//true    &#125;    /*    * String：字符串，使用一对&quot;&quot;引起来表示    *    * 1.String声明为final的，不可被继承    * 2.String实现了Serializable接口，表明字符串是支持序列化的。    *           实现了Comparable接口，表明String可以比较大小    * 3.String内部定义了final char[] value用于存储字符串数据    * 4.String：代表不可变的字符序列。简称：不可变性。    *       体现： 1.当对字符串重新赋值时，需要重新指定内存区域赋值，不能使用原有的value进行赋值。    *             2.当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有value进行赋值    *             3.当调用String的replace()方法修改指定字符或字符串时，也需要重新指定内存内存区域    * 5.通过字面量的方式（区别于new）给一个字符串赋值，此时字符串值声明在字符串常量池中。    * 6.字符串常量池中是不会存储相同内容的字符串的。    *    * */    @Test    public void test1()&#123;        //常量池中没有就新建一个        String s1 = &quot;abc&quot;;//字面量的定义方式        String s2 = &quot;abc&quot;;        System.out.println(s1==s2);        s1 = &quot;hello&quot;;        System.out.println(s1);        System.out.println(s2);        System.out.println(&quot;******************&quot;);        String s3 = &quot;abc&quot;;        s3+=&quot;def&quot;;        System.out.println(s3);        System.out.println(s2);        System.out.println(&quot;********************&quot;);        String s4 = &quot;abc&quot;;        String s5 = s4.replace(&#x27;a&#x27;,&#x27;m&#x27;);        System.out.println(s4);        System.out.println(s5);    &#125;    //一个小问题    @Test    public void test4()&#123;        String s1 = &quot;javaEEhadoop&quot;;        String s2 = &quot;javaEE&quot;;        String s3 = s2 + &quot;hadoop&quot;;        System.out.println(s1 == s3);//false        final String s4 = &quot;javaEE&quot;;//s4 常量        String s5 = s4 + &quot;hadoop&quot;;        System.out.println(s1 == s5);    &#125;&#125;\n\n","categories":["Java Language Basics","第九章 常用类"],"tags":[]},{"title":"数组复制的测试","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E4%B8%89%E7%AB%A0/%E6%95%B0%E7%BB%84%E5%A4%8D%E5%88%B6%E7%9A%84%E6%B5%8B%E8%AF%95/","content":"/** * 数组复制的测试 */package chapter03;/** * @author Dopphu * */public class ArrayCopyTest &#123;\tpublic static void main(String[] args) &#123;\t\tint[] arr1,arr2;\t\tint[][] demo = new int[1][1];\t\tarr1 = new int[] &#123;11,22,33,44,55&#125;;//\t\tarr2 = new int[5];\t\tfor(int i = 0;i&lt;arr1.length; i++) &#123;\t\t\tSystem.out.print(arr1[i]+&quot;\\t&quot;);\t\t&#125;\t\tarr2 = new int[7];\t\tSystem.out.print(&quot;\\n&quot;+arr2.length);\t\tSystem.out.println();\t\t//不能称作数组的复制,只能说是赋值\t\tarr2 = arr1;\t\tfor(int i = 0; i&lt;arr2.length; i=i+2) &#123;//\t\t\tSystem.out.print(arr2[i]+&quot;\\t&quot;);\t\t\tarr2[i]=i;\t\t&#125;\t\tfor(int i = 0;i&lt;arr1.length; i++) &#123;\t\t\tSystem.out.print(arr1[i]+&quot;\\t&quot;);\t\t&#125;\t\tSystem.out.print(&quot;\\n&quot;+arr2.length);\t\t//解释了为什么二维数组的地址不能赋给一维数组的地址，因为存的不只是地址\t\tSystem.out.println(arr1);\t\tSystem.out.println(demo);\t\tSystem.out.println(&quot;-------------这样复制-------------&quot;);\t\tint arr3[];\t\tarr3 = new int[arr1.length];\t\tfor(int i = 0;i&lt;arr3.length; i++) &#123;\t\t\tarr3[i] = arr1[i];\t\t&#125;\t\t\t\t//数组的反转\t\tfor(int i = 0;i&lt;arr3.length; i++) &#123;\t\t\tSystem.out.print(arr3[i]+&quot;\\t&quot;);\t\t&#125;\t\tSystem.out.println(&quot;\\n-------------反转-------------&quot;);\t\tfor(int i = 0; i&lt;=arr3.length/2; i++) &#123;\t\t\tint temp = arr3[i];\t\t\tarr3[i] = arr3[arr3.length-i-1];\t\t\tarr3[arr3.length-i-1] = temp; \t\t&#125;\t\tfor(int i = 0;i&lt;arr3.length; i++) &#123;\t\t\tSystem.out.print(arr3[i]+&quot;\\t&quot;);\t\t&#125;\t\tif(&quot;asd&quot;.equals(&quot;asd&quot;))System.out.println(&quot;\\n他们是相同的&quot;);\t&#125;&#125;\n\n","categories":["Java Language Basics","第三章 数组"],"tags":[]},{"title":"数组中的常见异常","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E4%B8%89%E7%AB%A0/%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%B8%B8%E8%A7%81%E5%BC%82%E5%B8%B8/","content":"/** * 数组中的常见异常 * 1.角标越界 java.lang.ArrayIndexOutOfBoundsException * 2.空指针异常 java.lang.NullPointerException */package chapter03;/** * @author Dopphu * */public class ArrayExceptionTest &#123;\tpublic static void main(String[] args) &#123;\t\t//1.负数角标、越界角标//\t\tint arr[] = new int[] &#123;1,2,3&#125;;//\t\tSystem.out.println(arr[9]);//\t\tSystem.out.println(arr[-1]);//\t\t\t\t//2.空指针异常\t\tint[][] arr0 = new int[5][];//\t\tSystem.out.println(arr0[0][0]);\t\t\t\t//2.另一种情况\t\tString[] arr1 = new String[] &#123;&quot;aa&quot;,&quot;bb&quot;&#125;;\t\tarr1[0]=null;\t\tSystem.out.println(arr1[0].toString());\t&#125;&#125;\n\n","categories":["Java Language Basics","第三章 数组"],"tags":[]},{"title":"初见Arrays的方法","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E4%B8%89%E7%AB%A0/%E5%88%9D%E8%A7%81Arrays%E7%9A%84%E6%96%B9%E6%B3%95/","content":"/** * Arrays方法 */package chapter03;import java.util.Arrays;/** * @author Dopphu * */public class ArraysTest &#123;\tpublic static void main(String[] args) &#123;\t\tint[] a = &#123;1,2,3&#125;;\t\tint[] b = &#123;2,1,3&#125;;\t\tboolean isEquals = Arrays.equals(a, a);//比较两个数组是否相等\t\t\t\t//toString输出数组信息\t\tSystem.out.println(Arrays.toString(a));\t\t//fill 将指定值填充到数组当中\t\tArrays.fill(a, 10);\t\tSystem.out.println(Arrays.toString(a));\t\t//排序 sort\t\tArrays.sort(b);\t\tSystem.out.println(Arrays.toString(b));\t\t\t\t//查找索引 binarySearch\t\tint index1 = Arrays.binarySearch(b, 1);\t\tint index2 = Arrays.binarySearch(a, 10);\t\tSystem.out.println(index1);//为什么是1：二分查找的缘故，解决\t\tSystem.out.println(index2);\t&#125;&#125;\n\n","categories":["Java Language Basics","第三章 数组"],"tags":[]},{"title":"二维数组的使用","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E4%B8%89%E7%AB%A0/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E4%BD%BF%E7%94%A8/","content":"/** * 二维数组的使用： * 规定：二维数组分为外层数组的元素，内层数组的元素 * int[][] arr = new int[4][3]; * 外层元素 arr[0]，arr[1]等 * 内层元素 arr[0][0]等 *  * 数组初始化值的默认情况看 * 针对初始化方式一：比如 int[][] arr = new int[4][3]; * \t\t外层初始化值为地址值 * \t\t内层初始化值为：与一维数组初始化情况相同 * 针对初始化方式二：比如 int[][] arr = new int[3][]; * \t\t外层元素初始化值为null * \t\t内层元素初始化值为：不能调用，否则报错 *  * 基于内存结构进行理解 */package chapter03;/** * @author Dopphu * */public class ArrayTest03 &#123;\tpublic static void main(String[] args) &#123;\t\t\t\tint[][] arr0 = new int[4][3];\t\tSystem.out.println(arr0[0][0]);\t\t\t\t\t\tint[][] arr = new int [4][];\t\tSystem.out.println(arr[3]);//null\t\t//↓报错：空指针异常//\t\tSystem.out.println(arr[3][0]);\t&#125;&#125;\n\n","categories":["Java Language Basics","第三章 数组"],"tags":[]},{"title":"二维数组","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E4%B8%89%E7%AB%A0/%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/","content":"package chapter03;/** * @author Dopphu * */public class ArrayTest02 &#123;\tpublic static void main(String[] args) &#123;\t\t//初始化01\t\tint[][] arr1 = new int[5][5];\t\tSystem.out.println(arr1[0][0]);\t\t//初始化02\t\tint[][] arr2 = new int[5][];\t\tarr2[0] = new int[3];\t\t//初始化03\t\tint[] arr3[] = new int[5][5];\t\t//初始化04 \t\tint arr4[][] = new int[][] &#123;&#123;1,2,3&#125;,&#123;1&#125;&#125;;//\t\tSystem.out.println(arr3[5][0]);//报错内容如下\t\t/* 空指针异常\t\t * Exception in thread &quot;main&quot; java.lang.ArrayIndexOutOfBoundsException: Index 5 out of bounds for length 5\tat chapter03.ArrayTest02.main(ArrayTest02.java:17)\t\t*/\t\t//没有赋值的元素用null填充//\t\tSystem.out.println(arr4[1][2]);//??为什么不成功,看来子数组的长度是可以不相同的\t\tSystem.out.println(arr2[0][0]);\t\t\t\t//获取二维数组的长度\t\tSystem.out.println(arr4.length);//其实二维数组是一维数组，只是它的元素是一个数组而已\t\t\t\t//所以这样遍历二维数组\t\tfor(int i = 0; i&lt;arr4.length; i++) &#123;\t\t\tfor(int j = 0; j&lt;arr4[i].length; j++) &#123;\t\t\t\tSystem.out.print(arr4[i][j]+&quot; &quot;);\t\t\t&#125;\t\t\tSystem.out.println();\t\t&#125;\t\tSystem.out.println(arr3[0][0]);//0\t\t\t&#125;&#125;\n\n","categories":["Java Language Basics","第三章 数组"],"tags":[]},{"title":"二分查找","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E4%B8%89%E7%AB%A0/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/","content":"/** * 二分查找 * 前提：数组是有序的 */package chapter03;/** * @author Dopphu * */class BinarySearch &#123;\tpublic static void main(String[] args) &#123;\t\t// int a[] = new int[]&#123;1,2,3,5,44,66&#125;;\t\tint a[] = new int[]&#123;5,5,5,5,5,5&#125;;\t\tint dest = 5;\t\tint start=0,end=a.length-1;\t\tint mid;\t\tboolean isfind = false; \t\twhile(start&lt;=end) &#123;\t\t\tmid=(start+end)/2;\t\t\tif(dest == a[mid]) &#123;\t\t\t\tisfind = true;\t\t\t\tbreak;\t\t\t&#125;else if(dest&lt;a[mid]) &#123;\t\t\t\tend = mid-1;\t\t\t&#125;else &#123;\t\t\t\tstart = mid+1;\t\t\t&#125;\t\t&#125;\t\tif(isfind) &#123;\t\t\tSystem.out.print(&quot;找到了&quot;);\t\t&#125;\t&#125;&#125;\n\n","categories":["Java Language Basics","第三章 数组"],"tags":[]},{"title":"一维数组的声明和初始化","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E4%B8%89%E7%AB%A0/%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E5%A3%B0%E6%98%8E%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96/","content":"/** *  */package chapter03;/** * @author Dopphu *  */public class ArrayTest &#123;\tpublic static void main(String[] args) &#123;\t\t//1.一维数组的声明和初始化\t\tint num;\t\tnum = 10;\t\tint id = 1001;\t\tint[] ids;//声明\t\t//1.1静态初始化：数组的初始化和数组元素的赋值操作同时进行\t\tids = new int[] &#123;1001,1002,1003,1004&#125;;\t\t//1.2动态初始化：数组的初始化和数组元素的赋值操作分开进行\t\tString[] name = new String[3];\t\t//数组的角标从0开始，到数组长度-1\t\tname[1] = &quot;Dopphu&quot;;\t\tname[2] = &quot;户&quot;;//\t\tname[0] = &quot;符&quot;;\t\t//数组元素的默认初始值/**\t 元素类型\t\t默认值 * &gt; 整型\t\t\t0 * &gt; 浮点型\t\t0.0 * &gt; char\t\tASCII为0的字符 * &gt; boolean\tfalse * 引用数据类型 * &gt; String\t\tnull */\t\t\t\tSystem.out.println(name[0]);\t\tchar[] testc = new char[4];\t\tSystem.out.println(&quot;---&quot;+testc[0]+&quot;***&quot;);\t\t//获取长度\t\tSystem.out.println(name.length);\t\t&#125;&#125;\n\n","categories":["Java Language Basics","第三章 数组"],"tags":[]},{"title":"08 如何自定义异常类","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E4%B8%83%E7%AB%A0/08%20%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E7%B1%BB/","content":"/** * 如何自定义异常类？ * 1. 继承现有的异常结构：Exception、RuntimeException * 2. 提供全局常量：serialVersionUID （唯一标识一个类） * 3. 提供重载的构造器 */package chapter07;/** * @author Dopphu * */public class test08 &#123;&#125;class MyException extends RuntimeException&#123;\t static final long serialVersionUID = -7034897190745766939L;\t public MyException() &#123;\t\t \t &#125;\t \t public MyException(String msg) &#123; \t\t super(msg);\t &#125;&#125;\n\n","categories":["Java Language Basics","第七章 异常处理"],"tags":[]},{"title":"07 throw和throws","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E4%B8%83%E7%AB%A0/07%20throw%E5%92%8Cthrows/","content":"/** * 手动的生成一个异常对象，并抛出（throw）—— throw 和 throws不一样，一定要注意区分！！！ */package chapter07;/** * @author Dopphu * */public class Test07 &#123;\tpublic static void main(String[] args) &#123;\t\tStudent s = new Student();\t\ttry &#123;\t\t\ts.register(-100);\t\t&#125; catch (Exception e) &#123;\t\t\tSystem.out.println(e.getMessage());\t\t&#125;\t\tSystem.out.println(s);\t&#125;\t&#125;class Student&#123;\tprivate int id;\tpublic void register(int id) throws Exception &#123;\t\tif(id &gt; 0) &#123;\t\t\tthis.id = id;\t\t&#125;else &#123;\t\t\t//输出的id非法\t\t\t//手动抛出异常//\t\t\tthrow new RuntimeException(&quot;您输入的数据非法&quot;);//\t\t\tthrow new Exception(&quot;你看出现异常了&quot;);\t\t\t//试一下自己定义的异常\t\t\tthrow new MyException(&quot;不能输入负数&quot;);\t\t&#125;\t&#125;\t@Override\tpublic String toString() &#123;\t\treturn &quot;Student [id=&quot; + id + &quot;]&quot;;\t&#125;\t&#125;\n\n","categories":["Java Language Basics","第七章 异常处理"],"tags":[]},{"title":"06 抛异常方法重写的规则之一","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E4%B8%83%E7%AB%A0/06%20%E6%8A%9B%E5%BC%82%E5%B8%B8%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99%E7%9A%84%E8%A7%84%E5%88%99%E4%B9%8B%E4%B8%80/","content":"/** * 方法重写的规则之一： * 子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常 */package chapter07;import java.io.FileNotFoundException;import java.io.IOException;/** * @author Dopphu * */public class Test06 &#123;\t\tpublic static void main(String[] args) &#123;\t\tTest06 t = new Test06();\t\tt.display(new SubClass());//结合多态理解一下\t&#125;\t\tpublic void display(SuperClass s) &#123;\t\ttry &#123;\t\t\ts.method();\t\t&#125; catch (IOException e) &#123;\t\t\te.printStackTrace();\t\t&#125;\t&#125;&#125;class SuperClass&#123;\t\tpublic void method() throws IOException &#123;\t\t\t&#125;&#125;class SubClass extends SuperClass &#123;\tpublic void method() throws FileNotFoundException&#123;\t\t\t&#125;&#125;\n\n","categories":["Java Language Basics","第七章 异常处理"],"tags":[]},{"title":"05 throws + 异常类型","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E4%B8%83%E7%AB%A0/05%20throws%20+%20%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%9E%8B/","content":"/** * 异常处理方式二：throws + 异常类型 * 往上抛，让上一级处理 *  * 1. &quot;throws + 异常类型&quot;写在方法的声明处。指明此方法执行时，可能会抛出异常类型。 * 一旦方法体执行时，仍会在异常的代码处生成一个异常类的对象，此对象满足throws后异常类型时，就会抛出。 * 异常代码后续的代码就不会再执行了 *  * 2.体会：try-catch-finally真正将异常处理掉了 * \t\tthrows的方式只是将异常抛给了方法的调用者，并没有真正将异常处理掉 *  * 3.开发中如何选择try-catch-finally 还是使用throws * \t\t1）如果父类中被重写的方法没有throws方式处理异常，则子类重写的方法也不能使用throws。意味着， * \t如果子类重写的方法中有异常，必须使用try-catch-finally方式处理 * \t\t2）执行的方法中，先后有调用了另外几个方法，这几个方法是递进关系执行的，我们建议这几个方法用throws的方式 * \t进行处理，而最外层的方法可以考虑使用try-catch-finally的方式进行处理 */package chapter07;/** * @author Dopphu * */public class Test05 &#123;\tpublic static void method1() throws ArithmeticException&#123;\t\tSystem.out.println(10/0);\t&#125;\tpublic static void main(String[] args) &#123;\t\ttry &#123;\t\t\tmethod1();\t\t&#125;catch(ArithmeticException e) &#123;\t\t\t\t\t&#125;\t&#125;&#125;\n\n","categories":["Java Language Basics","第七章 异常处理"],"tags":[]},{"title":"04 try-catch-finally中finally的使用","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E4%B8%83%E7%AB%A0/04%20try-catch-finally%E4%B8%ADfinally%E7%9A%84%E4%BD%BF%E7%94%A8/","content":"/** * try-catch-finally中finally的使用 *  * 1.finally是可选的 * 2.finally中声明的是一定会被执行的代码，即使catch中又出现异常了，try中有return语句， * catch中有return语句等情况 * 3.像数据库连接，输入输出流、网络编程Socket等资源，JVM是不能自动回收的，我们需要自己手动地进行资源的释放。 * 因此，此时资源的释放，就需要声明在finally中。 *  */package chapter07;import java.io.File;import java.io.FileInputStream;import org.junit.Test;/** * @author Dopphu * */public class Test04 &#123;\t\t@Test\tpublic void test1() &#123;\t\ttry &#123;\t\t\tint a=10;\t\t\tint b=0;\t\t\tSystem.out.println(a/b);\t\t&#125;catch(ArithmeticException e)&#123;\t\t\te.printStackTrace();\t\t\tSystem.out.println(&quot;ArithmeticException&quot;);\t\t\tint add[] = new int[] &#123;1,1&#125;;\t\t\tSystem.out.println(add[9]);\t\t&#125;catch(Exception e) &#123;\t\t\te.printStackTrace();\t\t\t\t\t&#125;finally &#123;\t\t\tSystem.out.println(&quot;我帅啊&quot;);\t\t&#125;//\t\tSystem.out.println(&quot;我帅啊&quot;);//这个和finally的区别在于catch中也可能出现异常或return\t&#125;\tpublic int test2() &#123;\t\t//由于不知道蹦到哪个catch，所以每个catch都要return \t\ttry &#123;\t\t\tint a=10;\t\t\tint b=0;\t\t\tSystem.out.println(a/b);\t\t\treturn 1;\t\t&#125;catch(ArithmeticException e)&#123;\t\t\te.printStackTrace();\t\t\tSystem.out.println(&quot;ArithmeticException&quot;);\t\t\tint add[] = new int[] &#123;1,1&#125;;\t\t\tSystem.out.println(add[9]);\t\t\treturn 2;\t\t&#125;catch(Exception e) &#123;\t\t\te.printStackTrace();\t\t\treturn 3;\t\t\t\t\t&#125;finally &#123;\t\t\tSystem.out.println(&quot;我帅啊&quot;);\t\t&#125;\t&#125;\t&#125;\n\n","categories":["Java Language Basics","第七章 异常处理"],"tags":[]},{"title":"03 抓抛模型和try-catch-finally的使用","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E4%B8%83%E7%AB%A0/03%20%E6%8A%93%E6%8A%9B%E6%A8%A1%E5%9E%8B%E5%92%8Ctry-catch-finally%E7%9A%84%E4%BD%BF%E7%94%A8/","content":"/** * 一、异常的处理：抓抛模型 *  * 过程一：“抛”，程序在正常执行过程中，一旦出现异常，就会在异常代码处生成一个对应异常类的对象。 * \t\t并将此对象抛出。 * \t\t一旦抛出对象以后，其后的代码就不再执行 * 过程二：“抓”，可以理解为异常处理方式 * \t\t\t1）try-catch-finally * \t\t\t2）throws * \t\t关于异常对象的产生：\t① 系统自动生成的异常对象 * \t\t\t\t\t\t② 手动的生成一个异常对象，并抛出（throw） * 二、try-catch-finally的使用 *  * try&#123; * \t\t//可能会出现异常的代码 * &#125;catch(异常类型1 变量名1)&#123; * \t\t//处理异常的方式1 * &#125;catch(异常类型2 变量名2)&#123; * \t\t//处理异常的方式2 * &#125; * ... * finally&#123; * \t\t//一定会执行的代码 * &#125; *  * 说明: * 1.finally 是可选的 * 2.使用try将可能出现异常的代码包装起来，在执行过程中，一旦出现异常，就会生成一个对应异常类的对象， * 根据此对象的类型，去catch中进行匹配 *  * 3.一旦try中的异常对象匹配到某一个catch时，就进入catch中进行异常的处理。一旦处理完成，就跳出try-catch结构（没有finally时） *  * 4.catch中的异常类型如果没有子父类关系，则谁声明在上，谁声明在下无所谓。 * \tcatch中的异常类型如果满足子父类关系，则要求子类一定声明在父类的上面。否则，报错 *  * 5.常用的异常对象处理的方式：1）String getMessage()\t2）printStackTrace() *  * 6.在try结构中声明的变量，在出了try结构以后，就不能再被调用（非要用那就声明在外边） *  * 7.try-catch-finally结构是可以嵌套的 *  * 体会：使用try-catch-finally处理编译异常，使得程序在编译时就不再报错，但是运行时仍可能报错。 * \t\t相当于我们使用try-catch-finally将一个编译时可能出现的异常，延迟到运行时出现。 *  * 实际开发中，主要用来处理编译时异常（否则都运行不了），就不针对运行时异常编写try-catch-finally了。 *  */package chapter07;import org.junit.Test;/** * @author Dopphu * */public class Test03 &#123;\t@Test\tpublic void test1() &#123;\t\tString s1 = &quot;abc&quot;;//\t\tint i = 10/0;\t\ttry &#123;\t\t\tint num = Integer.parseInt(s1);\t\t&#125;catch(NumberFormatException n) &#123;\t\t\tn.printStackTrace();\t\t\tSystem.out.println(&quot;出现了NumberFormatException异常。&quot;+n.getMessage());//getMessage()方法，返回字符串\t\t&#125;catch(Exception e)&#123;\t\t\tSystem.out.println(&quot;Exception：出现异常了&quot;);\t\t\te.printStackTrace();\t\t&#125;\t\tfinally &#123;\t\t\tSystem.out.println(&quot;总是要执行的代码&quot;);\t\t&#125;\t\t\t&#125;&#125;\n\n","categories":["Java Language Basics","第七章 异常处理"],"tags":[]},{"title":"02 异常的体系结构","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E4%B8%83%E7%AB%A0/02%20%E5%BC%82%E5%B8%B8%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/","content":"/** * 一、异常的体系结构 *  * java.lang.Throwable * \t\t\t|------java.lang.Error：一般不编写针对性的代码进行处理。 * \t\t\t|------java.lang.Exception：可以进行异常处理 * \t\t\t\t\t&gt; 编译时异常（checked） * \t\t\t\t\t\t- IOException * \t\t\t\t\t&gt; 运行时异常（unchecked） * \t\t\t\t\t\t- NullPointerException * \t\t\t\t\t\t- ArrayIndexOutOfBoundException *  * 面试题：常见的异常有哪些？举例说明 *  *  */package chapter07;import java.util.Date;import java.util.Scanner;import org.junit.Test;/** * @author Dopphu * */public class Test02 &#123;\t//NullPointerException\t@Test\tpublic void test1() &#123;//\t\tint[] arr = null;//\t\tSystem.out.println(arr[1]);\t\t//\t\tString str = null;//\t\tSystem.out.println(str.charAt(0));\t&#125;\t//IndexOutOfBoundException\t\t@Test//\tpublic void test2() &#123;//\t\tint arr2[] = new int[]&#123;1,2,3&#125;;//\t\tSystem.out.println(arr2[9]);//\t&#125;\t\t//java.lang.ClassCastException//\tpublic void test3() &#123;//\t\tObject obj = new Date();//\t\tString str = (String)obj;//\t&#125;\t\t//NumberFormatException//\tpublic void test4() &#123;//\t\tString s1 = &quot;abc&quot;;//\t\tint num = Integer.parseInt(s1);//\t&#125;\t\t//InputMismatchException//\tpublic void test5() &#123;//\t\tScanner scan = new Scanner(System.in);//\t\tint score = scan.nextInt();//\t\tSystem.out.println(score);//\t&#125;\t\t//ArithmeticException\tpublic void test6() &#123;\t\tint a = 10;\t\tSystem.out.println(a/0);//除数为0\t&#125;\t//以上为运行时异常\t\t&#125;\n\n","categories":["Java Language Basics","第七章 异常处理"],"tags":[]},{"title":"01 Error和Exception","url":"/2023/04/14/Java%20Language%20Basics/%E7%AC%AC%E4%B8%83%E7%AB%A0/01%20Error%E5%92%8CException/","content":"/** * Error: * Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况。比如：StackOverFlowError栈溢出 *  * 一般不编写针对性的代码进行处理 *  * Exception：可以使用针对性的代码进行处理。如：空指针访问、网络连接中断、数组角标越界、试图读取不存在的文件 *  * 对于这些错误一般有两种解决方案：一是一遇到错误就终止程序；另一种方法是在编写程序时就考虑到错误的检测、错误消息的提示， * 以及错误的处理 *  * 捕获错误最理想的是在编译期间，但有的错误只有在运行时才会发生、比如：除数为0、数组下标越界等。 * \t\t&gt; 分类：编译时异常和运行时异常 */package chapter07;/** * @author Dopphu * */public class Test01 &#123;\tpublic static void main(String[] args) &#123;//\t\tmain(args);//栈溢出：java.lang.StackOverflowError\t\t\t\tInteger[] arr = new Integer[1027*1024*1024];//堆溢出： java.lang.OutOfMemoryError\t&#125;&#125;\n\n","categories":["Java Language Basics","第七章 异常处理"],"tags":[]},{"title":"Hello World","url":"/2023/04/14/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","categories":[],"tags":[]},{"title":"关于","url":"/about/index.html","content":"祝你天天开心！\n","categories":[],"tags":[]}]